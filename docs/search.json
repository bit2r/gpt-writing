[
  {
    "objectID": "unicode.html",
    "href": "unicode.html",
    "title": "\n9  유니코드와 인코딩\n",
    "section": "",
    "text": "항목\nASCII (1963)\nEUC-KR (1980s)\nCP949 (1990s)\nUnicode (1991)\n\n\n\n범위\n128개의 문자\n2,350개의 한글 문자 등\n약 11,172개의 완성형 한글 문자 등\n143,859개의 문자 (버전 13.0 기준)\n\n\n비트 수\n7비트\n8~16비트\n8~16비트\n다양한 인코딩 방식 (UTF-8, UTF-16, UTF-32 등)\n\n\n표준\nANSI, ISO/IEC 646\nKS X 2901\n마이크로소프트\nISO/IEC 10646\n\n\n플랫폼\n다양한 시스템\nUNIX 계열, 일부 Windows\nWindows 계열\n다양한 플랫폼\n\n\n문자 집합\n영문 알파벳, 숫자, 특수 문자\n한글, 영문 알파벳, 숫자, 특수 문자\n한글, 한자, 영문 알파벳, 숫자, 특수 문자\n전 세계 언어, 특수 문자, 이모티콘 등\n\n\n확장성\n확장 불가능\n한정적\n더 많은 문자 지원\n높은 확장성\n\n\n국제성\n영어 중심\n한국어 중심\n한국어 중심\n다국어 지원\n\n\n유니코드 호환성\n호환 가능 (U+0000 ~ U+007F)\n호환 불가, 변환 필요\n유니코드와 상호 변환 가능\n자체가 표준\n\n\n\n디지털 글쓰기는 내용과 상관없이 결국 텍스트로 표현되고, 텍스트는 단지 문자다. 하지만, 컴퓨터가 문자 하나를 어떻게 표현할까?\n1960년대 미국식 영문자를 컴퓨터로 표현하는 해결책은 간단했다 - 알파벳 26개(대문자, 소문자), 숫자 10, 구두점 몇개, 그리고 전신을 보내던 시절에 제어를 위해 사용된 몇개 특수 문자(“새줄로 이동”, “본문 시작”, “개행”, “경고음”, 등). 모두 합쳐도 128개보다 적어서, 아스키(ASCII) 위원회가 문자마다 7비트( \\(2^7\\) = 128)를 사용하는 인코딩으로 표준화했다. 1\n\n\n\n\n\n\n\n\n표 9.1:  출력가능한 아스키 문자표 알파벳 예시 \n  \n이진법\n      팔진법\n      십진법\n      십육진법\n      약자\n      한국어_설명\n    \n\n\n000 0000\n0\n0\n00\nNUL\nNULL\n\n\n000 0001\n1\n1\n01\nSOH\n헤더 시작\n\n\n000 0010\n2\n2\n02\nSTX\n본문 시작, 헤더 종료\n\n\n000 0011\n3\n3\n03\nETX\n본문 종료\n\n\n000 0100\n4\n4\n04\nEOT\n전송 종료\n\n\n000 0101\n5\n5\n05\nENQ\n응답 요구\n\n\n000 0110\n6\n6\n06\nACK\n긍정응답\n\n\n000 0111\n7\n7\n07\nBEL\n경고음\n\n\n000 1000\n10\n8\n08\nBS\n백스페이스\n\n\n000 1001\n11\n9\n09\nHT\n수평 탭\n\n\n\n\n\n\n\n\n\n\n이진법\n      팔진법\n      십진법\n      십육진법\n      모양\n    \n\n\n1000000\n100\n64\n40\n@\n\n\n1000001\n101\n65\n41\nA\n\n\n1000010\n102\n66\n42\nB\n\n\n1000011\n103\n67\n43\nC\n\n\n1000100\n104\n68\n44\nD\n\n\n1000101\n105\n69\n45\nE\n\n\n1000110\n106\n70\n46\nF\n\n\n1000111\n107\n71\n47\nG\n\n\n1001000\n110\n72\n48\nH\n\n\n1001001\n111\n73\n49\nI\n\n\n\n\n\n\n\n\n\n표 9.1 에 제어문자가 아닌 출력가능 아스키 문자표 중 영문 대문자 A-I까지 10개를 뽑았다.\n\n\n\n\n미국정보교환표준부호(American Standard Code for Information Interchange, ASCII)는 영문 알파벳을 사용하는 대표적인 문자 인코딩으로 컴퓨터와 통신 장비를 비롯한 문자를 사용하는 많은 장치에서 사용되며, 대부분의 문자 인코딩이 아스키에 기초하고 있다.↩︎"
  },
  {
    "objectID": "unicode.html#아스키-코드",
    "href": "unicode.html#아스키-코드",
    "title": "\n9  유니코드와 UTF-8\n",
    "section": "\n9.2 아스키 코드",
    "text": "9.2 아스키 코드\n디지털 글쓰기는 내용과 상관없이 결국 텍스트로 표현되고, 텍스트는 단지 문자다. 하지만, 컴퓨터가 문자 하나를 어떻게 표현할까?\n1960년대 미국식 영문자를 컴퓨터로 표현하는 해결책은 간단했다 - 알파벳 26개(대문자, 소문자), 숫자 10, 구두점 몇개, 그리고 전신을 보내던 시절에 제어를 위해 사용된 몇개 특수 문자(“새줄로 이동”, “본문 시작”, “개행”, “경고음”, 등). 모두 합쳐도 128개보다 적어서, 아스키(ASCII) 위원회가 문자마다 7비트( \\(2^7\\) = 128)를 사용하는 인코딩으로 표준화했다. 1\n\n\n\n\n\n\n\n\n표 9.1:  제어문자와 출력가능한 아스키 문자표 알파벳 예시 \n  \n이진법\n      팔진법\n      십진법\n      십육진법\n      약자\n      한국어_설명\n    \n\n\n000 0000\n0\n0\n00\nNUL\nNULL\n\n\n000 0001\n1\n1\n01\nSOH\n헤더 시작\n\n\n000 0010\n2\n2\n02\nSTX\n본문 시작, 헤더 종료\n\n\n000 0011\n3\n3\n03\nETX\n본문 종료\n\n\n000 0100\n4\n4\n04\nEOT\n전송 종료\n\n\n000 0101\n5\n5\n05\nENQ\n응답 요구\n\n\n000 0110\n6\n6\n06\nACK\n긍정응답\n\n\n000 0111\n7\n7\n07\nBEL\n경고음\n\n\n000 1000\n10\n8\n08\nBS\n백스페이스\n\n\n000 1001\n11\n9\n09\nHT\n수평 탭\n\n\n\n\n\n\n\n\n\n\n이진법\n      팔진법\n      십진법\n      십육진법\n      모양\n    \n\n\n1000000\n100\n64\n40\n@\n\n\n1000001\n101\n65\n41\nA\n\n\n1000010\n102\n66\n42\nB\n\n\n1000011\n103\n67\n43\nC\n\n\n1000100\n104\n68\n44\nD\n\n\n1000101\n105\n69\n45\nE\n\n\n1000110\n106\n70\n46\nF\n\n\n1000111\n107\n71\n47\nG\n\n\n1001000\n110\n72\n48\nH\n\n\n1001001\n111\n73\n49\nI\n\n\n\n\n\n\n\n\n\n표 9.1 에 아스키 문자표에 제어문자 10개와 출력가능 아스키 문자표 중 영문 대문자 A-I까지 10개를 뽑아 사례로 보여주고 있다. 즉, 문자표는 어떤 문자가 어떤 숫자에 해당하는지를 정의하고 있다."
  },
  {
    "objectID": "unicode.html#ascii-extension",
    "href": "unicode.html#ascii-extension",
    "title": "\n9  유니코드와 UTF-8\n",
    "section": "\n9.3 확장 아스키",
    "text": "9.3 확장 아스키\n아스키(ASCII) 방식으로 숫자 2, 문자 q, 혹은 곡절 악센트 ^ 를 표현하는데 충분하다. 하지만, 투르크어족 추바시어 ĕ, 그리스 문자 β, 러시아 키릴문자 Я 는 어떻게 저장하고 표현해야 할까? 7-비트를 사용하면 0 에서 127까지 숫자를 부여할 수 있지만, 8-비트(즉, 1 바이트)를 사용하게 되면 255까지 표현할 수 있다. 그렇다면, ASCII 표준을 확장해서 추가되는 128개 숫자에 대해 추가로 문자를 표현할 수 있게 된다.\n\n아스키: 0…127\n확장된 아스키: 128…255\n\n불행하게도, 영어문자를 사용하지 않는 세계 곳곳에서 많은 사람들이 시도를 했지만, 방식도 다르고, 호환이 되지 않는 방식으로 작업이 되어, 결과는 엉망진창이 되었다. 예를 들어, 실제 텍스트가 불가리아어로 인코딩되었는데 스페인어 규칙을 사용해서 인코딩한 것으로 프로그램이 간주하고 처리될 경우 결과는 무의미한 횡설수설 값이 출력된다. 이와는 별도로 한중일(CJK) 동아시아 국가들을 비롯한 많은 국가들이 256개 이상 기호를 사용한다. 왜냐하면 8-비트로 특히 동아시아 국가 문자를 표현하는데 부족하기 때문이다."
  },
  {
    "objectID": "unicode.html#ascii-unicode",
    "href": "unicode.html#ascii-unicode",
    "title": "\n9  유니코드와 UTF-8\n",
    "section": "\n9.4 유니코드",
    "text": "9.4 유니코드\n1990년대 나타나기 시작한 해결책을 유니코드(Unicode) 라고 부른다. 유니코드는 정수값을 서로 다른 수만개 문자와 기호를 표현하는데 정의한다. ’A’는 U+0041, ’가’는 U+AC00과 같이 고유한 코드 포인트를 가진다. 하지만, 파일에 혹은 메모리에 문자열로 정수값을 저장하는 방식을 정의하지는 않는다.\n각 문자마다 8-비트를 사용하던 방식에서 32-비트 정수를 사용하는 방식으로 전환하면 되지만, 영어, 에스토니아어, 브라질 포르투칼어 같은 알파벳 언어권에는 상당한 공간 낭비가 발생된다. 접근 속도가 중요한 경우 메모리에 문자당 32 비트를 종종 사용한다. 하지만, 파일에 데이터를 저장하거나 인터넷을 통해 전송하는 경우 대부분의 프로그램과 프로그래머는 이와는 다른 방식을 사용한다.\n다른 방식은 (거의) 항상 UTF-8 으로 불리는 인코딩으로, 문자 마다 가변 바이트를 사용한다. 하위 호환성을 위해, 첫 128개 문자(즉, 구 아스키 문자집합)는 바이트 1개에 저장된다. 다음 1920개 문자는 바이트 2개를 사용해서 저장된다. 다음 61,000은 바이트 3개를 사용해서 저장해 나간다.\n궁금하면, 동작 방식이 다음 표에 나타나 있다. “전통적” 문자열은 문자마다 1 바이트를 사용한다. 반대로, “유니코드” 문자열은 문자마다 충분한 메모리를 사용해서 어떤 텍스트 유형이든 저장한다. R, 파이썬 3.x 에서 모든 문자열은 유니코드다. 엄청난 바이트를 읽어오거나 저장하여 내보내려고 할때, 인코딩을 지정하는 것은 엄청난 고통이다.\n유니코드 문자열은 여는 인용부호 앞에 소문자 U를 붙여 표시한다. 유니코드 문자열을 바이트 문자열로 전환하려면, 인코딩을 명세해야만 된다. 항상 UTF-8을 사용해야만 되고, 그밖의 인코딩을 사용하는 경우 매우, 매우 특별히 좋은 사유가 있어야만 된다. 특별한 인코딩을 사용하는 경우 두번 생각해 보라."
  },
  {
    "objectID": "unicode.html#디지털-문자",
    "href": "unicode.html#디지털-문자",
    "title": "\n9  유니코드와 UTF-8\n",
    "section": "\n9.4 디지털 문자",
    "text": "9.4 디지털 문자\nUTF-8(Universal Coded Character Set + Transformation Format – 8-bit의 약자)은 앞서 정의한 유니코드를 위한 가변 길이 문자 인코딩 방식 중 하나로, 켄 톰프슨과 롭 파이크가 제작했다."
  },
  {
    "objectID": "unicode.html#웹-표준-인코딩",
    "href": "unicode.html#웹-표준-인코딩",
    "title": "\n9  유니코드와 UTF-8\n",
    "section": "\n9.3 웹 표준 인코딩",
    "text": "9.3 웹 표준 인코딩\n스마트폰의 대중화에 따라 더이상 윈도우 운영체제에서 사용되는 문자체계가 더이상 표준이 되지 못하고 여러 문제점을 야기함에 따라 유니코드 + UTF-8 체제가 대세로 자리잡고 있는 것이 확연히 나타나고 있다.\n2010년 구글에서 발표한 자료에 의하면 2010년 UTF-8 인코딩이 웹에서 주류로 부상하기 시작한 것이 확인되었다. (Davis, 2010) 웹기반 플롯 디지털 도구를 활용하여 그래프(WebPlotDigitizer)에서 데이터를 추출하여 시각화면 유사한 결과를 시각적으로 표현할 수 있다. 2010년 이후 웹에서 가장 점유율이 높은 인코딩 방식은 UTF-8으로 W3Tech 웹기술조사(Web Technology Surveys)를 통해 확인을 할 수 있다. 여기서 주목할 점은, 프랑스어, 독일어, 스페인어와 같은 서유럽 언어의 문자와 기호 표현하는 ISO-8859-1 인코딩, 종종 “Latin-1”으로 불리는 8비트 문자 인코딩이 현저히 줄고 있다는 점이다."
  },
  {
    "objectID": "unicode.html#인코딩-문제",
    "href": "unicode.html#인코딩-문제",
    "title": "\n9  유니코드와 UTF-8\n",
    "section": "\n9.1 인코딩 문제",
    "text": "9.1 인코딩 문제\n문자 인코딩은 컴퓨터가 텍스트를 바이트로 변환하거나 바이트를 텍스트로 변환하는 방법이다. 인코딩 과정에서는 다양한 문제가 발생할 수 있고, 그 중 세 가지 문제가 많이 알려져있다. 첫번째는 ’두부(Tofu)’라 불리는 상황으로, 컴퓨터가 어떤 문자를 표현해야 할지 알지만, 화면에 어떻게 출력해야 할지 모르기 때문에 빈 사각형 상자로 표시된다. 두번째는 ’문자깨짐(Mojibake, 文字化け)’이다. 특히 일본어에서 자주 발생하며, 한 인코딩 방식으로 작성된 텍스트가 다른 인코딩 방식으로 해석될 때 문자가 깨지는 현상을 의미한다. 세번째는 ’의문부호(Question Marks)’로, 특정 문자가 다른 문자로 변환될 때 발생된다. 문자집합과 인코딩 궁합이 맞지 않을 때 발생하며, 데이터 손실과 오류도 야기된다.\n\n\n세가지 인코딩 문제"
  },
  {
    "objectID": "unicode.html#문자-집합",
    "href": "unicode.html#문자-집합",
    "title": "\n9  유니코드와 UTF-8\n",
    "section": "\n9.2 문자 집합",
    "text": "9.2 문자 집합\n\n9.2.1 아스키 코드\n디지털 글쓰기는 내용과 상관없이 결국 텍스트로 표현되고, 텍스트는 단지 문자다. 하지만, 컴퓨터가 문자 하나를 어떻게 표현할까?\n1960년대 미국식 영문자를 컴퓨터로 표현하는 해결책은 간단했다 - 알파벳 26개(대문자, 소문자), 숫자 10, 구두점 몇개, 그리고 전신을 보내던 시절에 제어를 위해 사용된 몇개 특수 문자(“새줄로 이동”, “본문 시작”, “개행”, “경고음”, 등). 모두 합쳐도 128개보다 적어서, 아스키(ASCII) 위원회가 문자마다 7비트( \\(2^7\\) = 128)를 사용하는 인코딩으로 표준화했다. 1\n\n\n\n\n\n\n\n\n표 9.1:  제어문자와 출력가능한 아스키 문자표 알파벳 예시 \n  \n이진법\n      팔진법\n      십진법\n      십육진법\n      약자\n      한국어_설명\n    \n\n\n000 0000\n0\n0\n00\nNUL\nNULL\n\n\n000 0001\n1\n1\n01\nSOH\n헤더 시작\n\n\n000 0010\n2\n2\n02\nSTX\n본문 시작, 헤더 종료\n\n\n000 0011\n3\n3\n03\nETX\n본문 종료\n\n\n000 0100\n4\n4\n04\nEOT\n전송 종료\n\n\n000 0101\n5\n5\n05\nENQ\n응답 요구\n\n\n000 0110\n6\n6\n06\nACK\n긍정응답\n\n\n000 0111\n7\n7\n07\nBEL\n경고음\n\n\n000 1000\n10\n8\n08\nBS\n백스페이스\n\n\n000 1001\n11\n9\n09\nHT\n수평 탭\n\n\n\n\n\n\n\n\n\n\n이진법\n      팔진법\n      십진법\n      십육진법\n      모양\n    \n\n\n1000000\n100\n64\n40\n@\n\n\n1000001\n101\n65\n41\nA\n\n\n1000010\n102\n66\n42\nB\n\n\n1000011\n103\n67\n43\nC\n\n\n1000100\n104\n68\n44\nD\n\n\n1000101\n105\n69\n45\nE\n\n\n1000110\n106\n70\n46\nF\n\n\n1000111\n107\n71\n47\nG\n\n\n1001000\n110\n72\n48\nH\n\n\n1001001\n111\n73\n49\nI\n\n\n\n\n\n\n\n\n\n표 9.1 에 아스키 문자표에 제어문자 10개와 출력가능 아스키 문자표 중 영문 대문자 A-I까지 10개를 뽑아 사례로 보여주고 있다. 즉, 문자표는 어떤 문자가 어떤 숫자에 해당하는지를 정의하고 있다.\n\n9.2.2 확장 아스키\n아스키(ASCII) 방식으로 숫자 2, 문자 q, 혹은 곡절 악센트 ^ 를 표현하는데 충분하다. 하지만, 투르크어족 추바시어 ĕ, 그리스 문자 β, 러시아 키릴문자 Я 는 어떻게 저장하고 표현해야 할까? 7-비트를 사용하면 0 에서 127까지 숫자를 부여할 수 있지만, 8-비트(즉, 1 바이트)를 사용하게 되면 255까지 표현할 수 있다. 그렇다면, ASCII 표준을 확장해서 추가되는 128개 숫자에 대해 추가로 문자를 표현할 수 있게 된다.\n\n아스키: 0…127\n확장된 아스키: 128…255\n\n불행하게도, 영어문자를 사용하지 않는 세계 곳곳에서 많은 사람들이 시도를 했지만, 방식도 다르고, 호환이 되지 않는 방식으로 작업이 되어, 결과는 엉망진창이 되었다. 예를 들어, 실제 텍스트가 불가리아어로 인코딩되었는데 스페인어 규칙을 사용해서 인코딩한 것으로 프로그램이 간주하고 처리될 경우 결과는 무의미한 횡설수설 값이 출력된다. 이와는 별도로 한중일(CJK) 동아시아 국가들을 비롯한 많은 국가들이 256개 이상 기호를 사용한다. 왜냐하면 8-비트로 특히 동아시아 국가 문자를 표현하는데 부족하기 때문이다.\n\n9.2.3 한글 완성형과 조합형\n1980년대부터 컴퓨터를 사용하신 분이면 완성형과 조합형의 표준화 전쟁을 지켜봤을 것이고, 그 이면에는 한글 워드프로세서에 대한 주도권 쟁탈전이 있었던 것을 기억할 것이다. 결국 완성형과 조합형을 모두 포용하는 것으로 마무리 되었지만, 여기서 끝난게 끝난 것이 아니다. 유닉스 계열에서 KSC5601을 표준으로 받아들인 EUC-KR과 90년대와 2000년대를 호령한 마이크로소프트 CP949 가 있었다. 결국 대한민국 정부에서 주도한 표준화 전쟁은 유닉스/리눅스, 마이크로소프트 모두를 녹여내는 것으로 마무리 되었고, 웹과 모바일 시대는 유니코드로 넘어가서 KSC5601이 유니코드의 원소로 들어가는 것으로 마무리 되었다.\n이제 신경쓸 것은 인코딩 … utf-8 만 신경쓰면 된다. 그리고 남은 디지털 레거시 유산을 잘 처리하면 된다.\n\n\n\n\n\n\n유닉스/리눅스(EUC-KR), 윈도우(CP949)\n\n\n\nEUC-KR, CP949 모두 2바이트 한글을 표현하는 방식으로 동일점이 있지만, EUC-KR 방식은 KSC5601-87 완성형을 초기 사용하였으나, KSC5601-92 조합형도 사용할 수 있도록 확장되었다. CP949는 확장 완성형으로도 불리며 EUC-KR에서 표현할 수 없는 한글글자 8,822자를 추가한 것으로 마이크로소프트 코드페이지(Code Page) 949를 사용하면서 일반화되었다.\n\n\n\n9.2.4 유니코드\n1990년대 나타나기 시작한 해결책을 유니코드(Unicode) 라고 부른다. 예를 들어, 영어 A 대문자는 1 바이트, 한글 가는 3 바이트다. 유니코드는 정수값을 서로 다른 수만개 문자와 기호를 표현하는데 정의한다. ’A’는 U+0041, ’가’는 U+AC00과 같이 고유한 코드 포인트를 가진다. 하지만, 파일에 혹은 메모리에 문자열로 정수값을 저장하는 방식을 정의하지는 않는다.\n각 문자마다 8-비트를 사용하던 방식에서 32-비트 정수를 사용하는 방식으로 전환하면 되지만, 영어, 에스토니아어, 브라질 포르투칼어 같은 알파벳 언어권에는 상당한 공간 낭비가 발생된다. 접근 속도가 중요한 경우 메모리에 문자당 32 비트를 종종 사용한다. 하지만, 파일에 데이터를 저장하거나 인터넷을 통해 전송하는 경우 대부분의 프로그램과 프로그래머는 이와는 다른 방식을 사용한다.\n다른 방식은 (거의) 항상 UTF-8 으로 불리는 인코딩으로, 문자 마다 가변 바이트를 사용한다. 하위 호환성을 위해, 첫 128개 문자(즉, 구 아스키 문자집합)는 바이트 1개에 저장된다. 다음 1920개 문자는 바이트 2개를 사용해서 저장된다. 다음 61,000은 바이트 3개를 사용해서 저장해 나간다.\n궁금하면, 동작 방식이 다음 표에 나타나 있다. “전통적” 문자열은 문자마다 1 바이트를 사용한다. 반대로, “유니코드” 문자열은 문자마다 충분한 메모리를 사용해서 어떤 텍스트 유형이든 저장한다. R, 파이썬 3.x 에서 모든 문자열은 유니코드다. 엄청난 바이트를 읽어오거나 저장하여 내보내려고 할때, 인코딩을 지정하는 것은 엄청난 고통이다.\n유니코드 문자열은 여는 인용부호 앞에 소문자 U를 붙여 표시한다. 유니코드 문자열을 바이트 문자열로 전환하려면, 인코딩을 명세해야만 된다. 항상 UTF-8을 사용해야만 되고, 그밖의 인코딩을 사용하는 경우 매우, 매우 특별히 좋은 사유가 있어야만 된다. 특별한 인코딩을 사용하는 경우 두번 생각해 보라.\n\n\n아스키에서 유니코드로 진화과정\n\n컴퓨터가 처음 등장할 때 미국 영어권 중심 아스키가 아니고 4바이트 전세계 모든 글자를 표현할 수 있는 유니코드가 사용되었다면 한글을 컴퓨터에 표현하기 위한 지금과 같은 번거로움은 없었을 것이다. 돌이켜보면 초기 컴퓨터가 저장용량 한계로 인해 유니코드가 표준으로 자리를 잡더라도 실용적인 이유로 인해서 한글을 컴퓨터에 표현하기 위한 다른 대안이 제시됐을 것도 분명해 보인다. 초창기 영어권을 중심으로 아스키 표준이 정립되어 현재까지 내려오고, 유니코드와 UTF-8 인코딩이 사실상 표준으로 자리잡았으며, 그 사이 유닉스/리눅스 EUC-KR, 윈도우즈 CP949가 빈틈을 한동안 매우면서 역할을 담당했다.\n\n\n\n\n\n\n\n\n\n항목\nASCII (1963)\nEUC-KR (1980s)\nCP949 (1990s)\nUnicode (1991)\n\n\n\n범위\n128개의 문자\n2,350개의 한글 문자 등\n약 11,172개의 완성형 한글 문자 등\n143,859개의 문자 (버전 13.0 기준)\n\n\n비트 수\n7비트\n8~16비트\n8~16비트\n다양한 인코딩 방식 (UTF-8, UTF-16, UTF-32 등)\n\n\n표준\nANSI, ISO/IEC 646\nKS X 2901\n마이크로소프트\nISO/IEC 10646\n\n\n플랫폼\n다양한 시스템\nUNIX 계열, 일부 Windows\nWindows 계열\n다양한 플랫폼\n\n\n문자 집합\n영문 알파벳, 숫자, 특수 문자\n한글, 영문 알파벳, 숫자, 특수 문자\n한글, 한자, 영문 알파벳, 숫자, 특수 문자\n전 세계 언어, 특수 문자, 이모티콘 등\n\n\n확장성\n확장 불가능\n한정적\n더 많은 문자 지원\n높은 확장성\n\n\n국제성\n영어 중심\n한국어 중심\n한국어 중심\n다국어 지원\n\n\n유니코드 호환\n호환 가능 (U+0000 ~ U+007F)\n호환 불가, 변환 필요\n유니코드와 상호 변환 가능\n자체가 표준"
  },
  {
    "objectID": "unicode.html#localization",
    "href": "unicode.html#localization",
    "title": "\n9  유니코드와 UTF-8\n",
    "section": "\n9.5 현지화/세계화",
    "text": "9.5 현지화/세계화\n현지화(Localization)는 세계화(internationalization)의 동전의 양면과 같다. 세계화를 영어로 internationalization으로 길기 때문에 i18n으로 줄여서 현지화는 영어로 Localization으로 길기 때문에 동일한 로직으로 L10N으로 줄여 표현한다. 현지화에 해당되는 사항은 다음이 포함된다. (Oliver, 2017)\n\n문자 집합\n통화\n날씨 온도(\\(^{\\circ} C / ^{\\circ} F\\))\n길이 (킬로미터, 마일)\n날짜와 시간\n키보드 배열\n좌측에서 우축으로, 위에서 아래, 우측에서 좌측으로 텍스트 작성 방식과 문서양식\n…\n\n\n\n\n\nDavis, M. (2010). Unicode nearing 50. https://googleblog.blogspot.com/2010/01/unicode-nearing-50-of-web.html\n\n\nOliver, C. (2017). Internationalization Part I: Unicode and Character Encodings. https://slideplayer.com/slide/7684069/"
  },
  {
    "objectID": "unicode.html#utf-8",
    "href": "unicode.html#utf-8",
    "title": "\n9  유니코드와 UTF-8\n",
    "section": "\n9.3 UTF-8",
    "text": "9.3 UTF-8\nUTF-8(Universal Coded Character Set + Transformation Format – 8-bit의 약자)은 유니코드 중에서 가장 널리 쓰이는 인코딩으로, 유니코드를 위한 가변 길이 문자 인코딩 방식 중 하나로 켄 톰프슨과 롭 파이크가 제작했다.\nUTF-8 인코딩의 가장 큰 장점은 아스키(ASCII), 라틴-1(ISO-8859-1)과 호환되어, 문서를 처리하는 경우 아스키, 라틴-1 문서를 변환 없이 그대로 처리할 수 있고 영어를 비롯한 라틴계열 문서로 저장할 때 용량이 매우 작다. 이러한 이유로 많은 오픈소스 소프트웨어와 데이터를 생산하는 미국을 비롯한 유럽언어권에서 UTF-8이 많이 사용되고 있지만, 한글은 한 글자당 3바이트 용량을 차지한다.\n\n9.3.1 웹 표준 인코딩\n스마트폰의 대중화에 따라 더이상 윈도우 운영체제에서 사용되는 문자체계가 더이상 표준이 되지 못하고 여러 문제점을 야기함에 따라 유니코드 + UTF-8 체제가 대세로 자리잡고 있는 것이 확연히 나타나고 있다.\n2010년 구글에서 발표한 자료에 의하면 2010년 UTF-8 인코딩이 웹에서 주류로 부상하기 시작한 것이 확인되었다. (Davis, 2010) 웹기반 플롯 디지털 도구를 활용하여 그래프(WebPlotDigitizer)에서 데이터를 추출하여 시각화면 유사한 결과를 시각적으로 표현할 수 있다. 2010년 이후 웹에서 가장 점유율이 높은 인코딩 방식은 UTF-8으로 W3Tech 웹기술조사(Web Technology Surveys)를 통해 확인을 할 수 있다. 여기서 주목할 점은, 프랑스어, 독일어, 스페인어와 같은 서유럽 언어의 문자와 기호 표현하는 ISO-8859-1 인코딩, 종종 “Latin-1”으로 불리는 8비트 문자 인코딩이 현저히 줄고 있다는 점이다."
  },
  {
    "objectID": "unicode.html#텍스트-표현",
    "href": "unicode.html#텍스트-표현",
    "title": "\n9  유니코드와 UTF-8\n",
    "section": "\n9.4 텍스트 표현",
    "text": "9.4 텍스트 표현\n1940년대, 1950년대 펀치카드 기술로 정의된 첫번째 방식이 고정폭 레코드(fixed-width records) 를 사용하는 것으로, 각 줄마다 동일한 고정길이를 갖는다. 예를 들어, 다음 일본 전통 단시 하이쿠(haiku)를 컴퓨터로 아래와 같이 레코드 3개로 배열했다. (점 문자는 “사용되지 않음”을 의미) 이런 방식은 여전히 데이터베이스에도 사용되고 있다.\n\n일본 전통 단시 하이쿠 예시\n\nA crash reduces\nyour expensive computer\nto a simple stone.\n\n\n\n\n고정길이 일본 전통 하이쿠 표현\n\n이런 표기법은 N번째 행 앞으로 뒤로 건너뛰기 쉬운데 이유는 각 행이 동일한 크기를 갖기 때문이다. 하지만, 공간을 낭비하는 약점이 있고, 행마다 얼마나 긴 최대 길이를 갖느냐에 관계없이, 궁극적으로 더 긴 길이를 갖는 행을 기준으로 처리해야만 된다.\n시간이 흐름에 따라 개발자 대부분은 다른 표현법으로 전환했다. 전환된 표현법에 따르면 텍스트는 단지 연속된 바이트(byte)에 불과하고, 이런 연속된 바이트 일부에 “현재 라인은 여기서 종료” 라는 의미가 담겨진다. 이러한 표현법으로 일본 전통 단시 하이쿠를 다시 표현하면 다음과 같다.\n\n\n변동길이 일본 전통 하이쿠 표현\n\n회색칸이 “행의 끝(end of line)”을 의미한다. 이런 표기법은 더 유연하고, 공간을 덜 낭비하지만, N번째 행 앞으로 뒤로 건너뛰는 것은 어렵게 되었다. 이유는 각각이 다른 길이를 갖기 때문이다. 물론 행 종료를 표시하는데 무엇을 사용할지 결정해야하는 문제가 남았다. 불행히도, 유닉스에서는 행의 끝으로 개행 문자(newline) 한개, \\n으로 정했지만, 윈도우에서는 행의 끝으로 복귀문자(carriage return) 다음에 개행문자, \\r\\n 으로 정했다.\n편집기 대부분에서 이런 차이를 탐지하고 처리할 수 있지만, 유닉스와 윈도우를 모두 다뤄야 되는 프로그래머에게는 여전히 성가신 일이다. 윈도우 운영체제 파일에서 데이터를 불러읽어올 경우, 파이썬에서 \\r\\n 을 \\n 으로 전환하고, 데이터를 써서 저장할 경우 반대 방식으로 전환한다. 그러나 이미지, 소리 또는 기타 이진 파일형식에서 \\r 또는 \\n에 해당하는 문자가 우연히 포함되어 있다면, 원치 않는 변환이 발생할 수 있다."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "챗GPT 디지털 글쓰기",
    "section": "",
    "text": "1 글쓰기\n글쓰기(Writing)는 언어를 사용하여 생각이나 정보를 표현하는 과정이다. 글쓰기는 말하기와 다르게 물리적인 형태로 기록되어 남겨지며, 시간과 공간의 제약을 받지 않아 글쓰기 결과물로 다양한 (디지털) 문서형태로 담아 지적유산으로 후대에 남길 수 있다. 정보 전달, 감정 표현, 이야기 전달 등 글쓰기는 다양한 목적을 갖고 있으며 최근에는 기계와 의사소통을 위해 강조되고 있는 교육용 파이썬, 데이터 과학 및 과학연구를 위한 R 프로그래밍도 글쓰기 범주에 포함되고 있다.\n글쓰기는 정보 전달의 가장 기본적인 방법 중 하나로, 시간과 공간의 제약을 받지 않는 특징이 있다. 물론 글쓰기 결과물에 담긴 문서에는 그 시대 시간적 공간적 특성도 담겨있다.\n글쓰기를 통해 우리는 지식을 전달하고, 이야기를 전달하며, 감정을 표현할 수 있다. 또한 글쓰기를 통해 우리는 법률 문서와 계약서 등을 작성하여 사회적인 규칙과 약속을 정할 수 있고, 현대 사회를 지탱하는 과학기술지식도 글쓰기가 시작점이 된다. 인공지능 기술의 비약적인 발전으로 프로그래밍을 통한 코딩도 기계와 규칙을 정해 상호 커뮤니케이션하는 글쓰기로 부각되고 있다. 이러한 이유로 글쓰기는 매우 중요한 역할을 하고, 글쓰기 없이 고도화된 현대 사회생존은 불가능하다."
  },
  {
    "objectID": "index.html#디지털-문서-제작-패러다임",
    "href": "index.html#디지털-문서-제작-패러다임",
    "title": "챗GPT 디지털 글쓰기",
    "section": "1.1 디지털 문서 제작 패러다임",
    "text": "1.1 디지털 문서 제작 패러다임\n신속하고 빠르게 누구나 짧은 학습을 통해서 문서를 저작하고 출판할 수 있는 방식으로 인기를 얻은 아래한글 혹은 MS워드 워드프로세서를 사용하는데 이는 위지위그(WYSIWYG: What You See Is What You Get, “보는 대로 얻는다”)에 기초한 것으로 문서 편집 과정에서 화면에 포맷된 낱말, 문장이 출력물과 동일하게 나오는 방식이다. 이전 타자기 대비 경쟁력이 있었고 이를 바탕으로 문서편집기 소프트웨어가 대세로 떠올랐다.\n위지윅의 대척점에 있는 것이 위지윔(WYSIWYM, What You See Is What You Mean)으로 대표적인 것인 \\(LaTeX\\) 으로 구조화된 방식으로 문서를 작성하면 컴파일을 통해서 최종 문서가 미려한 출판가능한 PDF, PS, DVI 등 확장자를 갖는 출판결과물을 얻을 수 있다.\n\\(LaTeX\\)이 갖는 장점은 이제 프로그래밍 코드(R / 파이썬 / SQL / 쉘스크립트 / 자바스크립트 등)을 문서저작에 포함되며 literate programming 패러다임이 대세로 떠올랐고 현존하는 다양한 문서저작 문제에 대한 응답으로 자리를 매김하고 있다. 1"
  },
  {
    "objectID": "index.html#문서로-보는-민주주의",
    "href": "index.html#문서로-보는-민주주의",
    "title": "챗GPT 디지털 글쓰기",
    "section": "1.2 문서로 보는 민주주의",
    "text": "1.2 문서로 보는 민주주의\n대한민국은 권력을 입법권, 행정권, 사법권으로 나눠 권력을 나누었다. 세부적으보 보면 다소 차이는 있겠지만 법을 만드는 것은 결국 문서를 저작하는 것이고 대한민국 정부는 법에 담긴 문서를 실행하는 기관이고 사법부는 법 문서를 해석하는 기관으로 볼 수 있다. 결국 민주주의는 문서를 기반으로 존립하는 사회체계라고 볼 수 있다. 최근 들어 인공지능이 부상하면서 문서저작을 보조하던 수단에서 이제는 사람보다 더 나은 통찰력을 보이는 분야도 속속 등장하고 있다. 이런 측면에서 인공지능 기계를 현 민주주의 체계 내에 어떻게 녹여낼 것인지 관심이 높아지고 있다."
  },
  {
    "objectID": "index.html#디지털-문서-저작",
    "href": "index.html#디지털-문서-저작",
    "title": "챗GPT 디지털 글쓰기",
    "section": "1.3 디지털 문서 저작",
    "text": "1.3 디지털 문서 저작\n과거 둘로 쪼개져서 과학기술 문서저작 즉 논문 등은 \\(LaTeX\\) 기반 위지윔(WYSIWYM) 패러다임이 확고한 자리를 잡았지만 위지위그(WYSIWYG) 패러다임 기반 아래한글 워드와 같은 문서저작편집기 성능이 높아지면서 사실상 둘 사이 경계도 허물어졌다.\n하지만, 과학기술 논문 저작에 진실성, 재현성 등이 강조되고 빅데이터 기반 과학연구가 큰 성과를 보이고 프로그래밍이 과학기술 논문 저작에 주요한 역할을 하면서 이런 추세를 반영한 과학기술 저작 패러다임이 떠오르고 있다.\n이러한 추세를 반영한 도구의 발전도 함께 이뤄지면서 과학기술 저작은 물론 거의 모든 문서 저작분야에 큰 변화가 일어나고 있다."
  },
  {
    "objectID": "index.html#과학문서-저작",
    "href": "index.html#과학문서-저작",
    "title": "챗GPT 디지털 글쓰기",
    "section": "1.4 과학문서 저작",
    "text": "1.4 과학문서 저작\n\n심각한 현재상황\n마크다운 기초\n고급 마크다운\n문서저작 실무\n수학 수식"
  },
  {
    "objectID": "index.html#사례-한국-r-컨퍼런스2021",
    "href": "index.html#사례-한국-r-컨퍼런스2021",
    "title": "챗GPT 디지털 글쓰기",
    "section": "1.5 사례: 한국 R 컨퍼런스(2021)",
    "text": "1.5 사례: 한국 R 컨퍼런스(2021)\n\n컨퍼런스 웹사이트\n컨퍼런스 전 기획\n\n컨퍼런스 포스터\n컨퍼런스 후원\n\n컨퍼런스 본 행사\n\n발표 슬라이드\n발표 템플릿\n\n컨퍼런스 후 설문\n\n설문조사 보고서\n\n기타\n\n탄소중립 신재생 에너지 캠프"
  }
]