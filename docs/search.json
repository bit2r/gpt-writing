[
  {
    "objectID": "colors.html#color-mechanism",
    "href": "colors.html#color-mechanism",
    "title": "\n13  색상\n",
    "section": "\n13.1 시각화 메커니즘 1\n",
    "text": "13.1 시각화 메커니즘 1\n\n크게 보면 기계 즉, 컴퓨터가 색을 이해하고 표현하는 RGB 체계와 사람이 색을 인지하고 이해하는 HCL 체계로 나누어 진다. 2진수로 표현된 시각적 데이터는 RGB 16진수로 변환되어 모니터에 표시되고, 물리적 광자(photon)로 사람눈에 위치한 망막에 꽂히게 되고, 사람은 뇌에서 인지한 후에 이를 처리하여 시각적인 정보를 인식하게 된다.\n따라서, 사람뇌에 인식할 수 있는 시각적인 정보로 데이터를 구성해야만 다양한 종류의 모니터를 통해 효율적이고 효과적으로 정보가 전달될 수 있다.\n\n\n시각적 인지 메커니즘\n\n\n13.1.1 16진수 RGB 표색법\n양수 숫자나 크레파스 명칭 대신에, 일반적이고 컴퓨터가 읽어들일 수 있는 색상 표색법이 16진수 팔레트다. Cynthia Brewer 는 펜실베니아 대학에서 교수로 색상이론과 시각화에 관련된 전문분야를 갖고 있으며 특히, ColorBrewer 으로 알려진 색생체계는 웹, 출판, 색맹을 고려하여 널리 쓰이고 있다. ColorBrewer 색상체계를 R에서 시각화를 할 때 사용될 수 있게 만든 것이 RColorBrewer 패키지다. RColorBrewer Dark2 팔레트를 통해 실제로 구현된 색상체계를 살펴보자.\n\nlibrary(RColorBrewer)\nbrewer.pal(n = 8, name = \"Dark2\")\n\n[1] \"#1B9E77\" \"#D95F02\" \"#7570B3\" \"#E7298A\" \"#66A61E\" \"#E6AB02\" \"#A6761D\"\n[8] \"#666666\"\n\n\n# 기호는 관례로 붙이는 것이고, 16진수 문자열을 다음과 같이 파싱한다: #rrggbb에서 rr, gg, bb 각각은 적색, 녹색, 청색 채널에 대한 생상농도를 나타낸다. 각 색상은 2를 밑으로 하는 16개 숫자를 나타내고, “16진수(hexadecimal)” 혹은 줄여서 헥스(hex)로 부른다. 다음에 밑을 10으로 하는 십진수와 16진수 비교표가 다음에 나와 있다.\n\n\n\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\nA\nB\nC\nD\nE\nF\n\n\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n예를 들어, 팔렛트 첫 색상이 #1B9E77으로 명세되어 있다. 따라서, 녹색 채널 색상농도는 9E가 된다.\n\\[ 9E = 9 * 16^1 + 14 * 16^0 = 9 * 16 + 14 = 158 \\]\n무슨 뜻일까? 해당 채널의 가장 낮은 값은 00=0 이 되고, 가장 높은 값은 FF=255 가 된다.\n도움이 되는 기억해야될 중요한 사례가 다음에 나타나 있다. 적색, 녹색, 청색에 대한 강렬한 RGB 색상은 다음과 같다.\n\n\n\n색상\n헥스코드\n붉은색\n녹색\n파란색\n\n\n\nblue\n#0000FF\n0\n0\n255\n\n\ngreen\n#00FF00\n0\n255\n0\n\n\nred\n#FF0000\n255\n0\n0\n\n\n\n\n다음에 흑백, 회색을 표현한 것이 나타나 있다.\n\n\n\n색상\n헥스코드\n붉은색\n녹색\n파란색\n\n\n\nwhite, gray100\n#FFFFFF\n255\n255\n255\n\n\ngray67\n#ABABAB\n171\n171\n171\n\n\ngray33\n#545454\n84\n84\n84\n\n\nblack, gray0\n#000000\n0\n0\n0\n\n\n\n\n“gray” 회색으로 치환하게 되면, “gray”를 보게되는 어느 곳에서나 동일한 결과를 얻게 됨에 주목한다. 모든 채널을 최대값으로 하면 흰색, 모든 채널을 최소값으로 하면 검정색이 된다.\n\n\nR에서 색상을 지정하는 방법\n\n\n양의 정수: palette()함수로 조작하거나 검색한 현재 색상 팔레트에 인덱스를 사용.\n\n색상 명칭: colors() 함수로 검색된 색상\n\n16진수 문자열: 16진수로 구성된 3개조에 추가해서, 알파 투명도를 나타내는 네번째 채널을 넣어 16진수 4개조로 구성된 생상표로 확장하기도 한다.\n\n\nrgb(), col2rgb(), convertColor() 함수도 유용하니, 자세한 내용은 도움말을 참조한다."
  },
  {
    "objectID": "colors.html#dataviz-mechanism-hcl",
    "href": "colors.html#dataviz-mechanism-hcl",
    "title": "\n13  색상\n",
    "section": "\n13.2 RGB 색상모형 대안 - HCL\n",
    "text": "13.2 RGB 색상모형 대안 - HCL\n\nRGB 색공간과 색상모형이 유일무이하고 가장 최고는 아니다. 컴퓨터 화면에 색상을 표현하는데는 자연스럽지만, 일부 영역에서 색상을 선택하는 작업에는 이런 모형을 적용하기 어렵다. 예를 들어, 사람이 구별하기는 쉽지만, 인지적으로 색상별로 비교되는 생각으로 구성된 정성적인 팔레트를 만들어 내는 방법은 명확하지 않다. 컴퓨터에 사용되는 색상을 기술하는데 RGB를 사용하지만, 사람이 색상체계를 구축하는 색공간에 RGB체계를 사용할 이유는 없다. 이점은 사람과 컴퓨터가 다른 것이고, 이를 인정해야만 된다.\n색상모형은 일반적으로 RGB와 마찬가지로 세가지 차원으로 구성된다. 이는 망막에 세가지 다른 수용체를 인간이 갖는 생리적 사실에 기인한다. RGB와 인간 시각 체계에 대한 자세한 정보는 블로그를 참고한다. 색상모형의 차원이 사람이 인식할 수 있는 식별가능한 정보량에 더 가까이 부합되면 될수록, 더욱 유용하다. 이런 부합성이 사려깊게 작성된 팔레트 생성을 가능하게 하고, 더불어 특정한 특성을 갖는 색공간에 대한 길을 연다. RGB 색체계는 인간의 인식체계와 일치성이 떨어진다. 적색, 녹색, 청색광을 탐지할 수 있는 광수용체를 갖기 때문에, 색을 인지하는 체험이 RGB 방식으로 분해된다는 것을 의미하지 않는다. 적색과 녹색을 섞은 것으로 황색을 인식하는 체험을 했는가? 물론 아니다. 생리학적인 현실은 그렇다. 또다른 RGB 대안 모형이 HSV(Hue-Saturation-Value, 색상-채도-명도)모형이다. 불행하게도, 색을 선택하는데 문제가 많은데, 이유는 색상이 서로 중첩되는 차원을 갖기 때문이다.\n사람이 인지하기 좋은 색모형은 무엇일까? CIELUV 와 CIELAB 이 가장 잘 알려진 사례다. CIELUV의 변종인 HCL(Hue-Chroma-Luminance, 색상-채도-휘도) 모형을 좀더 살펴보자. Zeileis와 동료들이 R 사용자를 위한 팩키지로 멋지게 작성했다.2 colorspace R 팩키지에 딸려있고, HCL 색상모형을 탐색하고 이용하는데 도움을 준다. 마지막으로, HCL 색모형이 ggplot2에 RColorBrewer와 마찬가지로 잘 녹여져있다.\n\n\nHCL 색상모형의 세가지 차원\n\n\n색상(Hue) : 색상은 일반적으로 “색상이 뭐지?”라고 생각할 때 생각나는 것이다. 이해가 바로되는 쉬운 것이다! 각도로 주어지고 따라서 0 에서 360 까지 값을 갖는데, 무지개 도넛을 상상하면 된다.\n\n채도(Chroma) : 채도는 색상이 얼마나 순수한지 혹은 생생한지 나타낸다. 특정 색상이 회색과 섞일 수록, 채도는 떨어진다. 가장 낮은 값은 0 으로 회색 그자체에 대응되고, 최대값은 휘도에 따라 변한다.\n\n휘도(Lumiance) : 휘도는 명도(brightness), 명도(Lightness), 광도(intensity), 명도(value)와 관련된다. 낮은 휘도는 어두움을 의미하고, 진짜 검정색은 휘도가 0 이다. 높은 휘도는 밝음을 의미하고, 진짜 흰색은 휘도가 1 이다.\n\n\n저자는 채도와 휘도를 이해하고 구별하는데 힘든 시간을 보냈다. 위에서 살펴봤듯이, 색체계는 서로 독립된 것이 아니고, 3차원 HCL 공간에 기이한 모형으로 정보를 제공하고 있다.\n위캠의 ggplot2 책에 나온 6.6 그림이 HCL 색공간을 이해하는데 도움이 된다.\n\n\nggplot2 HCL 색공간\n\n위캠 책에 언급된 내용을 다시 적으면 다음과 같다: 각 측면, 창은 휘도에 따라 가장 낮은 값에서 높은 값 순으로 HCL 공간을 슬라이스로 나누어 도식화한 것을 보여주고 있다. 0 과 100 극단 휘도값은 생략되었는데, 이유는 각각 검은 점과 흰점으로 나타나기 때문이다. 슬라이스 내부에, 중심은 채도가 0 으로, 회색에 대응된다. 슬라이스 끝쪽으로 이동하면, 채도가 증가하고, 색상이 더 순색에 가까워지고 농도가 짖어진다. 색상은 각도로 매핑된다.\ncolorspace 팩키지에 가치있는 기여는 아마도 함수를 사용해서 색상공간을 합리적 방식으로 색공간을 이리저리 돌아다닐 수 있게 만든 것이다. 이와는 대조적으로 RColorBrewer 팩키지가 제공하는 팔레트는 정교하게 제작되었지만, 불행히도 고정이다.\n인지기반 색상체계를 사용하는 것에 대한 옹호 사례와 더불어 색공간에 0 이 자리하는 것을 알려주는 중요성을 시연하고 있다.\n\n“Why Should Engineers and Scientists Be Worried About Color?”"
  },
  {
    "objectID": "colors.html#viz-printer-cmyk",
    "href": "colors.html#viz-printer-cmyk",
    "title": "\n13  색상\n",
    "section": "\n13.3 프린터 색상모형: CMYK 3 4\n",
    "text": "13.3 프린터 색상모형: CMYK 3 4\n\nCMYK 색상표는 시안(Cyan), 마젠타(Magenta), 옐로(Yellow), 블랙(Black = Key)를 원색으로 하여 명도가 낮아지는 감산혼합으로 주로 출력물 인쇄 혹은 사진 필림 현상에 사용되며 쿼크익스프레스, 일러스트레이터, 포토샵 등에서 CMYK 감산혼합을 지원한다. 현실적인 문제 때문에 RGB나 HSB(HSV)보다 표현 가능한 색이 적은 것으로 알려져 있다.\n학창시절 감산혼합의 색의 3원색은 빨강, 노랑, 파랑인데, CMYK는 생뚱맞게도 시안(Cyan), 마젠타(Magenta), 옐로(Yellow), 블랙(Black = Key)을 원색으로 하는데 이유는 빨강은 사실 자홍색(마젠타), 파랑은 청록색(시안)이라 정확한 색상이 후자가 맞다. 우리가 잘못 배운 탓이 크다.\nRGB 생상과 CMYK 생상을 PDF 파일로 찍어 상호 비교해보자. 5\n\n\nRGB 색상 출력\n\npdf(\"data/color_rgb.pdf\")\nRColorBrewer::display.brewer.all(type=\"qual\")\ndev.off()\n\n\n\n\n\nCMYK 색상 출력\n\npdf(\"data/color_cmyk.pdf\", colormodel = \"cmyk\")\nRColorBrewer::display.brewer.all(type=\"qual\")\ndev.off()"
  },
  {
    "objectID": "colors.html#dataviz-color-brewer-viridis",
    "href": "colors.html#dataviz-color-brewer-viridis",
    "title": "\n13  색상\n",
    "section": "\n13.4 RColorBrewer 와 viridis\n",
    "text": "13.4 RColorBrewer 와 viridis\n\n\n13.4.1 RColorBrewer\n색상선택이 가장 논란이 많고, 이리저리 만지작 거리면서 정말 많은 시간을 보내는 분야다. 지리학자이며 생상 전문가 Cynthia Brewer 교수가 출판과 웹에서 사용되는 색상표를 제작했고, 이는 RColorBrewer 팩키지에 반영되어 있다. 팩키지를 설치하고 사용하면 된다. 연관된 전체 팔레트를 살펴보는 명령어는 display.brewer.all() 이다.\n\nlibrary(RColorBrewer) # install.packages(\"RColorBrewer\")\ndisplay.brewer.all()\n\n\n\n\n\n\n\n팔레트는 종류가 많지만 다음 세가지 범주에 속한다. 위에서 아래부터 다음과 같다.\n\n\n순차적(sequential) : 낮은 것에서 높은 것으로 한쪽 극단이 흥미롭고 반대쪽 극단이 재미없는 것을 시각화하는데 매우 좋다. 예를 들어 p-값, 상관계수 (주의: 상관계수 1 이 흥미로운 것은 양수를 가정했다)\n\n정량적(quantitative) : 순서가 없는 범주형 자료를 시각화할 때 유용하다. 예를 들어, 국가나 대륙. 특수한 “쌍을 이룬” 팔레트가 있다; 예를 들어, 곡물 밀 유형같이 실험이 아닌 요인, 실험군과 대조군 같은 이진 실험 요인.\n\n발산하는(diverging) : 극단의 음수에서 극단의 양수까지 범위를 같는 것을 시각화하는데 유용한다. 이런 데이터는 극단의 값이 중간에 위치한 덜 흥미로운 지점을 지난다. 예를 들어, t-통계량, z-점수, 상관계수가 이에 속한다.\n\n명칭을 명세해서 RColorBrewer 팔렛트 하나만 볼 수 있다.\n\ndisplay.brewer.pal(n = 8, name = 'Dark2')\n\n\n\n\n\n\n\n\n13.4.2 viridis\n2015년 Stéfan van der Walt 와 Nathaniel Smith는 파이썬 matplotlib 팩키지에 사용될 새로운 색상 지도를 설계했고, SciPy 2015에서 발표했다. viridis 팩키지로 인해 R에 4가지 신규 팔레트가 추가되었다. CRAN과, GitHub에서 팩키지를 만날 수 있다.\n\n\n\n\n\n\n\n\n\n\nviridis 색상표는 완벽하게 균등하게 지각되도록 설계되었고, 정규형식에서나 흑백으로 전환되었을 때도 마찬가지다. 또한 색망을 갖는 독자도 올바르게 지각될 수 있도록 설계되었다.\n\n\n아직 나온지 얼마되지 않아서, 자세한 사항은 viridis 팩키지를 설치하고 소품문을 읽고 직접 경험하기 바란다.\n\n13.4.3 색맹을 갖는 사람\ndichromat 팩키지(CRAN)는 2색시자에 대한 효과적인 색상조합을 선택하는데 도움이 된다.\n\nlibrary(dichromat) # install.packages(\"dichromat\")\n\ncolorschems 목록에는 17 가지 색상조합이 담겨있는데, 적색과 녹색을 구별하는 능력이 없거나 예외적인 시력을 갖는 2색시자에게 적합하다.\n\n\n\n\n\n\n\n\ndichmat() 함수는 색상을 변환해서 다른 형태의 색맹에 근사적인 효과를 구현할 수 있어서, 후보 색상조합에 대한 효과를 평가할 수 있게 한다. data(\"dalton\") 명령어는 256 색상 팔레트를 표현하는 객체를 생성하는데, 정상 시야로 표현되는 것과, 적록(red-green) 색맹과 청녹(green-blue) 생맹으로 표현되는 것이다.(rogowitz1996ibm?)\n\npal_name &lt;- names(tvthemes:::stevenUniverse_palette)\n\nshow_all_pal &lt;- function(pal_name) {\n  exp_pal &lt;- paste0(\"tvthemes:::stevenUniverse_palette$\", pal_name)\n  \n  pal_call &lt;- eval(expr = parse(text = exp_pal))\n  \n  return(scales::show_col(pal_call))\n}\n\npurrr::walk(pal_name, ~ show_all_pal(pal_name = .x))\n\nRColorBrewer는 ColorBrewer 2.0에서 제공하는 색상 팔레트에 기반한 R 색상 패키지다. 데이터 시각화를 위한 다양한 색상 조합을 제공하며, 데이터 시각화 가독성과 해석력을 향상을 위한 발산(diverging), 연속(sequential), 범주형(qualitive) 데이터 유형에 대한 적합한 색상 팔레트가 포함되어 있다.\n\nlibrary(RColorBrewer)\n\npar(mfrow=c(1 ,3))\ndisplay.brewer.all(type=\"div\")  # 양쪽발산(diverging)\ndisplay.brewer.all(type=\"seq\")  # 연속형(sequential)\ndisplay.brewer.all(type=\"qual\") # 범주형(qualitive)\n\n\n\n\n\n\ndev.off()\n\nnull device \n          1 \n\n\npenguins 데이터셋을 활용하여 각 섬별로 펭귄의 수를 집계한 다음, Torgersen 섬의 이름을 NA(결측값)으로 변경한다. 변경된 데이터를 바탕으로 ggplot2 패키지를 사용해 막대 그래프를 생성하며, 섬의 이름을 x축에, 각 섬의 펭귄 수를 y축에 배치하고, 각 막대는 해당 섬의 이름에 따라 다른 색상으로 채워운다. 결측값(여기서는 Torgersen 섬)은 회색으로 표시되며, 나머지 색상은 RColorBrewer의 “Accent” 팔레트를 사용하여 색을 채워넣는다.\n\nlibrary(palmerpenguins)\nlibrary(tidyverse)\n\npenguins |&gt; \n  count(island) |&gt; \n  mutate(island = if_else(island ==  \"Torgersen\", NA_character_, island)) |&gt; \n  ggplot(aes( x = island, y = n, fill = island)) +\n    geom_col() +\n    scale_fill_brewer(palette=\"Accent\", na.value=\"grey50\")"
  },
  {
    "objectID": "colors.html#정당-색상",
    "href": "colors.html#정당-색상",
    "title": "\n13  색상\n",
    "section": "\n13.5 정당 색상",
    "text": "13.5 정당 색상\n더블어민주당, 국민의힘, 정의당 웹사이트에서 각 정당 로고 및 주된 로고 색상을 확인할 수 있다. 이를 바탕으로 정당별 시각화 제작에 사용될 색상으로 팔레트를 생성하여 활용한다.\n\n# 각 정당별 색상\n민주당_2색상 &lt;- c(\"#00A0E2\", \"#004EA1\")\n민주당_4색상 &lt;- c(\"#8AC452\", \"#00AA7D\", \"#008CCD\", \"#004EA1\")\n\n국힘_3색상 &lt;- c(\"#FFFFFF\", \"#E61E2B\", \"#00B5E2\")\n국힘_6색상 &lt;- c(\"#EDB19D\", \"#F18070\", \"#BDE4F8\", \"#004C7E\", \"#112C56\")\n\n정의당_3색상 &lt;- c(\"#ffed00\", \"#e8306d\", \"#00a366\", \"#623e91\")\n\n무소속_색상 &lt;- \"#999999\"\n\n# 정당, 색상코드, 시각화\nparty_palette &lt;- c(\"민주당\" = 민주당_2색상[2], \n                   \"국민의힘\" = 국힘_3색상[2], \n                   \"정의당\" = 정의당_3색상[1], \n                   \"무소속\" = 무소속_색상)\n\ndf_colors &lt;- data.frame(\n  party = names(party_palette),\n  color = party_palette\n)\n\nggplot(df_colors, aes(x = 1, y = party, fill = color)) +\n  geom_tile() +\n  scale_fill_identity() +\n  theme_void() +\n  coord_fixed(ratio = 0.1) +\n  geom_text(aes(label = str_glue(\"{party} - {color}\")))\n\n\n\n\n\n\n\n정당별 색상을 반영한 데이터 시각화 그래프 제작을 위해서 난수를 생성한 정당별 지지율 데이터를 만든 후에 정당색상을 반영한 그래프를 제작한다.\n\nparty_name &lt;- c(\"민주당\", \"국민의힘\", \"정의당\", \"무소속\")\nvotes &lt;- c(runif(1, min=.4, max=.5),\n           runif(1, min=.4, max=.5),\n           runif(1, min=.0, max=.05),\n           runif(1, min=.0, max=.05))\n\ntibble(party_name, votes) |&gt; \n  mutate(party_name = factor(party_name, levels = c(\"민주당\", \"국민의힘\", \"정의당\", \"무소속\"))) |&gt; \n  ggplot(aes(x = party_name, y = votes, fill = party_name)) +\n    geom_col() +\n    scale_fill_manual(values = party_palette) +\n    scale_y_continuous(labels = scales::percent) +\n    labs(x = \"\",\n         y = \"지지율\",\n         fill = \"정당명\",\n         title = \"정당별 지지율\")"
  },
  {
    "objectID": "colors.html#이미지-색상",
    "href": "colors.html#이미지-색상",
    "title": "\n13  색상\n",
    "section": "\n13.6 이미지 → 색상",
    "text": "13.6 이미지 → 색상\n이미지에서 색상을 출력한 후에 이를 팔레트로 만들어서 시각화한 사례를 만들어보자. 태극기에서 가장 많은 색상을 선택하여 16진수 색상코드를 추출한다. magick 패키지와 생상에서 데이터프레임 변환을 위해 imager 패키지를 사용해서 변환한다. 6\n\nlibrary(scales)\nlibrary(imager)\nlibrary(magick)\n\nflag_svg &lt;- image_read_svg(\"images/korean_flag.svg\")\n\nflag_palette &lt;- flag_svg |&gt; \n  image_resize(\"500\") |&gt; \n  image_quantize(max = 4, colorspace=\"RGB\") |&gt; \n  magick2cimg() |&gt; \n  RGBtoHSV() |&gt; \n  as.data.frame(wide=\"c\") %&gt;%  #3 making it wide makes it easier to output hex colour\n  mutate(hex=hsv(rescale(c.1, from=c(0,360)),c.2,c.3),\n         hue = c.1,\n         sat = c.2,\n         value = c.3) %&gt;%\n  count(hex, hue, sat,value, sort=T) %&gt;% \n  mutate(colorspace = \"RGB\") |&gt; \n  pull(hex)\n\nflag_colors_gg &lt;- tibble(colors = flag_palette) |&gt; \n  ggplot(aes(x = 1, y = 1:length(flag_palette), fill = colors)) + \n    geom_tile() +\n    scale_fill_identity() +\n    theme_void() + \n    coord_fixed(ratio = 0.2) +\n    geom_text(aes(label = str_glue(\"{colors}\")))  \n\n태극기 이미지를 ggplot으로 시각화한다.\n\nlibrary(ggimage)\n\nflag_image_gg &lt;- ggplot() +\n  geom_image(aes(x=0, y=0, image=\"images/korean_flag.svg\"), size=1) +\n  coord_cartesian(xlim=c(-1, 1), ylim=c(-1, 1)) +\n  theme_void()  \n\n태극기에서 추출한 색상을 바탕으로 막대그래프에 색상을 입혀 시각화한다.\n\nflag_penguin_gg &lt;- penguins |&gt; \n  count(island) |&gt; \n  mutate(island = if_else(island ==  \"Torgersen\", NA_character_, island)) |&gt; \n  ggplot(aes( x = island, y = n, fill = island)) +\n    geom_col() +\n    scale_fill_manual(values = flag_palette[2:4], na.value=\"grey50\") +\n    theme(legend.position = \"top\")\n\n태극기, 태극기 색상, 막대그래프 시각화를 한번에 요약하여 시각화한다.\n\nlibrary(patchwork)\n\nprint((flag_image_gg + flag_colors_gg) / flag_penguin_gg)"
  },
  {
    "objectID": "preface.html",
    "href": "preface.html",
    "title": "서문",
    "section": "",
    "text": "끊임없이 진화하는 인간 커뮤니케이션 환경에서 디지털 시대의 도래는 표현과 연결의 새로운 차원을 가져왔습니다. 디지털 불평등 격차해소를 추구하고 디지털 영역의 무한한 잠재력을 포용하는 작가로서, “디지털 글쓰기”를 여러분께 소개합니다. 이 책은 창의성, 기술, 인간 정신이 융합된 공간인 디지털 글쓰기의 광활하고 길들여지지 않은 경계를 탐험하고자 하는 사람들을 위한 안내서이자 동반자 역할을 합니다.\n새 시대에 등장한 다양한 플랫폼, 형식, 도구를 살펴보면서 온라인 글쓰기의 세계가 제시하는 독특한 기회와 도전 과제에 대해 자세히 살펴볼 것입니다. 이 책은 단순한 기술 매뉴얼이 아니라 말과 아이디어의 힘, 그리고 디지털 광야에 과감히 도전하는 사람들을 기다리는 무한한 가능성에 대한 찬사입니다.\n디지털 시대 글쓰기 진화를 살펴보고, 스토리를 만들고, 공유하고, 소비하는 방식에 대한 기술의 혁신적인 영향을 추적하는 것으로 여정을 시작할 것입니다. 재현가능한 과학기술 문서작성과 대량생산부터 인터랙티브 서사와 멀티미디어 경험에 이르기까지 새로운 형태의 디지털 스토리텔링의 출현에 대해 논의할 것입니다.\n온라인 글쓰기의 세계를 더 깊이 파고들면서 자신만의 목소리와 스타일을 개발하고, 전통적인 글쓰기 기법을 디지털 플랫폼의 고유한 요구에 맞게 조정하며, 소셜 미디어의 힘을 활용하여 독자와 소통하고 작품을 중심으로 커뮤니티를 구축하는 것의 중요성에 대해서도 살펴볼 것입니다.\n익명성은 여전히 개인적인 선택이지만, 디지털 영역에서 익명성이 가져다주는 기회와 도전을 인식하는 것은 필수적입니다. 개인정보 보호와 공개성 사이의 미묘한 균형, 그리고 온라인에서 콘텐츠를 제작하고 공유할 때 고려해야 할 윤리적 고려 사항과 책임에 대해 논의할 것입니다.\n디지털 글쓰기의 세계를 탐색하는 데 필요한 지식과 도구뿐만 아니라 나만의 목소리를 세상과 공유할 수 있는 영감과 용기를 얻으시기 바랍니다. 광활한 사이버 공간에 여러분의 글이 울려 퍼져 경계를 넘어 전 세계 독자들의 마음을 움직일 수 있도록 모험을 떠나보세요.\n디지털 오디세이에 오신 것을 환영합니다. 모험을 시작하세요."
  },
  {
    "objectID": "history.html",
    "href": "history.html",
    "title": "\n2  글쓰기와 반도체\n",
    "section": "",
    "text": "3 문자와 종이 역사\n글쓰기의 역사는 매우 오래되었다. 언어로 말하기가 발전한 지 수만 년 후에 글쓰기로 발전했다고 알려져 있으며, 글쓰기의 가장 초기의 증거는 약 3,000 BC경 이집트와 메소포타미아 시대에서 나타나며, 중국에서도 거의 동시에 별도로 발명되었다.\n글쓰기의 도구인 문자보다 숫자가 먼저 다양한 형태로 사용되기 시작했다는 점이 눈에 띈다. 글쓰기는 언어를 표현하는 방식으로 발전하면서 다양한 목적에 맞춰 사회적 문제 해결을 위해 진화해 왔다."
  },
  {
    "objectID": "history.html#문자와-언어",
    "href": "history.html#문자와-언어",
    "title": "\n2  글쓰기와 반도체\n",
    "section": "\n2.2 문자와 언어",
    "text": "2.2 문자와 언어\n언어(Languages)와 문자(Writing System)를 구분하는 것은 매우 중요하다. 언어는 음성, 제스처(몸짓, 손짓), 기호 등 다양한 형태를 가지며 문법, 어휘, 발음 등 구성 요소를 통해 의사소통에 사용된다. 반면에 문자는 언어를 표현하기 위한 시각적 기호체계로 알파벳, 음절 문자, 로고그램 등 형태를 갖는다. 언어는 문자 없이도 존재할 수 있지만, 문자는 특정 언어를 표현하기 위해 존재한다. 하나의 언어는 문자 체계를 다수 사용할 수 있으며, 하나의 문자 체계는 여러 언어에 사용될 수 있다."
  },
  {
    "objectID": "history.html#글쓰기-진화",
    "href": "history.html#글쓰기-진화",
    "title": "\n2  글쓰기와 반도체\n",
    "section": "\n3.1 글쓰기 진화",
    "text": "3.1 글쓰기 진화\n글쓰기는 항상 변화해왔으며 인간의 필요와 유행에 따라 발전해 왔다. 글쓰기의 전신으로 토큰(token)이 존재했고, 그림문자(pictogram)가 나타났으며, 그 후 로고그래피(logography)가 나타나면서 시각에서 청각으로 전환되었다. 알파벳은 소리의 분할을 나타내며, 현대 알파벳이 나타났으며, 조선시대 한글도 이전 문자체계를 자체적으로 분석하여 발명했다.\n글쓰기의 진화는 고대 문명의 초기 형태로 거슬러 올라갈 수 있으며 여러 단계로 나눌 수 있습니다. 다음은 시간 경과에 따른 문자 시스템의 발전에 대한 간략한 개요입니다:\n\n픽토그래프(기원전 6000~4000년경): 가장 초기에 알려진 문자 형태인 상형문자는 사물이나 아이디어를 나타내는 단순한 그림이나 기호였습니다. 수메르, 이집트, 중국에서 기본적인 정보를 전달하기 위해 사용되었습니다.\n설형 문자(기원전 3400~3200년경): 고대 수메르(현대 이라크)에서 개발된 설형문자는 가장 초기의 문자 체계 중 하나로 간주됩니다. 상형문자에서 발전한 이 문자는 점토판에 쐐기 모양의 스타일러스를 눌러 단어와 아이디어를 나타내는 일련의 쐐기 모양의 자국을 만들었습니다.\n이집트 상형 문자(기원전 3200~3000년경): 고대 이집트인들은 음성 기호와 표의 문자를 조합하여 사용하는 문자 체계인 상형 문자를 개발했습니다. 상형문자는 종교 텍스트, 비문, 공식 문서에 사용되었습니다.\n페니키아 알파벳(기원전 1200년경): 페니키아 알파벳은 이집트 상형문자에서 파생된 초기 알파벳 문자였습니다. 각 기호가 고유한 소리를 나타내는 알파벳 개념을 도입한 이 문자는 문자 발전에 있어 중요한 발전이었습니다.\n그리스 알파벳(기원전 800년경): 그리스 알파벳은 페니키아 알파벳에서 발전하여 모음을 도입하여 문자의 표현력을 크게 향상시켰습니다. 그리스 알파벳은 라틴어와 키릴 문자를 비롯한 많은 현대 유럽 문자 체계의 토대를 마련했습니다.\n라틴 알파벳(기원전 700년경): 고대 로마인들이 사용한 라틴 알파벳은 그리스 알파벳에서 파생되었습니다. 시간이 지남에 따라 발전하여 영어, 스페인어, 프랑스어, 독일어 등 많은 현대 문자 체계의 기초를 형성하고 있습니다.\n중국어 문자(기원전 1200년경): 중국어 문자는 상형문자에서 발전하여 각 문자가 단어 또는 형태소(의미 단위)를 나타내는 복잡한 로고그램 체계로 발전했습니다. 중국어 문자는 일본어와 한국어 등 다른 동아시아 문자 체계의 발전에 영향을 미쳤습니다.\n브라흐미 문자(기원전 300년경): 브라흐미 문자는 고대 인도에서 개발되었으며 데바나가리(힌디어와 산스크리트어에 사용), 타밀어, 태국어를 비롯한 많은 남아시아 및 동남아시아 문자의 조상으로 간주됩니다.\n아랍 문자(기원전 4세기경): 나바테아 알파벳에서 발전한 아랍 문자는 아랍어를 표기하는 데 사용되며 페르시아어, 우르두어, 파슈토어 등 다른 언어와 함께 사용할 수 있도록 변형되었습니다.\n키릴 문자(기원전 9세기경): 러시아어와 다른 여러 슬라브어를 표기하는 데 사용되는 키릴 문자는 선교사 형제인 시릴과 메토디우스가 제1차 불가리아 제국에서 개발했습니다. 그리스 알파벳을 기반으로 슬라브어 고유의 소리를 표현하기 위한 문자가 추가되었습니다.\n한글(기원후 14세기): 조선전기 제4대 세종대왕이 훈민정음이라는 이름으로 창제하여 반포한 우리나라 고유의 문자입니다. 한글은 다른 나라의 기원과 발달 과정에 비하면 전혀 다른 과정을 거쳐 온 문자입니다. 세종대왕을 중심으로 한 소수의 집현전 학자들에 의해 치밀하게 계획되어 처음부터 완전한 글자꼴과 표현 원리를 정해 1443년에 창제되어 세종28년 1446년에 10월에 반포한 것으로 이러한 독창적인 글자를 만든 일은 세계 역사에 일찍이 찾아볼 수 없었습니다.\n\n역사를 통틀어 다양한 문자 체계가 진화하고 적응하며 서로 영향을 주고받았습니다. 오늘날에는 전 세계 사람들의 다양한 언어적 요구를 충족하는 수많은 문자 체계와 알파벳이 존재합니다."
  },
  {
    "objectID": "history.html#언어와-문자",
    "href": "history.html#언어와-문자",
    "title": "\n2  글쓰기와 반도체\n",
    "section": "\n2.1 언어와 문자",
    "text": "2.1 언어와 문자\n위키백과 따르면 전세계 인구는 약 80억명(2030년 기준)에 이르며, 화자들에게 본토어로 성경을 제공할 목적으로 기독교 언어학 봉사단체 에스놀로그 통계에 따르면 7,168개(2023년 기준) 언어가 사용되고 있다. 이 중에서도 영어, 중국어, 힌디어, 스페인어, 프랑스어, 아랍어, 벵골어, 러시아어, 포르투갈어, 인도네시아어가 가장 많은 사용자를 보유하고 있다. 1\n\nlibrary(tidyverse)\nlibrary(rvest)\n\nlang_raw &lt;- read_html(\"https://en.wikipedia.org/wiki/List_of_languages_by_total_number_of_speakers\")  |&gt; \n  html_node(\".wikitable\") |&gt; \n  html_table() \n\nlang_tbl &lt;- lang_raw |&gt; \n  janitor::clean_names() |&gt; \n  set_names(c(\"언어\", \"family\", \"branch\", \"모국어\", \n\"제2언어\", \"전체\")) |&gt; \n  mutate(언어 = str_extract(언어, '([\\\\w\\\\s]+)\\\\s?\\\\(?') |&gt; \n              str_remove(\"\\\\($\")) |&gt; \n  mutate(모국어 = if_else(str_detect(모국어, \"million\"), \n                       parse_number(모국어) *10^6, \n                       parse_number(모국어) *10^9)) |&gt; \n  mutate(제2언어 = if_else(str_detect(제2언어, \"million\"), \n                       parse_number(제2언어) *10^6, \n                       parse_number(제2언어) *10^9)) |&gt; \n  mutate(전체 = if_else(str_detect(전체, \"million\"), \n                       parse_number(전체) *10^6, \n                       parse_number(전체) *10^9)) |&gt; \n  mutate(순위 = row_number()) |&gt; \n  select(순위, 언어, 모국어, 제2언어, 전체)\n\n# lang_tbl |&gt; \n#   write_csv(\"data/lang_tbl.csv\")\n\n\nlang_tbl &lt;- \n  read_csv(\"data/lang_tbl.csv\")\n\nlang_tbl |&gt; \n  slice(c(1:10, 13, 21, 24, 29)) |&gt; \n  gt() |&gt; \n  fmt_integer(columns = 모국어:전체) |&gt; \n  cols_align(\"center\") |&gt; \n  gt_theme_hangul() |&gt; \n  tab_spanner(label = \"구분\", columns = c(모국어, 제2언어))\n\n\n\n\n\n\n순위\n      언어\n      \n        구분\n      \n      전체\n    \n\n모국어\n      제2언어\n    \n\n\n\n1\nEnglish\n380,000,000\n1,077,000,000\n1,456,000,000\n\n\n2\nMandarin Chinese\n939,000,000\n199,000,000\n1,138,000,000\n\n\n3\nHindi\n345,000,000\n266,000,000\n609,000,000\n\n\n4\nSpanish\n485,000,000\n74,000,000\n559,000,000\n\n\n5\nFrench\n81,000,000\n229,000,000\n310,000,000\n\n\n6\nModern Standard Arabic\n0\n274,000,000\n274,000,000\n\n\n7\nBengali\n234,000,000\n39,000,000\n273,000,000\n\n\n8\nPortuguese\n236,000,000\n27,000,000\n264,000,000\n\n\n9\nRussian\n147,000,000\n108,000,000\n255,000,000\n\n\n10\nUrdu\n71,000,000\n161,000,000\n232,000,000\n\n\n13\nJapanese\n123,000,000\n200,000\n123,000,000\n\n\n21\nVietnamese\n85,000,000\n1,000,000\n86,000,000\n\n\n24\nKorean\n82,000,000\n29,000,000,000\n82,000,000\n\n\n29\nItalian\n65,000,000\n3,000,000\n68,000,000\n\n\n\n\n\n\n전세계에는 7,000개가 넘는 언어가 존재하나, 이를 표현하는 문자 체계는 대략 50개 정도에 불과하다. 한국어(제주어 포함)는 한글을 문자 체계로 사용하고 있지만, 이처럼 모든 언어가 고유의 문자(Writing System)를 가진 것은 아니다. 실제로 여러 언어가 동일한 문자 체계를 공유하는 경우가 많다. 예를 들어, 알파벳은 라틴어를 기반으로 하며, 영어, 불어, 독어, 이태리어 등 다양한 언어에서 사용되고 있다. 이 외에도 셀틱어, 발틱어, 슬로박어 등도 알파벳이 활용된다. 한자는 중국어와 대만어에서 주로 사용되며, 아랍문자는 아랍어뿐만 아니라 인도-이란 어족(페르시아어, 펀잡어 등)에도 쓰인다. 일본어는 가나(仮名)라는 문자 체계가 사용된다.\n\nwriting_raw &lt;- read_html(\"https://en.wikipedia.org/wiki/List_of_writing_systems\")  |&gt; \n  html_node(\".wikitable\") |&gt; \n  html_table() \n\nwriting_tbl &lt;- writing_raw |&gt; \n  janitor::clean_names() |&gt; \n  set_names(c(\"스크립트_명칭\", \"문자유형\", \"인구수\", \n\"languages_associated_with\", \"regions_using_script_de_facto\")) |&gt; \n  select(스크립트_명칭, 문자유형, 인구수) |&gt; \n  mutate(인구수 = parse_number(인구수) *10^6) |&gt; \n  mutate(스크립트_명칭 = str_squish(스크립트_명칭)) |&gt; \n  arrange(desc(인구수))\n\nwriting_tbl |&gt; \n  write_csv(\"data/writing_tbl.csv\")\n\n\nwriting_tbl &lt;- \n  read_csv(\"data/writing_tbl.csv\")\n\nwriting_tbl |&gt; \n  slice(1:10) |&gt; \n  gt() |&gt; \n  fmt_integer(columns = 인구수) |&gt; \n  cols_align(\"center\") |&gt; \n  gt_theme_hangul() \n\n\n\n\n\n스크립트_명칭\n      문자유형\n      인구수\n    \n\n\nLatin Latin\nAlphabet\n4,900,000,000\n\n\nChinese 汉字 漢字\nLogographic\n1,541,000,000\n\n\nArabic العربية\nAbjad or Abugida (when diacritics are used)\n828,000,000\n\n\nDevanagari देवनागरी\nAbugida\n480,500,000\n\n\nCyrillic Кирилица\nAlphabet\n289,000,000\n\n\nBengali–Assamese বাংলা-অসমীয়া\nAbugida\n234,000,000\n\n\nKana かな カナ\nSyllabary\n123,000,000\n\n\nTelugu తెలుగు\nAbugida\n83,000,000\n\n\nHangul 한글 조선글\nAlphabet, featural\n81,700,000\n\n\nTamil தமிழ்\nAbugida\n78,600,000\n\n\n\n\n\n\n문자가 존재하기 위한 전제조건이 있는데 크게 다음 세가지를 들고 있다.\n\n언어 : 한국어, 영어, 중국어, …\n아이디어: 생각, 콘텐츠,…\n기호: 숫자, 문자, 그림, …\n\n언어\n숫자와 수식\n교통표지 등 표식\n\n\n매체: 종이, 파피루스, 디스플레이"
  },
  {
    "objectID": "history.html#매체-역사",
    "href": "history.html#매체-역사",
    "title": "\n2  글쓰기와 반도체\n",
    "section": "\n3.2 매체 역사",
    "text": "3.2 매체 역사\n메시지를 전달하기 위해서 의미를 담을 수 있는 상형문자가 전세계 동시 다발적으로 개발되었으나 동시에 추상적인 개념 (예를 들어, 숫자)을 전달하기 위한 문자체계도 필요하여 개발됨과 동시에 문자를 담을 수 있는 매체에 대한 발전도 함께 이뤄졌다.\n초기 동굴벽화처럼 벽면에 그림을 그려서 의사를 전달하는 체계가 출현한 것은 기원전 16,500년 라스코 동굴벽화를 비롯하여 반구암각화에도 그 흔적을 어렵지 않게 찾을 수 있다. 기원전 3,000년 수메르 문명이 출현하면서 수십만의 사람들이 도시에 모여살게 되면서 세금 징수, 계약 등 산적한 정치, 사회, 경제 문제를 해결하는데 필수적으로 문자가 필요하게 되었다. 동시에 세금과 계약관계를 기록하고 보존할 수 있는 방식으로 점토를 사용하였고, 이집트에서도 유사한 목적으로 점토판 대신에 파피루스를 종이처럼 사용하는 방식을 사용했다.\n\n\n문자 매체의 진화\n\n문자를 담을 수 있는 매체도 생산과 유지관리에 비용이 많이 들고, 상형문자가 담을 수 있는 정보에 한계가 보임에 따라 지중해에서 수많은 물품을 거래하던 페니키아인들은 기존 상형문자체계를 벗어나 소리에 의미를 담을 수 있는 방식으로 진화시켜 무한대에 가까운 의미를 담을 수 있는 문자를 만들어냈는데 기원전 1,200년 페니키아 문자를 창안하게 되었다. 이후, 그리스 헬레니즘 문화를 거치면서 쥴리어스 시저 시대 라틴 알파벳(대문자)이 공표되면서 오늘에 이르게 되었다. 라틴 알파벳을 담을 수 있는 매체로 양피지(Parchment)가 사용되었고 필경사(Scribe)가 한땀 한땀 손으로 필사를 했다.\n동굴벽, 점토판, 파피루스 종이, 양피지를 거쳐 드디어 106년 채륜(Cai Lun)이 종이를 발명하면서 문자문화에 큰 변화가 생기게 되었다. 이후 서기 800년경 목판인쇄술이 발명되고 1450년 구텐베르크 인쇄술을 통해 성경이 대량 인쇄되어 르네상스의 초석이 되었으며, 푸어드니어(Fourdrinier) 형제가 1806년 종이를 대량생산하게 되는 초지기(Paper Macine)를 발병하면서 저렴한 비용으로 일반대중도 아이디어를 문자로 종이에 기록하여 널리 알릴 수 있는 토대가 완성되었다. 여기에 더해 1922년 독일에서 ISO 216을 통해 종이에 대한 국제 표준이 자리잡으면서 미국을 비롯한 일부 국가를 제외하고 전세계적으로 문자를 담아낸 매체에 대한 표준이 확립되었다."
  },
  {
    "objectID": "history.html#문자",
    "href": "history.html#문자",
    "title": "\n2  글쓰기와 반도체\n",
    "section": "\n3.3 문자",
    "text": "3.3 문자\n언어를 기록하기 위한 상징체계로 문자(文字, writing system)가 발명되었다. 문자는 언어중에서도 음성언어를 기록하기 위해 생겨난 것으로 알려져 있다. 문자는 정보의 저장과 전달에 신뢰성이 담보된다는 점에서 그 유용성이 크다.\n문자는 크게 표음문자(Phonographic)와 표의문자(Logographic)로 나눠진다. 표의문자의 대표적인 문자로 중국 한문과 이집트 상형문자가 꼽힌다. 예를 들어 木(나무 목) 은 목이라는 소리를 내지만 뜻은 나무를 갖고 있다. 표음문자는 한글을 비롯한 라틴계열 대부분의 언어가 여기에 포함된다.\n\n3.3.1 알파벳 2\n\n알파벳(Alphabet) 문자는 이집트 상형문자에서 시작되었다고 알려져 있다. 이후 상형문자는 페니키아 상인이 소리를 기반으로 의미를 전달하는 방식으로 진화되었고 그리스를 거쳐 알파벳 뒤쪽 문자가 추가되고 로마시대에 오늘날 알려진 영어 대문자가 완성되고 이후 소문자가 손으로 필사되면서 발명되고 다양한 글꼴이 생겨나게 되었다. 구텐베르그가 활자인쇄술을 발명되면서 현재와 같은 알파벳 문자가 완성되었다.\n\n\n알파벳 진화 역사\n\n\n3.3.2 문자 시스템\n앞서 문자를 크게 표음문자와 표의문자로 구분하였다. 이를 좀더 상세히 세분화하면 전세계 문자는 크게 다음과 같이 4개로 구분된다. (gohos2010?) 표어문자의 대표적인 문자가 중국의 한자, 음절문자의 대표적 문자가 일본어, 자질문자의 대표 문자가 한글이다. 그외 음소문자는 로마자로 대표되는 영문자가 있다.\n\n표어문자(logographic)\n음절문자(syllabic)\n음소문자(alphabetic)\n자질문자(featural)\n\n\n\n\n\n\n\n종류\n기호 표현\n예\n\n\n\n표어 문자\n형태소\n중국의 한자\n\n\n음절 문자\n음절 또는 모라\n일본의 가나 (문자)\n\n\n음소 문자\n낱소리 (자음 또는 모음)\n로마자, 키릴문자, 그리스 문자\n\n\n아부기다\n낱소리 (자음+모음)\n데바나가리 문자, 그으즈 문자\n\n\n아브자드\n낱소리 (자음)\n아랍 문자, 히브리 문자\n\n\n자질 문자\n음성 자질\n한국의 한글\n\n\n\n3.3.3 글쓰기 방향\n대부분의 문자를 왼쪽에서 오른쪽, 위에서 아래 방향으로 작성하는 방식을 취하고 있으나 이슬람권에서는 오른쪽에서 왼쪽으로 작성을 하고 있고 몽골은 위에서 아래로 작성하고 있다.\n\n\n3.3.4 표의 문자\n한자와 같은 표의 문자가 여러가지 단점이 있는 것처럼 보이기도 하지만 표의문자가 갖는 장점으로 인해 그 중요성이 더욱 부각되고 있다. 표의문자가 갖는 장점은 문자 자체 의미가 부여되기 때문에 전세계 누구도 문자만 보면 그 뜻을 유추할 수 있다는 점이다.\n\n그림문자(Pictographic): 😕, 🙋, 🍰, …\n표의문자(Ideogrpahic): 🚫 금지와 같은 의미를 갖는 문자로 ⛔ 🚸 교통 표지판, ▶️ 전자제품 사용\n추상 어표(Abstract Logograpahic): 한자 사람 인(人), %, &, …\n\n그림문자와 표의문자를 결합하게 되면 다음과 같이 흡연을 금지하는 의미를 명확히 전달할 수 있다.\n\n\n흡연과 금지가 결합된 표의문자"
  },
  {
    "objectID": "editor.html#paradigm",
    "href": "editor.html#paradigm",
    "title": "\n3  편집기와 출판\n",
    "section": "\n3.1 저작방식 패러다임",
    "text": "3.1 저작방식 패러다임\n위지위그(WYSIWYG: What You See Is What You Get)는 “보는 대로 얻는다”는 의미로, 사용자가 문서를 편집할 때 화면에 보이는 형태가 최종 출력물과 동일하게 나오는 편집 방식이다. 대다수 현대 워드 프로세서에서 위지위그 방식을 사용하고 있다. 사용자에게 직관적이고 쉽게 접근할 수 있는 인터페이스를 제공하기 때문이다.\n그러나 위지위그 방식에도 단점은 있다. 마크다운, TeX 같은 텍스트 기반 편집 방식은 문서 호환성과 범용성을 위해 쓰이는 반면, 위지위그 저작방식은 호환성과 범용성을 다소 희생할 수 밖에 없다. 특히 복잡한 문서나 웹 페이지를 작성하는 경우, 코딩방식으로 전환하여 수작업으로 최적화를 시도하더라도 완벽한 해결이 어렵다. 예를 들어, 위지위그 편집기에서 문서를 작성하면 뒷단에 불필요한 코드나 태그가 자동으로 생성되어 문서 최적화를 방해하며, 시간이 지남에 따라 누적되어 호환성과 재현성에 심각한 문제를 야기한다. 1 2\n위지윔(WYSIWYM: What You See Is What You Mean)은 “당신이 보는 것은 당신이 뜻하는 것이다”라는 의미로, 위지위그(WYSIWYG) 방식의 한계를 극복하기 위해 나온 대안 편집 방식이다. 위지윔 방식에서는 사용자가 무엇을 의미하는지를 중점으로 두어, 본래의 코드 구조를 더 명확하게 알 수 있다. 코드 의미를 직접적으로 반영하여, 불필요한 요소 없이 효율적으로 문서를 작성할 수 있는 장점이 있다.\nRStudio의 Visual 편집 기능은 위지윔 지향점을 잘 반영하고 있다. 사용자는 복잡한 코드나 태그 없이도 의미 있는 문서 구조를 쉽게 생성하고 관리할 수 있어 문서 최적화와 호환성을 높일 수 있으며, 더욱 높은 문서 저작 생산성을 달성할 수 있다.\n오픈 소스 LaTeX 편집기인 LyX는 위지윔 방식을 초기부터 채택하여 사용자에게 코드 본래 구조와 의미를 명확하게 파악할 수 있는 인터페이스를 제공했다. 이러한 접근법은 복잡한 수식이나 과학적인 문서를 작성할 때 특히 유용하며, LaTeX 복잡성을 낮추면서도 강력한 기능을 최대한 활용할 수 함으로써 위지위그 한계를 극복했다는 평가를 받고 있다.\n\n\n문서 컴파일\n위지위그"
  },
  {
    "objectID": "editor.html#main-features",
    "href": "editor.html#main-features",
    "title": "\n3  편집기와 출판\n",
    "section": "\n3.2 워드 프로세서 3\n",
    "text": "3.2 워드 프로세서 3\n\n워드 프로세서(Word Processor)는 문서 제작을 위한 소프트웨어로, 시각적으로 잘 구성된 인터페이스와 다양한 편집 기능을 제공한다. 사용자는 이러한 기능을 통해 원하는 형태와 구조를 갖는 문서를 쉽게 저작할 수 있다. 워드 프로세서는 글자 스타일, 문단 구성, 이미지 삽입, 표 만들기 등 다양한 기능이 포괄적으로 제공되며, 윈도우에 기본 제공되는 메모장(Notepad) 텍스트 편집기보다 훨씬 더 풍부한 문서 작성이 가능하다. 2023년 9월 1일부로 윈도우에서 무료로 제공되던 워드패드(WordPad)에 대한 지원도 없어지고 윈도우에서도 제거될 것이라는 발표가 있었다. 따라서, 서식이 필요한 문서를 저작할 경우 MS 워드(Word)나 아래한글과 같은 워드 프로세서를 사용해야 된다.\n아래한글은 국내에서 널리 사용되는 워드 프로세서 중 하나로, 한국 문화와 업무 환경에 맞춰 특화된 기능을 제공한다. 정부나 공공기관에서 사용하는 특별한 문서 양식을 미리 저장해 두어, 사용자가 양식을 찾는 데 시간을 쓰지 않고 글쓰기에 바로 집중할 수 있도록 큰 도움을 주었다.\n\n\n국산 워드 프로세서\n해외 워드 프로세서"
  },
  {
    "objectID": "editor.html#latex-editor",
    "href": "editor.html#latex-editor",
    "title": "\n3  편집기와 출판\n",
    "section": "\n3.3 LaTeX 편집기",
    "text": "3.3 LaTeX 편집기\nLaTeX 편집기는 운영체제나 사용자의 필요에 따라 다양한 선택옵션이 존재한다. 특히, 클라우드 기반 Overleaf, 설치형 TeXstudio, 데이터 과학에 특화된 RStudio IDE가 대표적이다. 편집기들은 LaTeX에 특화되었거나, 일부 LaTeX 기능을 분리하여 사용자 요구에 맞춰 활용할 수 있다.\n\n\nLaTeX 편집기 다양성\n\nOverleaf는 초기에 ShareLaTeX 서비스로 시작해 현재는 클라우드 기반의 LaTeX 편집 기능을 제공한다. 클라우드 특성을 살려 문서의 공유와 협업이 용이하다는 점이 큰 장점이다.\nTeXstudio는 Texmaker 후속으로 오픈 소스 LaTeX 편집기로 제공된다. 사용자는 TeXstudio 웹사이트에서 다운로드 받아 설치할 수 있으며, GitHub texstudio 저장소를 통해 한국어 현지화 작업에도 참여할 수 있다.\n\n\n클라우드 편집기\n설치형 편집기"
  },
  {
    "objectID": "editor.html#rstudio-ide",
    "href": "editor.html#rstudio-ide",
    "title": "\n3  편집기와 출판\n",
    "section": "\n3.4 RStudio IDE 편집기",
    "text": "3.4 RStudio IDE 편집기\nRStudio IDE는 처음 데이터 과학 R 프로그래밍 언어를 위한 통합개발환경으로 시작하였으나 이제는 파이썬을 비롯하여 SQL, Observable JS 등 데이터 과학 전분야를 담당하고 있다. 특히, 데이터 분석, 시각화 및 문서 작업을 간편하게 할 수 있도록 다양한 도구와 기능을 제공할 뿐만 아니라, Shiny 웹 애플리케이션 개발, Plumber를 통한 API 개발, 쿼토(Quarto)/R 마크다운을 활용해 다양한 데이터 과학 산출물을 제작할 수 있다. 또한, Git 버전 관리 시스템과 통합되어 코드 이력을 쉽게 추적하고 관리할 수 있고 GitHub과 연결하여 협업기능도 지원한다.\nRStudio 코드 편집기는 자동 완성, 구문 강조, 맞춤법 검사 등 기능을 제공하여 개발자 편의를 향상시켰고, GUI 데이터 뷰어를 통해 데이터프레임과 데이터 객체를 직접적으로 시각적으로 살펴볼 수 있으며, 내장 패키지 관리 시스템을 통해 R 패키지도 손쉽게 설치하고 관리할 수 있다.\n웹앱 Shiny 애플리케이션 개발과 테스트도 가능하고, 문서화 프로그래밍을 차세대 R 마크다운 쿼토(Quarto)를 이용하여 코드, 데이터, 그래프를 하나의 문서로 통합하여 구현할 수 있을 뿐만 아니라 팬독(Pandoc)을 통해 다양한 형태 문서를 자동으로 생성할 수 있다.\n\n\nRStudio 문서화 프로그래밍 사례\n\n\n3.4.1 Visual 마크다운 편집기\nVisual 마크다운 기능을 사용하게 되면 과학/기술 문서 작성의 용이성 뿐만 아니라 인용(Citation), 문학적 프로그래밍(literate programming) 을 통한 재현가능한 과학문서 구현, 팬독(Pandoc)을 사용하여 텍스트와 코드로 PDF, HTML, 워드 등 다양한 문서 동시 생성이 가능하다.\n\n\nRStudio Visual 마크다운 편집기능\n\n\n3.4.2 맞춤법 검사"
  },
  {
    "objectID": "editor.html#쿼토-설치",
    "href": "editor.html#쿼토-설치",
    "title": "\n3  편집기와 출판\n",
    "section": "\n3.5 쿼토 설치",
    "text": "3.5 쿼토 설치\n쿼토(Quarto) 웹사이트에서 Quarto CLI 엔진과 통합개발도구(IDE)를 설치한다. 쿼토 CLI를 지원하는 IDE는 VS Code, RStudio, Jupyter, VIM/Emacs 와 같은 텍스트 편집기가 포함된다. IDE까지 설치를 했다면 문학적 프로그래밍(literate programming)을 통해 사람이 저작하는 마크다운(Markdown)과 기계가 저작하는 프로그래밍 언어(R/Python/SQL/줄리아/자바스크립트)를 결합한 다양한 문서저작을 시작할 수 있다.\n\n\n쿼토 도구모음\n\n\n3.5.1 윈도우 설치\n쿼토(Quarto)를 윈도우 운영체제에 설치하기 위해서는 몇 가지 단계를 거쳐야 한다.\n\n3.5.2 쿼토 다운로드\n먼저 Quarto 공식 웹사이트에서 윈도우용 설치 파일을 다운로드한다. 웹사이트 “Download Quarto CLI” 윈도우 버전을 선택하여 다운로드한다.\n\n\n쿼토 다운로드 화면\n\n쿼토 설치\n다운로드한 파일을 더블클릭 실행하여 설치를 진행한다. 설치 마법사가 나타나면 지시에 따라 설치를 완료하면 된다. 설치가 완료되면 환경 변수에 쿼토 설치 경로를 등록해야 한다. ‘제어판’을 열고 ’시스템과 보안’으로 이동한 다음 ’시스템’을 선택한다. ’고급 시스템 설정’을 클릭한 후 ’환경 변수’ 버튼을 누른다. ‘시스템 변수’에서 ’Path’ 변수를 찾아 Quarto의 설치 경로를 추가한다. 일반적인 경로는 C:\\Users\\&lt;사용자계정명&gt;\\AppData\\Local\\Programs\\Quarto\\bin과 같을 수 있다.\n\n\n쿼토 설치완료\n\n\n3.5.3 쿼토 CLI\n마지막으로 환경 변수 설정이 올바르게 이루어졌는지 확인하기 위해 명령 프롬프트나 터미널을 열어 quarto --version 혹은 quarto --help 명령을 입력한다. 올바른 버전 번호가 출력되면 설치가 성공적으로 완료된 것이다.\n\n\n쿼토 CLI 실행화면\n\n\n\n\n\n\n\n\n\n\n\n윈도우 시스템의 경우 초기 윈도우에서 쿼토 실행명령이 quarto.cmd 이였으나 quarto.exe도 지원된다. 즉, 제어판 → 환경 변수 설정 … 에서 \"C:\\Users\\사용자명\\AppData\\Local\\Programs\\Quarto\\bin 디렉토리를 등록한 후 quarto 명령어를 사용한다.\n\nSys.which(\"quarto\")\n                                                                  quarto \n\"C:\\\\Users\\\\사용자명\\\\AppData\\\\Local\\\\Programs\\\\Quarto\\\\bin\\\\quarto.exe\""
  },
  {
    "objectID": "editor.html#부조종사",
    "href": "editor.html#부조종사",
    "title": "\n3  편집기와 출판\n",
    "section": "\n3.6 부조종사",
    "text": "3.6 부조종사\nGitHub 부조종사(Copilot)를 Rstudio에서 사용하기 위해서는 특별한 버전 Rstudio, 즉 일일 빌드 (Daily Builds)가 필요하여 각자 운영체제에 맞는 RStudio Desktop 버전을 다운로드한 후 설치한다.\n\nTools -&gt; Global Options -&gt; Copilot -&gt; Enable Github Copilot\n\n설치가 완료되면 Rstudio를 실행하고 상단 메뉴에서 ‘Tools’를 선택한 다음 ’Global Options’을 클릭하면, 왼쪽 사이드바에서 ’Copilot’을 선택하고 ’Enable GitHub Copilot’ 체크박스를 선택한 다음 ’Sign In’을 클릭하고 나타나는 링크에서 인증 코드를 입력한다. ’Authorize Github Copilot Plugin’을 클릭하여 인증 과정을 완료하면 설정이 완료된다.\n\n\nGitHub 부주종사 설치과정\n\nGitHub Copilot를 Rstudio에서 사용해보면, 작성하려는 코드가 회색으로 예측되어 나타난다. ‘Tab’ 키를 눌러 탭완성(Tab Completion) 기능으로 제시한 코드를 수락하여 개발을 이어간다."
  },
  {
    "objectID": "editor.html#출판-플랫폼",
    "href": "editor.html#출판-플랫폼",
    "title": "\n3  편집기와 출판\n",
    "section": "\n3.7 출판 플랫폼",
    "text": "3.7 출판 플랫폼\n데이터 과학 분야에서 산출물을 공유하고 출판하는 것은 매우 중요한 단계로 효과적인 출판과 비용적인 면을 고려하여 최적 플랫폼과 도구를 선정한다. 데이터 과학 분야를 개척한 RStudio IDE로 과거 R 마크다운 산출물을 RPubs에 출판한 경험이 있다면, Quarto Pub은 그와 유사한 경험을 제공한다. 다른 대안으로는 netlify, GitHub Pages, RStudio Connect 등이 있다.\n\n\n쿼토 출판"
  },
  {
    "objectID": "latex_pdf.html#latex-engine",
    "href": "latex_pdf.html#latex-engine",
    "title": "4  LaTeX과 PDF",
    "section": "4.1 LaTeX 엔진",
    "text": "4.1 LaTeX 엔진\nLaTeX을 실제 문서 작성에 활용하기 위해서는 적절한 TeX 배포판을 선택해야 한다. 이에 대해 KTUG 한국 TeX 사용자 그룹은 \\(ko.TeX\\) Live를 추천하고 있으며, 그 이유는 다음과 같다. (Lee2017?)\n\nLaTeX 엔진으로 pdfLaTeX, XeLaTeX, LuaLaTeX 세 가지가 있으나, XeLaTeX은 유니코드 TeX 엔진으로 동아시아 언어(CJK)를 잘 지원하고, 트루타입 및 오픈타입 폰트를 자유롭게 선택할 수 있어 인기가 높다.\n운영체제에 따라 차이는 있지만, 실제 문서 작업에 LaTeX을 안정적으로 설치하고 사용하기 위해서는 TeX Live가 MikTeX보다 안정성과 사용자 지원 측면에서 우수하다.\nTeX 소스파일과 PDF 파일 간의 탐색 기능은 TexStudio IDE를 활용하여 쉽게 이용할 수 있다.\n\n과거에는 latex+dvips+pspdf를 사용한 전통적인 작업 흐름이 있었으며, 이 방식은 pstricks를 이용해 PDF 파일을 생성하는데 시간이 오래 걸리고, eps 파일만을 이미지로 사용할 수 있다는 한계가 있었다. 또 다른 방식인 latex+dvipdfmx 작업 흐름은 중간 단계로 .dvi 파일을 생성한 후 dvipdfmx를 이용해 PDF 파일을 만든다. 그러나 현재 가장 인기 있는 작업 흐름은 pdfLaTeX, XeLaTeX, LuaLaTeX를 활용한 방식으로, 이는 .tex 소스파일에서 바로 .pdf 파일을 생성할 수 있다는 장점이 있다.\n논문 외의 문서를 작성할 경우에는 한 단계 더 나아가 memoir 또는 oblivoir 클래스를 활용하는 것이 효율적이다. 이 방법은 이미 검증된 문서 템플릿을 기반으로 빠르게 PDF 문서를 생성할 수 있는 방법이다.\n\n\n\n한글지원 LaTeX 엔진과 작업흐름"
  },
  {
    "objectID": "latex_pdf.html#latex-knuth",
    "href": "latex_pdf.html#latex-knuth",
    "title": "4  LaTeX과 PDF",
    "section": "4.2 LaTeX 구성요소",
    "text": "4.2 LaTeX 구성요소\n수학과 교수였던 도널드 크누스는 문서 조판 시스템을 개발하면서 수식 처리를 간편하게 할 수 있도록 하면서, 메타폰트(METAFONT)라는 글꼴 시스템도 개발하여 고품질 글자체를 구현할 수 있도록 했다. 이러한 기초 위에 레슬리 램포트는 TeX을 더욱 사용하기 쉽게 만들기 위해 다양한 매크로를 LaTeX으로 묶어 공개했다. 그 결과 일반인도 LaTeX을 이용해 고품질의 문서를 쉽게 작성할 수 있게 되었다. 버클리 대학 마이클 스피백 교수는 수식을 간편하게 문서에 적용할 수 있도록 AMS-TeX라는 매크로를 개발하고, 이에 대한 설명을 “The Joy of TeX”이라는 책에서도 공개했다. (Spivak, 1990)\npdftex와 e-TeX이 결합하여 사실상 표준 TeX이 되었고, 이를 기반으로 XeTeX과 LuaTeX이 발전하고 있다. 특히, 한글 폰트 처리에 있어서 XeTeX(지텍으로 읽음)이 널리 사용되고 있다.\nLaTeX 동작 원리는 Salomon의 도식화에 영감을 받아 Kees van der Laan이 1994년에 정리한 논문에서 상세하게 설명되어 있다. (Laan, 1994) 기본적으로 고품질의 전자 출판을 위해 글꼴과 TeX이 필요하며, 이 두 요소가 결합하여 고품질의 출력물을 생성한다. 이러한 TeX 엔진을 지원하는 다양한 패키지 중에서 AMS-(La)TeX, LaTeX, manmac 등이 주목을 받고 있다.\n문서의 다양한 구성 요소, 예를 들어 목차, 색인, 참고문헌, 그림과 표 등은 모듈화되어 관리되며, 글꼴 및 구조적인 스타일과 관련된 부분도 별도로 관리되고 있다. TeXWorks와 같은 위지윅(WYSIWYG)을 지원하는 편집기는 구문 강조, 맞춤법 검사 등을 통해 고품질의 LaTeX 문서 작성을 지원하고 있다.\n\n\n\n편집기, 엔진, 글꼴을 중심으로 본 LaTeX내부\n\n\nLaTeX 문서 작성을 위해 기본적인 구성요소는 다음과 같다.\n\n배포판: 과거에는 다양한 배포판이 윈도우, 리눅스, 맥에서 사용되었지만, 현재는 TeX Live가 대표적인 LaTeX 작업 환경이다. MikTeX도 있지만, 큰 차이는 없다.\n글꼴: 초기에는 글꼴로 폰트 메트릭(tfm)과 메타폰트(MetaFont)가 주로 사용되었으나, 현재는 트루타입과 오픈타입이 널리 쓰인다.\n\n폰트 선택은 밥처럼 기본적이면서도 안정적인 것이 좋다. 특별한 상황에서는 그에 맞는 폰트를 선택하는 것이 중요하다.\n일반적으로 Serif와 San Serif 폰트를 한 쌍으로 사용하는 것이 균형감이 있다. 예를 들어, 나눔고딕과 나눔명조, KoPub돋움과 KoPub바탕, 함초롬도움과 함초롬바탕 등이 있다.\n글자 크기는 10~12 포인트가 적절하며, 이는 장시간 동안의 읽기 피로를 줄이기 위함이다.\n\n그래픽: TeX/LaTeX 자체는 그래픽을 주요 영역으로 보지 않는다. 과거에는 dvips와 EPS 형식을 주로 사용했으나, 현재는 .jpg, .png, .pdf 등도 잘 처리한다.\n문자와 입력: 초기에는 ASCII 코드가 주를 이루었으나, 현재는 UTF-8을 권장하고 있다. 특히, \\usepackage[utf8x]{inputenc}가 필요한 경우가 많다.\n색인과 참고문헌: makeindex와 bibtex는 색인과 참고문헌 처리의 표준이다. 그러나 유니코드 처리를 위해 texindy와 biber도 주목을 받고 있다.\n수식: 수학 표현과 관련해서는 미국 수학회가 발전시킨 amsmath가 표준이다.\n출력: 과거에는 .dvi 형식이 기본이었으나, 현재는 .pdf가 기본이다. 또한, 웹을 위한 다양한 .html 출력도 지원한다. 이에 따라, 웹이 책 형태의 문서보다 더 중요한 위치를 차지하게 될 것으로 예상된다.\n\n% A flowchart of a TeX workflow\n% Author: Stefan Kottwitz\n% https://www.packtpub.com/hardware-and-creative/latex-cookbook\n\\documentclass[border=10pt]{standalone}\n\\begin{document}\n\\smartdiagram[flow diagram:horizontal]{Edit,\n  \\LaTeX, Bib\\TeX/ biber, make\\-index, \\LaTeX}\n\\end{document}\nLaTeX을 통한 PDF 파일 제작 과정은 몇 가지 주요 단계로 이루어진다. LaTeX 전용 TexStudio 같은 통합개발환경(IDE), RStudio 같은 데이터 과학 IDE, 범용 소프트웨어 개발 VS코드 같은 IDE에서 텍스트 편집기를 열어 신규 LaTeX 파일을 생성하는데 파일 확장자는 .tex이다. 파일 시작 부분에 \\documentclass 명령어를 사용하여 문서의 종류와 옵션을 설정하는데, 학술 논문을 작성한다면 article 클래스를, 책을 작성한다면 book 클래스 등을 선택한다.\n\\usepackage 명령어를 사용하여 필요한 패키지를 불러와서 특별한 기능이나 스타일을 추가한다. 예를 들어, 수식을 표현하기 위해 amsmath 패키지를, 그림을 삽입하기 위해 graphicx 패키지 등이 사용된다.\n문서의 본문은 \\begin{document}와 \\end{document} 사이에 작성되고, 영역 안에서 텍스트, 표, 그림, 수식 등을 자유롭게 배치할 수 있다. 본문 작성 중에 참고문헌 서지관리를 위해 BibTeX texindy, biber를 사용하고, 색인 생성을 위해 makeindex를 사용한다.\n본문 작성이 완료되면, LaTeX 컴파일러를 실행하여 .tex 파일을 PDF로 변환한다. 영어는 pdflatex, 한글은 xelatex 을 LaTeX 엔진으로 사용하고, 참고문헌과 색인이 포함된 경우 컴파일 과정이 수차례 이어진다.\n\n\n\nLaTeX작업흐름\n\n\n\n\n\n\nLaan, K. van der. (1994). What is TEX and Metafont all about?\n\n\nSpivak, M. (1990). The Joy of\\(\\backslash\\)TeX \\(\\{\\)\\(\\}\\), a Gourmet Guide to Typesetting with the\\(\\backslash\\)AmSTeX \\(\\{\\)\\(\\}\\) Macro Package: A Gourmet Guide to Typesetting with the AMS-TEX Macro Package. American Mathematical Soc."
  },
  {
    "objectID": "quarto.html#single-sourcing-출판저작",
    "href": "quarto.html#single-sourcing-출판저작",
    "title": "5  쿼토(Quarto)",
    "section": "5.1 Single Sourcing 출판저작",
    "text": "5.1 Single Sourcing 출판저작\n데이터 사이언스 출판저작에 다소 차이는 있지만 출판에 대한 대체적인 방식은 유사할 것으로 보인다. 즉, Single Sourcing 을 콘텐츠 저작, 디자인, 최종 출판물 관리까지 일원화되어 자동화되어 체계적으로 관리된다면 중복되는 낭비는 물론 재현가능성도 높여 과학기술 출판저작물로 가장 이상적으로 간주되고 있다.\n\n5.1.1 문제점\n\n\n\n그림 5.1: 문제점\n\n\n\n\n5.1.2 개념\n\n\n\n그림 5.2: Single Sourcing 개념\n\n\n\n\n5.1.3 Single Sourcing Multi-Use\n\n\n\n그림 5.3: Single Sourcing Multi-Use"
  },
  {
    "objectID": "quarto.html#작업흐름",
    "href": "quarto.html#작업흐름",
    "title": "5  쿼토(Quarto)",
    "section": "5.2 작업흐름",
    "text": "5.2 작업흐름\n기존 R .Rmd, 파이썬 .ipynb 확장자를 갖는 작업흐름이 .qmd 파일로 단일화되는 것이 가장 큰 특징이다. 따라서 마크다운으로 콘텐츠를 작성하고 프로그래밍 코드를 R, 파이썬, 자바스크립트, 쥴리아 로 작성하게 되면 자동으로 계산을 수행하고 결과물을 마크다운으로 변환시키기 때문에 후속 작업을 신경쓰지 않고 원하는 결과물을 얻을 수 있는 장점이 있다.\n\n5.2.1 R (.Rmd)\n\n\n\n\n\n\n\n5.2.2 파이썬 (주피터)\n\n\n\n\n\n\n\n5.2.3 Quarto - R\n\n\n\n\n\n\n\n5.2.4 Quarto - 파이썬"
  },
  {
    "objectID": "quarto.html#쿼토-해부",
    "href": "quarto.html#쿼토-해부",
    "title": "5  쿼토(Quarto)",
    "section": "5.3 쿼토 해부",
    "text": "5.3 쿼토 해부\n쿼토는 데이터 과학 문서 작성 패러다임을 바꾼 R마크다운의 후속작으로 볼 수 있다. 쿼토는 10년 이상의 knitr 경험을 바탕으로 개발되었으며, 최근에는 위지윅(What You See Is What You Get) 패러다임도 RStudio Visual 편집에 도입하여 복잡한 코드 작성 없이 직관적으로 문서를 작성할 수 있다. R 사용자는 RStudio IDE, 파이썬 등 개발 경험이 풍부하신 분들은 파이참, VS코드, 이맥스/VIM 등 통합개발환경(IDE)을 쿼토 CLI를 통해 출판물을 쉽게 저작할 수 있다.\n쿼토는 다양한 프로그래밍 언어를 통해 계산(Computation) 기능을 문서에 담을 수 있도록 지원한다. R, 파이썬, SQL, 자바스크립트 등 다양한 프로그래밍 언어로 문서 내에 그래프, 표, 인터랙티브 결과물을 쉽게 삽입할 수 있다. 이러한 장점들이 모여 문서를 제작하고 유통하고 소비하는 데이터 과학자, 개발자, 과학기술 연구원, 사무노동자 분들의 시간을 줄여주고 업무 생산성을 크게 높여주는 도구로 자리매김하고 있다.\n\n\n\n쿼토 작업흐름\n\n\n쿼토 저작은 메타데이터(전문, front matter), 텍스트, 코드라는 세 가지 주요 구성요소로 이뤄진다.\n\n메타데이터 (YAML): YAML은 “YAML Ain’t Markup Language”의 약자로, 데이터를 구조화하기 위한 언어로, 쿼토에서 문서에서 전문(Front Matter)을 구성하는 문서 제목, 작성자, 날짜, 문서 형식 등을 정의한다. 메타데이터는 보통 문서 상단에 위치하며, 문서의 전반적인 설정과 구성을 담당한다.\n텍스트 (마크다운): 마크다운도 언어로, 2004년 아론 스워츠와 존 그루버가 주도하여 탄생했다. HTML 같은 복잡한 마크업 언어 대신, 간단한 형식의 문서를 빠르고 효율적으로 작성할 수 있는 도구로 복잡한 디자인보다는 내용의 구조와 의미에 중점을 두기 때문에 문서 작성자는 외양보다 내용에 더 집중할 수 있다는 장점이 있다.\n코드 (knitr, jupyter): knitr는 R 코드를 문서에 통합을 가능케하고, jupyter는 파이썬 사용자에게 인기있는 패키지다. 쿼토에서 knitr, jupyter에서 작성된 코드를 문서에 포함시킬 수 있어 데이터 분석 통계값, 그래프, 다이어그램, 지도 등 다양한 결과물을 문서에 삽입할 수 있다.\n\n\n\n\nQuarto 문서 구성요소\n\n\n\n5.3.1 YAML\nYAML(발음은 야믈)은 쿼토파일 메타데이터로 문서 본문보다 먼저 제시되는 전문(front matter)으로 문서를 구조화하기 R 마크다운, 쿼토에서 도입된 경량언어로 쿼토에서는 문서 제목, 작성자, 날짜, 문서 형식, 레이아웃 등을 정의한다. 보통 키값(key-value) 쌍을 이루는데, 키는 콜론(:)으로 값과 구분한다.\n\n\n\n\n키값 쌍\n---\nkey: value\n---\n\n\n\n\n\n문서출력형식 PDF 지정\n---\nformat: pdf\n---\n\n\n\nYAML로 문서 전문을 작성하게 되면 가독성이 뛰어나 읽고 이해하기 쉽다. 복잡한 문서 구조나 설정을 지정할 때 특히 유용하다. 중첩된 선택옵션과 같은 복잡한 문서구조도 들여쓰기(indent)를 통해 명확히 표현된다. 재사용성도 뛰어나 같은 설정 값을 여러 곳에서 사용해야 할 경우, YAML 파일 하나를 수정하면 모든 곳에 적용될 수 있어 시간과 노력을 절약해준다. 또한, 텍스트 기반이라 Git과 같은 버전 제어 시스템과 잘 통합되어 여러 저자가 공동 작업 진가를 발휘한다. 하지만, 들여쓰기에 민감하여 실수로 공백을 잘못 넣었을 경우 오류가 발생할 수 있으므로 주의가 요구된다.\nYAML은 단순히 KEY: Value 에 불과한데 사례를 통해 YAML의 편리성과 유용함을 살펴보자.\n\n\n\nCLI PDF 지정\n$ quarto render document.qmd --to pdf\n\n\n\n\n\nYAML 문서형식 PDF\n---\nformat: pdf\n---\n\n\n\n다음 예시에서 quarto render 명령을 사용하여 document.qmd 파일을 HTML 형식 문서로 제작하는데 CLI에서 옵션에서 -M code fold:true을 통해 코드 섹션을 접을 수 있는 형태로 제작함을 나타내고 있다.\n동일한 의도를 YAML 설정으로 바꾸면, 설정 파일에 format 섹션을 만들고 그 안에 html을 정의하고 나서, html 포맷에 목차 생성(toc: true)과 코드 접기 기능(code-fold: true)을 추가로 설정했다.\n동일한 의도를 CLI에 넣는 것보다 YAML 파일에 담게되면 훨씬 깔끔하고 우아하다. 많은 선택옵션들이 명령어로 직접 들어가면 명령어가 길어져 가독성이 떨어지고, 나중에 어떤 옵션을 사용했는지 파악하기도 어렵다. 반면 YAML 파일이 도입되면, 설정을 한 곳에서 명확하게 관리할 수 있어 유지보수도 편리하고, 공동 저작자들과 쉽게 공유되기 때문에 협업에도 유리하다.\n\n\n\nCLI 코드접기\n$ quarto render document.qmd --to html -M code fold:true\n\n\n\n\n\nYAML 코드접기\n---\nformat: \n  html:\n    toc: true\n    code-fold: true\n---\n\n\n\n문서저작 통합개발환경(IDE) RStudio나 VSCode 에서 제공하는 탭-자동완성(Tab Completion) 기능은 YAML 전문코드를 작성할 때 큰 도움이 된다. 첫 글자나 몇몇 글자를 타이핑한 후에 탭 키를 누르면, IDE가 가능한 모든 명령어나 변수, 함수 이름 등을 보여주기 때문에 저작자는 오타를 줄이고 빠르게 문서를 저작할 수 있다. RStudio에서 Ctrl + space 단축키를 사용하면, YAML 전문코드를 작성할 때 키값을 선택할 수 있는 목록을 보여준다.\n\n\n\n\n\n\nYAML 키 설정\n\n\n\n \n\n\n\n\n탭 자동완성 선택확정\n\n\n\n그림 5.4: RStudio YAML 자동완성\n\n\n\n5.3.2 마크다운\n\n\n5.3.3 프로그래밍 언어"
  },
  {
    "objectID": "quarto.html#r-마크다운과-비교",
    "href": "quarto.html#r-마크다운과-비교",
    "title": "5  쿼토(Quarto)",
    "section": "5.4 R 마크다운과 비교",
    "text": "5.4 R 마크다운과 비교\nFAQ for R Markdown Users\n쿼토는 “차세대 R 마크다운”이라는 별명답게 R 마크다운 생태계의 다양한 패키지와 기능을 지원한다. 쿼토가 시작이 R 마크다운보다 길지 않아 아직 R 마크다운 생태계의 모든 기능을 지원하지는 않지만, 점차 지원 범위를 넓혀나가고 있으며 고유한 기능도 추가로 제공하기 시작했다.\n\n\n\n기능\nR 마크다운\n쿼토(Quarto)\n\n\n\n\n파일형식\n\nhtml_document\npdf_document\nword_document\n\n\nhtml\npdf\ndocx\n\n\n\n비머(Beamer)\n\nbeamer_presentation\n\n\nbeamer\n\n\n\n파워포인트(PPT)\n\npowerpoint_presentation\n\n\npptx\n\n\n\n웹 슬라이드\n\nxaringan\nioslides\nrevealjs\n\n\nrevealjs\n\n\n\nAdvanced Layout\n\ntufte\ndistill\n\n\nQuarto Article Layout\n\n\n\nCross References\n\nhtml_document2\npdf_document2\nword_document2\n\n\nQuarto Crossrefs\n\n\n\nWebsites & Blogs\n\nblogdown\ndistill\n\nQuarto Websites\nQuarto Blogs\n\n\nBooks\nbookdown\nQuarto Books\n\n\nInteractivity\nShiny Documents\nQuarto Interactive Documents\n\n\nPaged HTML\npagedown\n출시 예정\n\n\nJournal Articles\nrticles\nQuarto Journal Articles\n\n\nDashboards\nflexdashboard |\n출시 예정\n\n\nInteractive Tutorials\nlearnr\n계획 없음\n\n\n\n\n\n\n\nHyde, A. (2021, 8월 16). Single Source Publishing - A investigation of what Single Source Publishing is and how this ’holy grail’ can be achieved. https://coko.foundation/articles/single-source-publishing.html"
  },
  {
    "objectID": "markdown_01_mess.html#세가지-패러다임",
    "href": "markdown_01_mess.html#세가지-패러다임",
    "title": "6  심각한 현재 상황",
    "section": "6.1 세가지 패러다임",
    "text": "6.1 세가지 패러다임\n문자전용 도구와 그림을 위한 도구 사이 간격을 보여주는 한가지 흔적이 문자와 그림을 제어하기 위한 별도 언어개발에서 찾아볼 수 있다. 플로터는 일반적으로 제도 언어(drawing language) 로 제어된다. 다음 예를 보면 이해가 쉽다. “펜을 위로, (x, y) 위치로 이동, 펜을 아래로, 다시 해당 위치만큼 이동한다”\nPU;\nPA200,150;\nPD;\nPA250,250;\n반대로, 라인 프린터를 위한 조판 언어(Typesetting language) 로 저자는 컴퓨터에 두번째 제목으로 문구를 설정하고, 단어를 이탤릭체로 설정하게 지시한다. 그러고 나면, 컴퓨터가 단어 위치와 외양을 결정한다.\n.t2 Section Heading\n\nEmpty lines separate\n.it paragraphs\nand lines starting with '.' are commands.\n이 기간동안에 세번째 유형의 언어가 생겨났는데, 외양 보다는 문서 콘텐츠(content)를 기술하려고 초점을 뒀다. 의사와 변호사는 환자 진료기록과 판례를 검색하고자 했지만, 그 당시 컴퓨터가 자연어를 처리할만큼 강력하지 못했다. 그래서, IBM 같은 회사가 마크업 언어 를 개발해서, 사람들이 문서의 의미 즉 시맥틱 을 명시적으로 기술하게 만들었다:\n&lt;person&gt;Derstmann&lt;/person&gt; still questions the importance of &lt;chemical&gt;methane&lt;/chemical&gt; release\nin &lt;event&gt;the Fukuyama disaster&lt;/event&gt;."
  },
  {
    "objectID": "markdown_01_mess.html#저작도구-쓰임새",
    "href": "markdown_01_mess.html#저작도구-쓰임새",
    "title": "6  심각한 현재 상황",
    "section": "6.2 저작도구 쓰임새",
    "text": "6.2 저작도구 쓰임새\n세가지 세계가 1970년대 레이져 프린터의 발명으로 충돌했고, 1980년대 고해상도 컴퓨터 화면과 1990년대 월드와이드웹으로 확대만 되었다. 다른 한편으로, 대부분의 사람들은 단순히 저작만을 원했다 – 이 단어는 여기에, 저 단어는 저기에, 단어중 일부는 녹색으로, 다른 단어는 이탤릭으로 … 아래한글, 마이크로소프트 워드, 맥라이트 같은 위지윅(WYSIWIG, What You See Is What You Get) 편집기가 이런 요구를 채워줬지만, 이런 방식으로 만들어진 문서는 두가지 결점을 갖고 있다:\n\n융통성이 없다(rigid). 누군가 수작업으로 배치를 바꾸고 나서, 페이지 크기를 변경하면, 다시 재작업을 수행해야만 된다.\n불분명하다. 컴퓨터에 무언가 이택릭으로 표현하도록 지시하면, 해당 문구가 책제목인지, 혹은 새로운 용어를 정의하는지 분간할 수 없다.\n\n조판언어와 마크업 언어는 상기 두가지 문제를 다루고 있다. 텍스트와 그림 외양과 페이지 위치에 대해 언급하는 대신에, 저자는 컴퓨터에 텍스트와 그림이 어떤 유형인지를 전달한다: 예를 들어, 제목 혹은 신규 용어. 그리고 나면, 컴퓨터가 외양이 어떨지, 어디에 위치해야 될지 결정한다. 시맨틱 의미와 외양을 이런 방식으로 구별하게 되면 저자는 쉽고 일관성을 갖고 스타일을 전환할 수 있게 된다. 예를 들어, “모든 두번째 제목을 16 포인트, 나눔고딕체로 왼쪽정렬하라.”\n하지만, 이런 접근법도 결점은 있다:\n\n컴퓨터는 텍스트를 이해하지 못하기 때문에 항상 인간과 같은 방식으로 텍스트를 배치하지는 않는다. 따라서 사람들은 컴퓨터가 경직성을 재도입하더라도 컴퓨터의 선택을 재정의할 수 있어야 한다고 주장해 왔다.\n문서의 의미를 지정하는 것은 대부분의 사람들에게 낯선 일이며 제목을 몇 번 확대하는 것보다 훨씬 더 많은 작업이 필요하다.\n저자가 입력한 내용을 해석하고 표시할 내용을 파악하는 데는 컴퓨터 시간이 오래 걸린다. 왜 문서가 의도한 바를 반영하지 못하는지 알아내는데는 몇배 시간이 든다; 이것이 정확하게 프로그램을 디버깅하는 것과 같고, 디버깅은 대략 난감한 작업이다.\n\n지금까지 그 누구도 상기 문제를 모두 피하는 무언가를 발명하지는 못했다. 그래서, 저작을 할 때면 오늘날 연구자를 비롯한 많은 분들이 다양하고 혼동되는 선택지를 받게 되었다:\n\n아래한글, 리브레오피스, 마이크로소프트 워드 같은 데스크톱 위지윅 도구 (리브레오피스와 워드는 .docx 파일형식으로 호환 동작된다). 지금까지 편지같은 단순한 저작물을 생성하는 가장 쉬운 방식이지만, 융통성이 없고, 불명확하고 수식을 배치하는 기능이 상대적으로 미약하고, 버젼제어 시스템과 궁합이 맞지 않는다.\n구글 독스 같은 웹기반 위지윅 도구. 워드나 한글, 리브레오피스의 신속성을 갖추고, 더불어 협업을 수월(왜냐하면 모든이가 문서 사본 하나만 공유하기 때문)하게 한다. 하지만, 웹기반 위지윅 도구는 여전히 융통성이 없고 불명확하며, 책임을 질 수 없는 개인회사 바구니에 모든 달걀을 놓는 것에 많은 사람들이 불편해하고 있다.\n데스크톱 LaTeX. 강력한 조판언어로 수식과 참고문헌관리에 정말 훌륭한 기능을 제공한다. 버젼제어 시스템과 조화가 잘 되는데, 일반 텍스트로 문서를 저작하기 때문이다. 하지만, 지금까지 학습하기 가장 복잡하고, 텍스트와 그림을 원하는 곳에 배치시키는 작업이 고생스럽게도 수시간 소요될 수 있다.\nAuthorea, Overleaf 같은 웹기반 도구는 위지윅 편집 인터페이스를 저자에게 제공하지만 문서는 LaTeX으로 저장되고, 변경사항을 타이핑해서 넣을 때마다 실시간으로 화면에 다시 출력해서 보여준다.\nHTML. 웹의 네이티브 언어로 LaTeX 보다 훨씬 (훨씬) 더 단순하지만, 훨씬 더 적은 기능을 제공한다: 주석, 참고문헌관리, 절마다 번호매기기 같은 단순한 기능도 직접적으로 지원되지 않는다. 상당히 버보스하게 상세할 수도 있고, CSS2는 변덕스러운 것으로도 유명하다.\n\n\n마크다운 : HTML에 대한 단순화 대안으로 개발되었다. 마크다운은 일반-텍스트 전자우편 관례를 사용한다: 빈줄은 문단을 구분하고, 이탤릭체로 만드는데 *별표*로 감싸는 등등. HTML보다 더 적은 작업을 수행하지만, 타이핑 양은 훨씬 더 적다. 하지만, 불행하게도 거의 모든 마크다운 구현결과물이 자체적인 기능이 추가되어서 “마크다운 표준”은 모순어법에 해당된다.\n\nHTML과 마크다운은 직접적으로 수식을 지원하지 않지만, 플러그인 혹은 팩키지가 존재해서 저자가 LaTeX-유형의 수식을 문서에 삽입할 수 있다. 쥬피터 노트북(Jupyter Notebook)은 이런 팩키지에 의지해서 사용자가 수식과 기타 다른 것들을 마크다운 셀에 넣어서 브라우져에서 렌더링할 수 있게 구현한다.\n저작 도구를 선택할 때 마지막으로 고려할 점은 LaTeX 같은 데스크톱 텍스트 기반 시스탑과 재현가능 연구를 지원하는 연산기능을 관리하는 다른 도구를 적절히 통합하는 것이다. 적어도 지금으로는 전형적인 지구물리학 혹은 생물정보학 파이프라인과 구글 독스 혹은 리브레오피스를 통합하는 것이 훨씬더 복잡하다. 예를 들어, 데이터가 변경될 때 그림이 자동으로 갱신되는 것을 들 수 있다.\n\n\n\n\n\n\n엎친 데 덮친 격\n\n\n\n위지윅과 조판/마크업 구분은 실제 파일형식보다 도구로 작업하는 것에 더 연관되어 있다: .docx 파일은 실제로 LaTeX, HTML, 마크다운 파일처림 조판 명령어와 텍스트가 혼재되어 있다. 차이점은 조판/마크업 언어로 작성된 명령어는 사람이 읽을 수 있는 텍스트로 저장된다는 것이다. 이것이 함의하는 바는 유닉스 명령-라인 유틸리티가 처리할 수 있다는 점이다. (스택오버플로우에서 지적한 것처럼, 실제로 얼마나 많은 작업 수행할지에 대해 한계가 존재한다) 이와 비교해서, 아래한글, 마이크로소프트 워드, 리브레오피스에 내장된 서식 명령어는 특정한 전용 프로그램을 위해, 특정 프로그램에 의해서 제작되었다. 따라서, grep 같은 일반-텍스트 도구로는 처리가 되지 않는다.\n구글 독스도 마찬가지다: 서식 명령어가 문서에 내장되어서 사용자가 상호작용하는 페이지를 렌터링해서 생성할 때 사용자 브라우져에서 돌고 있는 자바스크립트로 실행된다. 저장형식이 LaTeX이라는 점을 제외하면, Authorea 와 Overleaf 도 동일한다.\n강성 프로그래머는 위지윅 도구와 텍스트가 아닌 형식을 조롱할 수도 있지만, 기초는 진흙으로 만들어져 있다. 마이크로소프트 워드는 수십년동안 시장을 지배하고 있다; 이 기간동안 문서형식은 몇번 변경되었지만, 명령-라인 애호가는 충분한 시간을 갖고 선호하는 도구로 이를 처리할 수 있었다. 하지만, 그런 일은 일어나지 않았다. 이것이 의미하는 바는 버전제어 시스템 대부분이 세상에서 가장 널리 사용되는 문서형식을 처리할 수 없다는 점이다: 두가지 다른 마이크로소프트 워드 파일을 마주쳤을 때, Git과 Git의 친족은 “차이가 탐지되었습니다”라고 말하는 것이 전부다. 전체적인 효과는 버전제어를 도입하려는 누구나 본인과 동료가 언젠가는 엄청난 생산성 향상을 목표로 도입하여 수년동안 사용한 도구를 포기하는 것이다.\n상기 논의는 저자가 논문과 편지만 작성하다고 가정했지만, 과학연구자는 자주 본인 작업을 시연하는데, 포스터와 슬라이드 자룔를 생성할 필요가 있다. 파워포인트는 말이 필요없는 발표도구의 여왕이다: 많은 사람들이 파워포인트 때문에 발표가 엉망이 되어다고 비판하지만, 이것은 마치 시적 표현이 좋지 못한 것을 만연필 핑계를 대는 것에 비견된다. 파워포인트와 파워포인트 짝퉁은 컴퓨터 화면을 마치 칠판처럼 사람들이 쉽게 사용할 수 있게 만들었다. 중요항목 목록으로 구성된 너무나도 지루한 슬라이드를 쭉 생성할 수도 있지만, 쉽고 자유롭게 이미지, 도표, 텍스트를 섞어 사용할 수도 있다. LaTeX과 HTML로 그런 작업을 수행할 수 있지만, 어느쪽도 그다지 쉽지는 않다. 사실, LaTeX이나 HTML 모두 어려워서 대부분 사람들은 신경도 쓰지 않는다. 설사 그런 작업을 수행한다손 치더라도, 그래픽적인 요소는 문서의 중요한 부분이라기 보다는 외부 삽입에 불과하다.\n논문과 발표자료를 함께 생각하면 다소 불편한 상황에 있음을 인지하게 된다. 다른 한편으로, 논문과 발표자료는 연구 프로젝트에서 핵심적인 부분으로 코드와 데이터처럼 공유되고 추적관리되어야 한다. 다른 한편으로 스테픈 터너(Stephen Turner)는 다음과 같이 언급했다:\n공동작업하는 지친 물리연구원에게 문서를 컴파일하는 개념을 설명하려고 한다고 보자. 그전에 일반 텍스트와 워드 프로세싱 사이 차이점을 설명해야 된다. 그리고 텍스트 편집기도 잊으면 안된다. 그리고 나서 마크다운/LaTeX 컴파일러. 그리고 BiBTeX. Git 그리고 GitHub 등등. 그러는 동안에 연구원은 다른 곳에서 호출 연락을 받을 것이다…\n… 달리 설득시킬만큼 노력하지만, 과학컴퓨팅 외부 사람들과 협업할 때, 이러한 얼개를 갖고 논문 협업을 하는 장벽이 너무나도 높아서 단순히 극복이 되지 않는다. 좋은 취지는 제쳐두고, 항상 “검토 메뉴에 변경내용 추적을 갖는 워드 문서만 주세요” 혹은 그와 유사하게 끝나게 된다."
  },
  {
    "objectID": "markdown_01_mess.html#과학기술-저작도구",
    "href": "markdown_01_mess.html#과학기술-저작도구",
    "title": "6  심각한 현재 상황",
    "section": "6.3 과학기술 저작도구",
    "text": "6.3 과학기술 저작도구\n가까운 장래에는 과학 연구자 상당수가 순수 텍스트 조판 툴로 바꾸기 보다는 계속해서 위지윅 편집기 혹은 연관된 파일형식을 사용할 것이다. Authorea와 Overleaf 같은 하이브리드 시스템이 이러한 절벽을 경사로로 바꿀 것이고, 프로그래머가 궁극적으로 다른 99% 사용자가 선호하는 문서형식에 체면을 갖추고 관심을 가질 것이지만, 수년간의 작업이 소요될 것이다.\n대부분 과학분야 연구원이 이미 아래한글, 마이크로소프트 워드 같은 데스크톱 위지윅 시스템과 구글 독스같은 클라우드 대체 소프트웨어와 친숙하기 때문에, 순수 텍스트 대체 언어만 다룰 예정이다: 웹사이트와 블로그를 위한 마크다운, 원고 저작을 위한 LaTeX. 웹에는 마크다운을 추천하는데 이유는 대부분 사람이 HTML로 원하는 모든 것을 그다지 많이 타이핑하지 않고도 수행하기 때문이다. 원고 저작에 (적어도 지금은) 마크다운을 추천하지 않는다. 이유는 다음과 같다:\n\n저널 대부분이 제출형식으로 받아주지 않기 때문이다.\n고위 연구협력자가 이를 받아줄 가능성은 없다. (물론, 고위 연구협력자가 LaTeX을 사용하지 않았다면, LaTeX으로 전환하지도 않을 것이다…).\n과학연구원이 원하는 기능 상당수를 마크다운이 지원하는 않는다. (예를 들어, 참고문헌 서지관리)\n\n반면에 LaTeX을 추천하는 이유는 다음과 같다:\n\nPDF와 다른 표준형식으로 컴파일 작업을 수행한다.\n그림과 표를 배치하는데 탁월한 성능을 보여준다.\n버젼제어와 잘 묶어 작업할 수 있다.\n서지관리 소프트웨어 상당수와 호환된다.\n많은 저널에서 받아주는 형식이다. (하지만, 학문 분야마다 상당한 다양성이 존재한다.)"
  },
  {
    "objectID": "markdown_02_markdown.html",
    "href": "markdown_02_markdown.html",
    "title": "7  마크다운 기초",
    "section": "",
    "text": "들어가며"
  },
  {
    "objectID": "markdown_02_markdown.html#메타데이터metadata",
    "href": "markdown_02_markdown.html#메타데이터metadata",
    "title": "7  마크다운 기초",
    "section": "7.1 메타데이터(Metadata)",
    "text": "7.1 메타데이터(Metadata)\n마크다운으로 문서 메타데이터를 저자가 야믈(YAML) 헤더에 나타낼 수 있다. YAML 은 “Yet Another Markup Language”를 축약한 두문어지만 중요하지는 않다. YAML 헤더는 다음과 같다.\n---\ntitle: \"마크다운과 팬독(`pandoc`)을 활용한 과학기술문서 저작\"\nshorttitle: \"현대적인 과학기술 문서 저작\"\nauthor: 이광춘\ndate: \"2015년 7월 7일\"\n---\n상기 야믈(YAML) 헤더 요소는 견본(템플릿) 으로 사용되고 해당 문서에 대한 메타데이터가 정의된다."
  },
  {
    "objectID": "markdown_02_markdown.html#기본-구문",
    "href": "markdown_02_markdown.html#기본-구문",
    "title": "7  마크다운 기초",
    "section": "7.2 기본 구문",
    "text": "7.2 기본 구문\n\n7.2.1 제목\n줄에 숫자 기호(#)를 한개부터 여섯개까지 작성해서 텍스트에 작성되는 구분 수준이 결정된다. 예를 들어, 다음 문서는 첫번째 큰 제목 두개(들어가면, 방법론)를 갖고, 방법론 제목에 중첩된 두번째 제목을 갖는다: 동적 인구 모형\n\n\n# 들어가며\n# 방법론\n## 동적 인구 모형\n\n\n\n\n\n\n\n방법론\n\n동적 인구 모형\n\n\n\n\n\n\n7.2.2 텍스트 서식\n마크다운으로 쉽게 이탤릭, 굵게, 이탤릭 굵게 글씨체를 지정할 수 있다. (하지만, 모든 마크다운이 마지막 서식구문에 동의하지는 않는다). 글꼴에 서식 적용은 * 혹은 _을 사용해서 적용한다. 따라서 다음 명령어는 모두 동등하다:\n\n\n*이탤릭* 그리고 _이탤릭_\n**굵게** 그리고 __굵게__\n***이탤릭 굵게.*** 그리고 ___이탤릭 굵게.___\n\n\n\n이탤릭 그리고 이탤릭  굵게 그리고 굵게  이탤릭 굵게. 그리고 이탤릭 굵게.\n\n\n\n\n7.2.3 코드\n코드는 백틱으로 텍스트를 감싸 인라인(inline) 으로 작성하거나,\n\n\n프로그램 실행은 `python helloworld.py`으로 프롬프트를 작성한다.\n\n\n\n프로그램 실행은 python helloworld.py으로 프롬프트를 작성한다.\n\n\n혹은 백틱(`) 3개나 틸드(~) 3개를 한줄씩 코드상하에 넣어 코드블록을 구분한다:\n\n\n```\n이것이\nR, 파이썬\n코드블록 입니다.\n```\n\n\n\n이것이\nR, 파이썬\n코드블록 입니다.\n\n\n코드블록 첫번째 행에, 프로그래밍 언어 를 명세하는 것도 가능하다:\n\n\n`python` 으로 언어를 명세한다:\n\n```python\nfor i in xrange(5):\n  print \"This is line \" + str(i) + \" of this useless loop.\\n\"\n```\n\n훌륭해 보입니다!\n\n\n\npython 으로 언어를 명세한다:\nfor i in xrange(5):\n  print \"This is line \" + str(i) + \" of this useless loop.\\n\"\n훌륭해 보입니다!\n\n\n\n\n7.2.4 링크\n하이퍼링크를 작성하는 방식은 두가지가 있다. 첫번째는 인라인 으로 작성하는 것으로 [텍스트](http://link.tld) 방식을 사용한다. 두번째는 명칭을 지정한 표식을 사용하는 방식이다. 예를 들어:\n\n\n이것은 [첫번째 링크], 다음은 또다른 [두번째 링크][link2] 혹은 [세번째 링크](http://link.1)\n\n[첫번째 링크]: http://link.1\n[link2]: http://link.2\n\n\n\n이것은 첫번째 링크, 다음은 또다른 두번째 링크 혹은 세번째 링크\n\n\n명칭을 지정한 표식을 사용하는 방식에 대한 구문은 [텍스트][표식] 이 먼저 나오고 나서, [표식]: http://link 표식링크가 문서 다음에 뒤따라 나온다. [표식]이 없는 경우 [텍스트]: link 방식으로 동작하게 된다."
  },
  {
    "objectID": "markdown_02_markdown.html#동적-인구-모형",
    "href": "markdown_02_markdown.html#동적-인구-모형",
    "title": "7  마크다운 기초",
    "section": "동적 인구 모형",
    "text": "동적 인구 모형"
  },
  {
    "objectID": "markdown_02_markdown.html#컴파일",
    "href": "markdown_02_markdown.html#컴파일",
    "title": "7  마크다운 기초",
    "section": "7.3 컴파일",
    "text": "7.3 컴파일\n지금까지 작성원고는 말그대로 마크다운 자체 파일(확장자가 mkd, .markdown, .pandoc)이다. 마크다운을 뭔가 다른 것으로 변환할 필요가 있다. 대체로 PDF, 혹은 텍스트 프로세서에서 볼 수 있는 문서형식이 된다.\n\n7.3.1 팬독(pandoc) 으로 컴파일\n팬독(pandoc) 프로그램이 이런 작업을 수행하는 나름 최적의 도구다.(물론, jekyll 처럼 웹에 특화된 도구도 존재한다.) 대부분의 명령-라인 도구와 마찬가지로, pandoc은 입력값으로 파일과 일부 선택옵션 플래그를 순차적으로 받는다. pandoc을 호출하는 기본방식은 다음과 같다:\npandoc input.ext -o output.ext\n\n기본 구문\n팬독(pandoc) 아래 숨은 마술 로 입력파일이 출력 파일로 된다. 다음 경우에, 입력파일은 마크다운으로 PDF 파일을 생성하는 마술 명령어는 다음과 같다:\npandoc manuscript.md -o manuscript.pdf\n그리고 MS 워드 문서를 생성하려면 다음과 같다.\npandoc manuscript.md -o manuscript.doc\ndocx, otf는 신규 워드문서와 리브레오피스 확장자다. txt, rtf, html을 시도해보고 산출결과가 어떻게 달라지는지 살펴본다.\n\n\n\n7.3.2 견본 템플릿\n최종문서에 작성한 것을 어디에 넣을지 팬독(pandoc)은 어떻게 알 수 있을까? 다양한 견본 템플릿 이 존재하는데, 견본 템플릿에는 pandoc이 모든 요소를 어디에 넣을지 정리되어 있다. pandoc 웹사이트에서 견본 템플릿을 복사하고 변경할 수 있는 다양한 정보가 담겨있다. 구글로 바로 찾을 수 있는 재사용가능한 견본 템플릿이 상당히 많다.\n\n\n7.3.3 선택옵션 플래그\n선택옵션 플래그를 통해서 pandoc에 추가적인 인자를 전달한다. pandoc 에서 지원하는 인자가 상당히 많은데, 자세한 정보는 쉘를 열고 man pandoc 도움말을 참조하거나, 인터넷 온라인 문서를 참조한다. 본 학습에서는 참고문헌과 관련된 두가지 선택옵션 플래그에 집중한다."
  },
  {
    "objectID": "markdown_03_advanced.html#수식",
    "href": "markdown_03_advanced.html#수식",
    "title": "8  고급 마크다운",
    "section": "8.1 수식",
    "text": "8.1 수식\n수식을 LaTeX 구문으로 작성할 수 있다. 예를 들어, 아래 코드 덩어리는 적법한 마크다운 구문이다:\nThe equation for a polynomial function is $y(x) = ax^2 + bx +c$.\n그리고 다음도 적법하다:\nThe sum of a vector of numbers ($\\mathbf{v}$) is noted\n\n\\begin{equation}\n\\sum_{x=1}^n\\mathbf{v}_i\n\\end{equation}"
  },
  {
    "objectID": "markdown_03_advanced.html#표",
    "href": "markdown_03_advanced.html#표",
    "title": "8  고급 마크다운",
    "section": "8.2 표",
    "text": "8.2 표\n마크다운이 갖는 이슈중 하나는 표에 대한 지원이 미약하다는 점이다. (하지만, LaTeX 구문을 사용하는 것은 가능) 그럼에도 불구하고, 상대적으로 간단한 표를 작성하는 방법은 있다.\n|  교과목  |    담당자 |     선수 교과목 |\n|:---------|:-----------|------------------:|\n| 마크다운 | xwMOOC        | 쉘, Git, Makefiles |\n상기 구문을 적용하면 다음에 나온 표가 작성된다.\n\n\n\n교과목\n담당자\n선수 교과목\n\n\n\n\n마크다운\nxwMOOC\n쉘, Git, Makefiles\n\n\n\n표를 구성하는 요소가 몇개 있다. 첫번째 줄은 헤더 로 표제목, 두번째 줄은 정렬, 그 다음 줄이 표에 기술되는 내용물 이 된다.\n칼럼은 파이프(|) 기호로 구분한다. 파이프를 수직방향으로 정렬할 필요는 없다. (하지만, 원문서를 읽을 때 가독성을 상당히 높힌다 – 편집기 대부분에는 이런 기능을 플러그인으로 지원한다)\n기본디폴트 설정으로 칼럼은 좌측 정렬 된다. 정렬을 명세하려면, 두번째 행에 다음과 같이 : 세미콜론을 사용해서 지정한다.\n|   좌측정렬  |  중앙정렬  |    우측정렬   | 기본 설정 (좌측) |\n|:-------------|:--------:|--------------:|:---------------|\n| `:---`       |  `:--:`  |        `---:` | `----`         |\n상기 구문을 적용하면 다음에 나온 표가 작성된다.\n\n\n\n좌측정렬\n중앙정렬\n우측정렬\n기본 설정 (좌측)\n\n\n\n\n:---\n:--:\n---:\n----"
  },
  {
    "objectID": "markdown_03_advanced.html#그림",
    "href": "markdown_03_advanced.html#그림",
    "title": "8  고급 마크다운",
    "section": "8.3 그림",
    "text": "8.3 그림\n그림은 마크다운에서 잘 지원되고 있다. 표기법은 링크에 사용된 표기법을 따르지만, 느낌표(!)를 앞에 위치시킬 필요가 있다.\n예를 들어,\n![소프트웨어 카펜트리 로고](images/swc-logo-blue.png)\n상기 구문을 적용하면 다음과 같이 그림이 삽입된다.\n\n\n\n소프트웨어 카펜트리 로고\n\n\n다른 방법으로 다음과 같이 그림 삽입 구문을 작성해도 된다.\n![소프트웨어 카펜트리 로고][swc]\n[swc]: (images/swc-logo-blue.png)\nLaTeX 명령어, \\label{f:swc} 라벨을 넣은 것에 주목한다. \\autoref{f:swc}를 사용해서 텍스트에 그림을 참조하게 한다. LaTeX에 autoref 팩키지는 놀랍도록 유용한데, 참조하는 객체 유형을 식별해서, 사람이 관여하지 않고도 Fig. 1, Tab. 2, Eqn. 3, 혹은 기타 필요한 것을 자동으로 완성시킨다."
  },
  {
    "objectID": "markdown_03_advanced.html#참고문헌의-표현",
    "href": "markdown_03_advanced.html#참고문헌의-표현",
    "title": "8  고급 마크다운",
    "section": "8.4 참고문헌의 표현",
    "text": "8.4 참고문헌의 표현\n학술논문에 있는 최종 요건은 참고문헌이다. pandoc과 pandoc-citeproc 확장기능을 통해 마크다운이 참고문헌 기능을 매우 우아하게 처리한다. pandoc 서지관리 모듈은 다양한 형식으로부터 인용을 불러올 수 있다. 최초 CSL JSON 와 CSL YAML로 설계되어, bibtex과 RIS를 수용할 수 있다.\n참고문헌을 참조하는 방식은 인용키, @CitationKey를 이용한다. 예를 들어, (bibtex) 라이브러리에 다음 참고문헌이 담겨 있다면:\n@ARTICLE{thom99,\n    title = {The raw material for coevolution},\n    journal = {Oikos},\n    author = {Thompson, John N},\n    number = {1},\n    volume = {84},\n    year = {1999},\n    pages = {5--16},\n}\n텍스트에 @thom99 을 넣어 참조한다. 모든 참고문헌 관리 소프트웨어를 사용해서 pandoc에서 지원되는 형식 중 하나로 내보내기 한다. 인용키가 보여주는 방식을 사용자 정의에 맞추면 된다.\n참고문헌을 ([@John2012; @Jack2014])와 같이 결합할 수 있고, 인라인 으로 “저자-년도” 스타일을 지정해서 사용하고 있다면 @Doe2013 작성하게 되면 Doe (2013)와 같이 표시되고, 괄호를 사용해서 [@Doe2013]와 같이 사용하면 (Doe, 2013) 산출물을 얻게 된다. 또한, 텍스트를 추가하는 것도 가능하다: [검토를 위해 @Billy2015 참조] 와 같이 작성하면, (검토를 위해 Billy et al., 2015 참조)와 같이 나타난다.\n참고문헌이 문서 끝에 자동으로 삽입된다. 저널 요건에 맞춰 서식을 바꾼 수천가지 방법이 있다."
  },
  {
    "objectID": "writing.html#글쓰기-비교",
    "href": "writing.html#글쓰기-비교",
    "title": "9  디지털 글쓰기",
    "section": "9.1 글쓰기 비교",
    "text": "9.1 글쓰기 비교\n디지털 글쓰기와 전통적인 글쓰기는 몇 가지 차이점이 있다. 디지털 글쓰기는 검색 엔진에 의해 쉽게 찾아질 수 있도록 설계되어 있으며, 다양한 미디어가 쉽게 통합될 수 있고, 디지털 글쓰기는 발행 후에도 언제든지 쉽게 조작할 수 있어 더 동적이고 생동감을 넣을 수도 있고, 깃(Git)과 같은 버전제어 도구와 연결시켜 글쓰기를 하게 되면 추적도 가능하여 재현가능한 글쓰기가 가능하게 된다. 디지털 글쓰기의 가장 큰 장점 중의 하나는 사람만이 저작을 하는 것이 아니라 기계가 저작한 프로그램도 글쓰기에 담을 수 있어 더욱 풍성한 글쓰기가 가능하다는 점이다.\n반면 전통적인 글쓰기는 발행 후 개발이 중단될 뿐만 아니라 한정된 지면(예를 들어 A4, B5)에 다양한 색상을 넣어 강조와 가독성을 높일 수 있으나 인쇄 난이도의 증가로 인해 비용도 급격히 증가하게 되고 무엇보다 정적인 정보만 담을 수 있어 최신 기술 흐름을 반영하는데 한계가 있다.\n또한 커뮤니케이션 관점에서 보면 디지털 글쓰기는 온라인 도구를 사용하여 작성 과정의 초기부터 광범위한 청중과 거의 실시간으로 텍스트를 공유할 수 있어 작성 과정이 공개적이고 다수다 저작과정에 별다른 장벽없이 참여할 수 있다는 점에서 전통적인 글쓰기가 소수의 저자가 집필을 마무리해야 후속 디자인 작업을 비롯한 후속 출판작업이 진행된다는 면에서 큰 차이가 있다. 특히 전통 글쓰기 결과물이 책과 같은 물리적 매체에 담기게 되면 이를 다시 디지털로 되돌리기 위해 광학문자인식(OCR) 과정을 거쳐야 하며 책속에 담긴 그래프, 표, 이미지 등 데이터는 별도 과정을 거쳐 디지털화 해야하는 한계도 명확하다."
  },
  {
    "objectID": "writing.html#쿼토",
    "href": "writing.html#쿼토",
    "title": "9  디지털 글쓰기",
    "section": "9.2 쿼토",
    "text": "9.2 쿼토\nQuarto Guide 웹사이트에 과학기술을 위한 문서 저작에 대한 전체적인 사항이 조망되어 있다. 최근 과학기술 저작물은 다양한 출판형식과 더불어 문학적 프로그래밍(literate programming) 패러다임을 도입하고 가독성과 커뮤니케이션 강화를 위해 상호작용 인터랙티브한 기능도 내장되어 있다.\n최근 과학기술 저작물은 전통적인 출판 패러다임을 떠나 급격한 변화를 경험하고 있다. 이러한 변화의 중심에는 다양한 출판 형식의 출현과 함께 문학적 프로그래밍(literate programming)이라는 새로운 패러다임의 도입이 큰 역할을 하고 있다. 문학적 프로그래밍은 코드와 설명을 결합하여 보다 이해하기 쉽고 읽기 좋은 문서를 생성하는 방식을 의미한다. 이러한 변화의 배경에는 빅데이터, 데이터 과학, 인공지능으로 이어지는 과학기술 정보 전달과 공유를 보다 효율적으로 하기 위한 필요성이 크다. 또한, 인터랙티브 상호작용 기능은 다양한 문서 가독성과 커뮤니케이션 능력을 한층 강화했다. 인공지능 시대 R마크다운(R Markdown)이 10년 넘는 기간 동안 책(bookdown), 블로그(blogdown), 패키지 매뉴얼(pkgdown), PPT(xaringan), 대쉬보드(flexdashboard) 등 재현가능하고 추적가능한 과학기술 문서저작에 가능성을 보였고 이를 차세대 R마크다운이라는 별명을 갖고 있는 쿼토(Quarto)로 기존에 축적한 지식과 경험을 좋은 점은 계승하고 인공지능시대 새로운 패러다임을 적극 도입하여 새로운 과학기술 문서저작도구로 재탄생했다.\n\n\n\n쿼토 개요\n\n\n\n9.2.1 위지윅 vs 위지윔\n신속하고 빠르게 누구나 짧은 학습을 통해서 문서를 저작하고 출판할 수 있는 방식은 아래한글 혹은 MS워드 워드프로세서를 사용하는데 이는 위지위그(WYSIWYG: What You See Is What You Get, “보는 대로 얻는다”)에 기초한 것으로 문서 편집 과정에서 화면에 포맷된 낱말, 문장이 출력물과 동일하게 나오는 방식을 말한다. 위지윅의 대척점에 있는 것이 위지윔(WYSIWYM, What You See Is What You Mean)으로 대표적인 것인 LaTeX 으로 구조화된 방식으로 문서를 작성하면 컴파일을 통해서 최종 문서가 미려한 출판가능한 PDF, PS, DVI 등 확장자를 갖는 출판결과물을 얻을 수 있다.\n\n\n\n\n\n\n블로그 저작 소프트웨어\n개인용 컴퓨터가 보급되면서 아래한글과 같은 워드 프로세서를 사용해서 저작을 하는 것이 일반화되었지만 곧이어 인터넷이 보급되면서 웹에 문서를 저작하는 것이 이제는 더욱 중요하게 되었다. 전문 개발자가 아닌 일반인이 HTML, CSS, JavaScript를 학습하여 웹에 문서를 제작하고 출판하는 것은 난이도가 있다보니 워드프레스와 티스토리 같은 위지위그 패러다임을 채택한 저작도구가 사용되고 있으나 상대적으로 HTML, CSS, JavaScript을 조합한 방식과 비교하여 고급스러운 면과 함께 정교함에 있어 아쉬움이 있는 것도 사실이다.\n\n\n워드프레스와 티스토리\n\n\n\n\n\n\n\nHTML + CSS + 자바스크립트"
  },
  {
    "objectID": "writing.html#재현가능-글쓰기",
    "href": "writing.html#재현가능-글쓰기",
    "title": "9  디지털 글쓰기",
    "section": "9.3 재현가능 글쓰기",
    "text": "9.3 재현가능 글쓰기\n과학의 근본적인 원칙 중 하나는 연구의 결과가 독립적으로 재현가능해야 한다는 것이다. 이 원칙은 연구 타당성을 확인하고, 그 결과가 일반화 가능한지 검증하는 데 필수적이다. 그러나 2010년 전후, 다양한 학문 분야에서 재현할 수 없는 연구 결과가 다수 발표됨에 따라 과학 커뮤니티 내에서 큰 우려가 발생하였고, 이러한 현상을 재현성 위기(Reproducibity Crisis)라고 부르며, 과학연구 신뢰성을 크게 훼손시켰다.\n이 위기에 대응하여, 전 세계 연구자들과 전문가들은 재현가능한 연구 저작을 촉진하고 지원하기 위한 다양한 방안을 모색하기 시작했다. 연구방법론 표준화, 데이터 공유, 연구 소프트웨어 투명성 강화 등 다양한 활동이 들불처럼 일어났고, 기술 커뮤니티 형성과 더불어 다양한 도구와 플랫폼 개발을 통해 재현성 문제를 해결하고자 하는 움직임이 확산되고 있다.\n데이터 과학에서 재현성은 핵심적인 요소로 간주된다. 연구 결과의 신뢰성과 타당성을 검증하는 데 있어, 다른 연구자나 전문가들이 동일한 결과를 도출할 수 있도록 연구 과정을 투명하게 공유하는 것은 필수적이다. 이러한 맥락에서 R 팩키지는 재현가능한 데이터 분석 프로젝트를 지원하는 데 중요한 역할을 한다.\n\n\n\n그림 9.1: 재현가능한 과학기술 문서 제작과정\n\n\n특히, R 팩키지를 활용한 연구 개요서(research compendia)는 재현성을 강화하는 훌륭한 도구로 간주된다. 연구 개요서는 연구의 모든 요소(코드, 데이터, 출력 결과물, 환경 등)을 포괄적으로 담고 있어, 연구의 전체 과정을 투명하게 추적하고 검증할 수 있다. 한 사례로 그림 9.1 에 코드부터 단계별로 재현가능한 과학기술 문서 제작과정을 보여주고 있다."
  },
  {
    "objectID": "writing.html#디지털-글쓰기",
    "href": "writing.html#디지털-글쓰기",
    "title": "9  디지털 글쓰기",
    "section": "9.4 디지털 글쓰기",
    "text": "9.4 디지털 글쓰기\n글쓰기는 인류의 역사와 함께한 중요한 소통 도구로서, 그 방식과 형태는 시대별로 지속적으로 변화해왔다. 최근의 글쓰기 환경은 그 전보다 훨씬 복잡하고 다양한 요소를 요구한다. 과거에는 원고지에 텍스트를 작성하는 것만으로도 충분했다. 한글이나 영어로 이루어진 문장들은 감정을 전달하거나 사실을 나열하며, 이를 통해 독자와의 소통을 이루었다. 그러나 현대의 글쓰기 환경에서는 단순한 텍스트 정보 전달만으로는 부족하다. 이미지, 그래픽, 그리고 인터랙티브한 요소들이 텍스트와 함께 통합되어야 하며, 이를 통해 독자의 관심을 끌고 정보의 흡수를 증진시킨다.\n가독성 또한 중요한 고려사항이다. 디자인적인 측면에서 효과적인 글꼴 선택은 텍스트의 내용을 더욱 돋보이게 하며, 독자의 읽기 경험을 향상시킨다. 현대의 글쓰기는 단순한 정보 전달을 넘어서, 그 과정과 결과의 재현성에도 중점을 둔다. 특히 과학연구나 기술문서에서 두드러진다. 자동화 도구와 버전 관리 시스템의 도입을 통해 재현성을 지원하고, 글쓰기 효율성과 투명성을 동시에 높이고 있다.\n최근의 눈에 띄는 추세 중 하나는 인공지능 발전과 그에 따른 기계 저작물의 폭증을 들 수 있다. 기계가 작성한 텍스트를 포함한 콘텐츠가 인간 저자와 비슷하거나 오히려 생산 속도나 경제적인 면에서 확실한 우위를 보이면서 이에 대한 연구와 기술적 시도가 활발히 이루어지고 있다.\n\n\n\n현대의 글쓰기: 기술적 도전과 진화의 중심"
  },
  {
    "objectID": "writing.html#latex-philosophy",
    "href": "writing.html#latex-philosophy",
    "title": "9  디지털 글쓰기",
    "section": "9.5 LaTeX 철학",
    "text": "9.5 LaTeX 철학\nLaTeX은 한마디로 정의하게 되면 “논리적인 디자인”이라고 볼 수 있다. 저작물이 만들어지는 과정은 저작자가 원고를 손으로 쓰거나 타자기로 쳐서 출판사에 넘겨주면, 출판사의 편집디자이너는 원고를 보고 세부적인 출력형식을 결정하여 인쇄소에 넘긴다. 인쇄소는 이를 토대로 과거 식자공이 식자판을 만들었다면 현재는 컴퓨터가 파일을 만든다. LaTeX 과 TeX 이 하는 업무가 다소 차이가 난다. (김영록, 2017)\n\nLaTeX 은 편집디자이너에 해당되는 업무를 수행\nTeX 은 식자공에 해당되는 업무를 수행\n\n\n\n\n문서의 논리적 구조와 디자인\n\n\n컴퓨터를 활용하여 전자조판을 넘긴 이유는 문서를 좀 더 읽기 쉽게 만들어 독자에게 저작자의 생각을 잘 이해시키는 것이다. 이러한 목적을 달성하기 위해서는 문서의 디자인이 그 문서의 논리적 구조를 잘 반영시켜야 하고, 반대로 문서의 논리적 구조를 잘 반영시키기 위해서는 문서 디자이너가 문서의 논리적 구조를 잘 이해해야만 된다. LaTeX의 명령어는 기본적으로 문서의 논리적 구조를 기술하는 것이다. 이렇게 기술된 명령어를 TeX으로 전달하여 조판하게 되어 원하는 최종 결과물을 얻게 된다.\nLaTeX에서 채택하는 논리적 디자인의 가장 큰 장점은 글을 더 잘 쓰게 된다는 점에 있다. LaTeX 으로 글을 작성하게 되면 점점 LaTeX이 채택하고 있는 논리적 디자인에 맞추게 되고 이를 통해서 글쓰기 실력이 향상된다.\n아마도 LaTeX의 가장 큰 장점은 자동화에 있다. 시각적 디자인(Wysiwig)을 채택하여 작성한 문서를 다른 형식으로 변환하거나 문서의 수식의 일련번호를 로마자에서 아라비아 숫자로 모두 변경시키거나 표나 그래프 번호를 일괄번경하는 등 이러한 사례는 자주 발견된다. 특히, 국내외 저널에 제출할 논문을 LaTeX 으로 작성한 경우 템플릿만 바꾸면 쉽게 고품질 논문을 만들 수 있는데 워드를 이용하여 작성할 경우 수작업을 하게 되어 비생산적인 시간낭비도 크고 미려한 문서를 얻을 수도 없다.\n따라서, LaTeX 으로 글을 쓰게 되면 글쓰기 본질에 집중할 수 있어 저작자의 생각과 의견을 좀더 진솔하게 가감없이 독자에게 전달시킬 수 있게 된다."
  },
  {
    "objectID": "writing.html#wysiwyg",
    "href": "writing.html#wysiwyg",
    "title": "9  디지털 글쓰기",
    "section": "9.6 시각적 디자인",
    "text": "9.6 시각적 디자인\n문서를 논리적으로 디자인하는 반대 개념으로 있는 것이 위즈윅(WSYIWIG, What You See Is What You Get) 으로 대표적인 것이 아래한글, MS 워드와 같은 워드 프로세서다. 시각적 디자인을 하게 되면 논리적이지 못한 애매한 조판을 하기 쉽다. 또한, PDF 파일로도 출력을 할 때 미세하나마 출력물에 일관성이 실종되기도 한다.\n\n\n\n\n김영록. (2017). 교육 현장에서의 텍의 활용. TeX: 조판, 그 이상의 가능성."
  },
  {
    "objectID": "unicode.html#인코딩-문제",
    "href": "unicode.html#인코딩-문제",
    "title": "\n10  유니코드와 UTF-8\n",
    "section": "\n10.1 인코딩 문제",
    "text": "10.1 인코딩 문제\n문자 인코딩은 컴퓨터가 텍스트를 바이트로 변환하거나 바이트를 텍스트로 변환하는 방법이다. 인코딩 과정에서는 다양한 문제가 발생할 수 있고, 그 중 세 가지 문제가 많이 알려져있다. 첫번째는 ’두부(Tofu)’라 불리는 상황으로, 컴퓨터가 어떤 문자를 표현해야 할지 알지만, 화면에 어떻게 출력해야 할지 모르기 때문에 빈 사각형 상자로 표시된다. 두번째는 ’문자깨짐(Mojibake, 文字化け)’이다. 특히 일본어에서 자주 발생하며, 한 인코딩 방식으로 작성된 텍스트가 다른 인코딩 방식으로 해석될 때 문자가 깨지는 현상을 의미한다. 세번째는 ’의문부호(Question Marks)’로, 특정 문자가 다른 문자로 변환될 때 발생된다. 문자집합과 인코딩 궁합이 맞지 않을 때 발생하며, 데이터 손실과 오류도 야기된다.\n\n\n세가지 인코딩 문제"
  },
  {
    "objectID": "unicode.html#문자-집합",
    "href": "unicode.html#문자-집합",
    "title": "\n10  유니코드와 UTF-8\n",
    "section": "\n10.2 문자 집합",
    "text": "10.2 문자 집합\n\n10.2.1 아스키 코드\n디지털 글쓰기는 내용과 상관없이 결국 텍스트로 표현되고, 텍스트는 단지 문자다. 하지만, 컴퓨터가 문자 하나를 어떻게 표현할까?\n1960년대 미국식 영문자를 컴퓨터로 표현하는 해결책은 간단했다 - 알파벳 26개(대문자, 소문자), 숫자 10, 구두점 몇개, 그리고 전신을 보내던 시절에 제어를 위해 사용된 몇개 특수 문자(“새줄로 이동”, “본문 시작”, “개행”, “경고음”, 등). 모두 합쳐도 128개보다 적어서, 아스키(ASCII) 위원회가 문자마다 7비트( \\(2^7\\) = 128)를 사용하는 인코딩으로 표준화했다. 1\n\n\n\n\n\n그림 10.1: 제어문자와 출력가능한 아스키 문자표 알파벳 예시\n\n그림 10.1 에 아스키 문자표에 제어문자 10개와 출력가능 아스키 문자표 중 영문 대문자 A-I까지 10개를 뽑아 사례로 보여주고 있다. 즉, 문자표는 어떤 문자가 어떤 숫자에 해당하는지를 정의하고 있다.\n\n10.2.2 확장 아스키\n아스키(ASCII) 방식으로 숫자 2, 문자 q, 혹은 곡절 악센트 ^ 를 표현하는데 충분하다. 하지만, 투르크어족 추바시어 ĕ, 그리스 문자 β, 러시아 키릴문자 Я 는 어떻게 저장하고 표현해야 할까? 7-비트를 사용하면 0 에서 127까지 숫자를 부여할 수 있지만, 8-비트(즉, 1 바이트)를 사용하게 되면 255까지 표현할 수 있다. 그렇다면, ASCII 표준을 확장해서 추가되는 128개 숫자에 대해 추가로 문자를 표현할 수 있게 된다.\n\n아스키: 0…127\n확장된 아스키: 128…255\n\n불행하게도, 영어문자를 사용하지 않는 세계 곳곳에서 많은 사람들이 시도를 했지만, 방식도 다르고, 호환이 되지 않는 방식으로 작업이 되어, 결과는 엉망진창이 되었다. 예를 들어, 실제 텍스트가 불가리아어로 인코딩되었는데 스페인어 규칙을 사용해서 인코딩한 것으로 프로그램이 간주하고 처리될 경우 결과는 무의미한 횡설수설 값이 출력된다. 이와는 별도로 한중일(CJK) 동아시아 국가들을 비롯한 많은 국가들이 256개 이상 기호를 사용한다. 왜냐하면 8-비트로 특히 동아시아 국가 문자를 표현하는데 부족하기 때문이다.\n\n10.2.3 한글 완성형과 조합형\n1980년대부터 컴퓨터를 사용하신 분이면 완성형과 조합형의 표준화 전쟁을 지켜봤을 것이고, 그 이면에는 한글 워드프로세서에 대한 주도권 쟁탈전이 있었던 것을 기억할 것이다. 결국 완성형과 조합형을 모두 포용하는 것으로 마무리 되었지만, 여기서 끝난게 끝난 것이 아니다. 유닉스 계열에서 KSC5601을 표준으로 받아들인 EUC-KR과 90년대와 2000년대를 호령한 마이크로소프트 CP949 가 있었다. 결국 대한민국 정부에서 주도한 표준화 전쟁은 유닉스/리눅스, 마이크로소프트 모두를 녹여내는 것으로 마무리 되었고, 웹과 모바일 시대는 유니코드로 넘어가서 KSC5601이 유니코드의 원소로 들어가는 것으로 마무리 되었다.\n이제 신경쓸 것은 인코딩 … utf-8 만 신경쓰면 된다. 그리고 남은 디지털 레거시 유산을 잘 처리하면 된다.\n\n\n\n\n\n\n유닉스/리눅스(EUC-KR), 윈도우(CP949)\n\n\n\nEUC-KR, CP949 모두 2바이트 한글을 표현하는 방식으로 동일점이 있지만, EUC-KR 방식은 KSC5601-87 완성형을 초기 사용하였으나, KSC5601-92 조합형도 사용할 수 있도록 확장되었다. CP949는 확장 완성형으로도 불리며 EUC-KR에서 표현할 수 없는 한글글자 8,822자를 추가한 것으로 마이크로소프트 코드페이지(Code Page) 949를 사용하면서 일반화되었다.\n\n\n\n10.2.4 유니코드\n1990년대 나타나기 시작한 해결책을 유니코드(Unicode) 라고 부른다. 예를 들어, 영어 A 대문자는 1 바이트, 한글 가는 3 바이트다. 유니코드는 정수값을 서로 다른 수만개 문자와 기호를 표현하는데 정의한다. ’A’는 U+0041, ’가’는 U+AC00과 같이 고유한 코드 포인트를 가진다. 하지만, 파일에 혹은 메모리에 문자열로 정수값을 저장하는 방식을 정의하지는 않는다.\n각 문자마다 8-비트를 사용하던 방식에서 32-비트 정수를 사용하는 방식으로 전환하면 되지만, 영어, 에스토니아어, 브라질 포르투칼어 같은 알파벳 언어권에는 상당한 공간 낭비가 발생된다. 접근 속도가 중요한 경우 메모리에 문자당 32 비트를 종종 사용한다. 하지만, 파일에 데이터를 저장하거나 인터넷을 통해 전송하는 경우 대부분의 프로그램과 프로그래머는 이와는 다른 방식을 사용한다.\n다른 방식은 (거의) 항상 UTF-8 으로 불리는 인코딩으로, 문자 마다 가변 바이트를 사용한다. 하위 호환성을 위해, 첫 128개 문자(즉, 구 아스키 문자집합)는 바이트 1개에 저장된다. 다음 1920개 문자는 바이트 2개를 사용해서 저장된다. 다음 61,000은 바이트 3개를 사용해서 저장해 나간다.\n궁금하면, 동작 방식이 다음 표에 나타나 있다. “전통적” 문자열은 문자마다 1 바이트를 사용한다. 반대로, “유니코드” 문자열은 문자마다 충분한 메모리를 사용해서 어떤 텍스트 유형이든 저장한다. R, 파이썬 3.x 에서 모든 문자열은 유니코드다. 엄청난 바이트를 읽어오거나 저장하여 내보내려고 할때, 인코딩을 지정하는 것은 엄청난 고통이다.\n유니코드 문자열은 여는 인용부호 앞에 소문자 U를 붙여 표시한다. 유니코드 문자열을 바이트 문자열로 전환하려면, 인코딩을 명세해야만 된다. 항상 UTF-8을 사용해야만 되고, 그밖의 인코딩을 사용하는 경우 매우, 매우 특별히 좋은 사유가 있어야만 된다. 특별한 인코딩을 사용하는 경우 두번 생각해 보라.\n\n\n아스키에서 유니코드로 진화과정\n\n컴퓨터가 처음 등장할 때 미국 영어권 중심 아스키가 아니고 4바이트 전세계 모든 글자를 표현할 수 있는 유니코드가 사용되었다면 한글을 컴퓨터에 표현하기 위한 지금과 같은 번거로움은 없었을 것이다. 돌이켜보면 초기 컴퓨터가 저장용량 한계로 인해 유니코드가 표준으로 자리를 잡더라도 실용적인 이유로 인해서 한글을 컴퓨터에 표현하기 위한 다른 대안이 제시됐을 것도 분명해 보인다. 초창기 영어권을 중심으로 아스키 표준이 정립되어 현재까지 내려오고, 유니코드와 UTF-8 인코딩이 사실상 표준으로 자리잡았으며, 그 사이 유닉스/리눅스 EUC-KR, 윈도우즈 CP949가 빈틈을 한동안 매우면서 역할을 담당했다.\n\n\n\n\n\n\n\n\n\n항목\nASCII (1963)\nEUC-KR (1980s)\nCP949 (1990s)\nUnicode (1991)\n\n\n\n범위\n128개의 문자\n2,350개의 한글 문자 등\n약 11,172개의 완성형 한글 문자 등\n143,859개의 문자 (버전 13.0 기준)\n\n\n비트 수\n7비트\n8~16비트\n8~16비트\n다양한 인코딩 방식 (UTF-8, UTF-16, UTF-32 등)\n\n\n표준\nANSI, ISO/IEC 646\nKS X 2901\n마이크로소프트\nISO/IEC 10646\n\n\n플랫폼\n다양한 시스템\nUNIX 계열, 일부 Windows\nWindows 계열\n다양한 플랫폼\n\n\n문자 집합\n영문 알파벳, 숫자, 특수 문자\n한글, 영문 알파벳, 숫자, 특수 문자\n한글, 한자, 영문 알파벳, 숫자, 특수 문자\n전 세계 언어, 특수 문자, 이모티콘 등\n\n\n확장성\n확장 불가능\n한정적\n더 많은 문자 지원\n높은 확장성\n\n\n국제성\n영어 중심\n한국어 중심\n한국어 중심\n다국어 지원\n\n\n유니코드 호환\n호환 가능 (U+0000 ~ U+007F)\n호환 불가, 변환 필요\n유니코드와 상호 변환 가능\n자체가 표준"
  },
  {
    "objectID": "unicode.html#utf-8",
    "href": "unicode.html#utf-8",
    "title": "\n10  유니코드와 UTF-8\n",
    "section": "\n10.3 UTF-8",
    "text": "10.3 UTF-8\nUTF-8(Universal Coded Character Set + Transformation Format – 8-bit의 약자)은 유니코드 중에서 가장 널리 쓰이는 인코딩으로, 유니코드를 위한 가변 길이 문자 인코딩 방식 중 하나로 켄 톰프슨과 롭 파이크가 제작했다.\nUTF-8 인코딩의 가장 큰 장점은 아스키(ASCII), 라틴-1(ISO-8859-1)과 호환되어, 문서를 처리하는 경우 아스키, 라틴-1 문서를 변환 없이 그대로 처리할 수 있고 영어를 비롯한 라틴계열 문서로 저장할 때 용량이 매우 작다. 이러한 이유로 많은 오픈소스 소프트웨어와 데이터를 생산하는 미국을 비롯한 유럽언어권에서 UTF-8이 많이 사용되고 있지만, 한글은 한 글자당 3바이트 용량을 차지한다.\n\n10.3.1 웹 표준 인코딩\n스마트폰의 대중화에 따라 더이상 윈도우 운영체제에서 사용되는 문자체계가 더이상 표준이 되지 못하고 여러 문제점을 야기함에 따라 유니코드 + UTF-8 체제가 대세로 자리잡고 있는 것이 확연히 나타나고 있다.\n2010년 구글에서 발표한 자료에 의하면 2010년 UTF-8 인코딩이 웹에서 주류로 부상하기 시작한 것이 확인되었다. (Davis, 2010) 웹기반 플롯 디지털 도구를 활용하여 그래프(WebPlotDigitizer)에서 데이터를 추출하여 시각화면 유사한 결과를 시각적으로 표현할 수 있다. 2010년 이후 웹에서 가장 점유율이 높은 인코딩 방식은 UTF-8으로 W3Tech 웹기술조사(Web Technology Surveys)를 통해 확인을 할 수 있다. 여기서 주목할 점은, 프랑스어, 독일어, 스페인어와 같은 서유럽 언어의 문자와 기호 표현하는 ISO-8859-1 인코딩, 종종 “Latin-1”으로 불리는 8비트 문자 인코딩이 현저히 줄고 있다는 점이다.\n\n\n2010 ~ 2012 웹에서 UTF-8 성장세"
  },
  {
    "objectID": "unicode.html#텍스트-표현",
    "href": "unicode.html#텍스트-표현",
    "title": "\n10  유니코드와 UTF-8\n",
    "section": "\n10.4 텍스트 표현",
    "text": "10.4 텍스트 표현\n1940년대, 1950년대 펀치카드 기술로 정의된 첫번째 방식이 고정폭 레코드(fixed-width records) 를 사용하는 것으로, 각 줄마다 동일한 고정길이를 갖는다. 예를 들어, 다음 일본 전통 단시 하이쿠(haiku)를 컴퓨터로 아래와 같이 레코드 3개로 배열했다. (점 문자는 “사용되지 않음”을 의미) 이런 방식은 여전히 데이터베이스에도 사용되고 있다.\n\n일본 전통 단시 하이쿠 예시\n\nA crash reduces\nyour expensive computer\nto a simple stone.\n\n\n\n\n고정길이 일본 전통 하이쿠 표현\n\n이런 표기법은 N번째 행 앞으로 뒤로 건너뛰기 쉬운데 이유는 각 행이 동일한 크기를 갖기 때문이다. 하지만, 공간을 낭비하는 약점이 있고, 행마다 얼마나 긴 최대 길이를 갖느냐에 관계없이, 궁극적으로 더 긴 길이를 갖는 행을 기준으로 처리해야만 된다.\n시간이 흐름에 따라 개발자 대부분은 다른 표현법으로 전환했다. 전환된 표현법에 따르면 텍스트는 단지 연속된 바이트(byte)에 불과하고, 이런 연속된 바이트 일부에 “현재 라인은 여기서 종료” 라는 의미가 담겨진다. 이러한 표현법으로 일본 전통 단시 하이쿠를 다시 표현하면 다음과 같다.\n\n\n변동길이 일본 전통 하이쿠 표현\n\n회색칸이 “행의 끝(end of line)”을 의미한다. 이런 표기법은 더 유연하고, 공간을 덜 낭비하지만, N번째 행 앞으로 뒤로 건너뛰는 것은 어렵게 되었다. 이유는 각각이 다른 길이를 갖기 때문이다. 물론 행 종료를 표시하는데 무엇을 사용할지 결정해야하는 문제가 남았다. 불행히도, 유닉스에서는 행의 끝으로 개행 문자(newline) 한개, \\n으로 정했지만, 윈도우에서는 행의 끝으로 복귀문자(carriage return) 다음에 개행문자, \\r\\n 으로 정했다.\n편집기 대부분에서 이런 차이를 탐지하고 처리할 수 있지만, 유닉스와 윈도우를 모두 다뤄야 되는 프로그래머에게는 여전히 성가신 일이다. 윈도우 운영체제 파일에서 데이터를 불러읽어올 경우, 파이썬에서 \\r\\n 을 \\n 으로 전환하고, 데이터를 써서 저장할 경우 반대 방식으로 전환한다. 그러나 이미지, 소리 또는 기타 이진 파일형식에서 \\r 또는 \\n에 해당하는 문자가 우연히 포함되어 있다면, 원치 않는 변환이 발생할 수 있다."
  },
  {
    "objectID": "unicode.html#localization",
    "href": "unicode.html#localization",
    "title": "\n10  유니코드와 UTF-8\n",
    "section": "\n10.5 현지화/세계화",
    "text": "10.5 현지화/세계화\n현지화(Localization)는 세계화(internationalization)의 동전의 양면과 같다. 세계화를 영어로 internationalization으로 길기 때문에 i18n으로 줄여서 현지화는 영어로 Localization으로 길기 때문에 동일한 로직으로 L10N으로 줄여 표현한다. 현지화에 해당되는 사항은 다음이 포함된다. (Oliver, 2017)\n\n문자 집합\n통화\n날씨 온도(\\(^{\\circ} C / ^{\\circ} F\\))\n길이 (킬로미터, 마일)\n날짜와 시간\n키보드 배열\n좌측에서 우축으로, 위에서 아래, 우측에서 좌측으로 텍스트 작성 방식과 문서양식\n…\n\n\n\n\n\nDavis, M. (2010). Unicode nearing 50% of the web. https://googleblog.blogspot.com/2010/01/unicode-nearing-50-of-web.html\n\n\nOliver, C. (2017). Internationalization Part I: Unicode and Character Encodings. https://slideplayer.com/slide/7684069/"
  },
  {
    "objectID": "components.html#그래프",
    "href": "components.html#그래프",
    "title": "\n11  문서 구성요소\n",
    "section": "\n11.1 그래프",
    "text": "11.1 그래프\n그래프(ggplot)에 사용되는 글꼴도 마찬가지로 showtext 패키지 웹폰트를 사용해서 다양한 한글도 사용할 수 있다. showtext 패키지는 font_add_google() 함수를 통해서 구글 한글폰트를 지정하여 이를 ggplot 에 적용시킬 수 있다.\n\nlibrary(tidyverse)\nlibrary(showtext)\nlibrary(palmerpenguins)\n\nfont_add_google(\"Nanum Pen Script\", \"nanum_pen_script\")\nfont_add_google(\"Jua\", \"Jua\")\nshowtext_auto()\n\ntheme_quarto &lt;- theme(\n  text = element_text(family = 'Jua', size = 25),\n  plot.title.position = 'plot',\n  plot.title = element_text(\n    family = 'nanum_pen_script', size = 55,\n    face = 'bold', \n    colour = thematic::okabe_ito(8)[3],\n    margin = margin(t = 2, r = 0, b = 3, l = 0, unit = \"mm\")\n  ),\n  plot.subtitle = element_text(\n    family = 'Jua', size = 25,\n    face = 'bold', \n    colour = thematic::okabe_ito(8)[5],\n    margin = margin(t = 0, r = 0, b = 0, l = 0, unit = \"mm\")\n  )\n  \n)\n\ntheme_set(theme_minimal() + theme_quarto)\n\nmass_flipper &lt;- ggplot(data = penguins,\n                       aes(x = flipper_length_mm,\n                           y = body_mass_g,\n                           color = species)) +\n  geom_point(size = 3,\n             alpha = 0.8) +\n  labs(title = \"팔머 관측소 LTER 서식 펭귄 크기\",\n       subtitle = \"Adelie, Chinstrap, Gentoo 펭귄에 대한 물갈퀴 길이와 체질량\",\n       x = \"물갈퀴 길이(Flipper length) (mm)\",\n       y = \"체질량(Body mass) (g)\")\n\nmass_flipper"
  },
  {
    "objectID": "components.html#표",
    "href": "components.html#표",
    "title": "\n11  문서 구성요소\n",
    "section": "\n11.2 표",
    "text": "11.2 표\n문서에 표를 넣게 되면 정보를 효과적으로 요약할 뿐만 아니라 가독성을 높이는 중요한 커뮤니케이션 도구 중 하나다. 마크다운(Markdown), gt 패키지, LaTeX는 자료를 표 형식으로 표현할 때 각각의 장점이 있다. 마크다운은 기본적이며 간단한 방법으로, 복잡한 설치나 추가 패키지 없이도 빠르게 내용에 충실한 기본표를 작성할 수 있다. gt 패키지는 그래프 문법을 참고하여 표문법을 충실히 준수하며 데이터에 기반한 표제작에 필요한 거의 모든 기능을 제공한다. LaTeX는 가장 전문적인 표를 만들 수 있는 도구로, 논문이나 학술 자료에 적합한 고품질의 표를 제작하는데 유용하다.\n\n\n표제작 세가지 방식\n\n\n11.2.1 마크다운 표\nmtcars 데이터프레임에서 시연목적으로 관측점 5개와 열 4개를 뽑아내서 kable()함수에 넣고 출력형식을 markdown으로 지정한다. markdown외에도 html, pandoc, latex, rst등으로 출력형식을 지정할 수 있다.\n\n\n\nlibrary(tidyverse)\nlibrary(knitr)\n\nmtcars %&gt;% \n  sample_n(5) %&gt;% \n  select(mpg, cyl, disp) %&gt;% \n  kable(\"markdown\")\n\n\n\n\n\n\n\n\n\nmpg\ncyl\ndisp\n\n\n\nHornet Sportabout\n18.7\n8\n360.0\n\n\nMerc 230\n22.8\n4\n140.8\n\n\nMazda RX4\n21.0\n6\n160.0\n\n\nDuster 360\n14.3\n8\n360.0\n\n\nFiat 128\n32.4\n4\n78.7\n\n\n\n\n\n\n\n\n11.2.2 gt\n\n그래프 문법(grammar of graphics)처럼 표 문법(grammar of table) gt 팩키지가 등장했다. 표를 분해하면 다음과 같고 이를 tibble 혹은 데이터프레임을 입력받아 GT 객체로 변환시킨 후에 GT 표를 HTML로 출력하는 작업흐름을 갖는다.\n\n\n표 해부도\n\ngt 팩키지에 내장된 exibble 데이터셋은 \\(8 \\times 9\\) 구조를 갖는 단순한 데이터셋이지만 표와 관련된 다양한 형태를 개발에 사용할 주요한 정보를 담고 있다. 1\n\n\n\nlibrary(gt)\n\nmtcars %&gt;% \n  sample_n(5) %&gt;% \n  select(mpg, cyl, disp) %&gt;% \n  gt() |&gt; \n  tab_header(\n    title = md(\"**mtcars** 데이터셋 표\"),\n    subtitle = md(\"디지털 글쓰기 `gt` 패키지\")\n  ) %&gt;%\n  tab_source_note(\"표제작: 한국 R 사용자회 오픈소스 소프트웨어 개발자\")\n\n\n\n\n\n\n\n\n\n\n\n\nmtcars 데이터셋 표\n    \n\n디지털 글쓰기 gt 패키지\n    \n\nmpg\n      cyl\n      disp\n    \n\n\n\n21.4\n6\n258.0\n\n\n30.4\n4\n95.1\n\n\n17.3\n8\n275.8\n\n\n19.7\n6\n145.0\n\n\n33.9\n4\n71.1\n\n\n\n표제작: 한국 R 사용자회 오픈소스 소프트웨어 개발자\n    \n\n\n\n\n\n\n\n11.2.3 LaTeX 표\nLaTeX은 수식 뿐만 아니라 복잡하고 미려한 표도 코드를 통해 제작할 수 있다. 쿼토에서 LaTeX 표를 제작하기 위해서는 먼저 표제작을 위한 LaTeX 표코드를 준비하고, GitHub에서 팬독-필터 tarleb/parse-latex를 다음 명령어로 설치한다.\n$ quarto install extension tarleb/parse-latex\n쿼토 확장팩이 설치되면 YAML에 다음과 같이 parse-latex을 등록하여 사용한다.\n---\nfilters:\n  - parse-latex\n---\n\n\n\n\\begin{table}[h]\n\\centering\n\\begin{tabular}{|l|c|c|c|}\n\\hline\nCar Model & mpg & cyl & disp \\\\\n\\hline\nLotus Europa & 30.4 & 4 & 95.1 \\\\\nMerc 230 & 22.8 & 4 & 140.8 \\\\\nFiat 128 & 32.4 & 4 & 78.7 \\\\\nPontiac Firebird & 19.2 & 8 & 400.0 \\\\\nMerc 450SL & 17.3 & 8 & 275.8 \\\\\n\\hline\n\\end{tabular}\n\\caption{mtcars 데이터셋}\n\\end{table}\n\n\n\n\n\nmtcars 데이터셋\n\nCar Model\nmpg\ncyl\ndisp\n\n\n\nLotus Europa\n30.4\n4\n95.1\n\n\nMerc 230\n22.8\n4\n140.8\n\n\nFiat 128\n32.4\n4\n78.7\n\n\nPontiac Firebird\n19.2\n8\n400.0\n\n\nMerc 450SL\n17.3\n8\n275.8\n\n\n\n\n\n\n11.2.4 표 제작 사례\n펭귄 데이터를 기반으로 gt 패키지를 사용하여 표 제목, 칼럼명, 셀값에 다양한 글꼴, 크기, 색상, 굵기를 적용한 사례가 표 11.1 에 코드로 나와 있다. 미국 웨스 앤더슨 영화 색상(Darjeeling1)을 표에 적용하고, 글꼴로 웹글꼴 구글 글꼴을 활용하여 gt 패키지로 다양한 글꼴을 적용하고, fmt_integer() 함수를 사용해서 숫자 가독성을 높이기 위해 천단위 구분자를 넣고 부가적인 디자인도 표에 적용한다.\n\nlibrary(gt)\n\nbasic_theme &lt;- function(data, ...){\n  data %&gt;% \n    tab_options(\n      column_labels.background.color = \"#F98400\",\n      table.font.size = px(12),\n      column_labels.font.size = px(20),\n      row.striping.background_color = \"#F2AD00\",\n      heading.align = \"left\",\n      heading.title.font.size = px(30)\n  )\n}\n\npalmerpenguins::penguins %&gt;% \n  select( 펭귄종=species, 섬=island, bill_length_mm, body_mass_g) %&gt;% \n  slice_sample(n = 10) %&gt;% \n  gt() %&gt;% \n    tab_header(title = md(\"팔머 펭귄 표본 **10 마리** 측정 정보\")) %&gt;% \n    tab_source_note(source_note = \"데이터: Kristen Gorman 박사와 남국 팔머 관측소(Palmer Station, Antarctica LTER)에서 수집\") %&gt;% \n    cols_label(bill_length_mm = \"부리 길이 (mm)\",\n               body_mass_g    = \"체질량 (g)\") %&gt;% \n  tab_style(\n    style = cell_text(\n      font = c(\n        google_font(name = \"Nanum Pen Script\"),\n        default_fonts()\n      ),\n      size = \"xx-large\",\n      color = \"gray35\",\n      weight = \"bolder\"\n    ),\n    locations = cells_body(columns = bill_length_mm)\n  ) %&gt;% \n  # 체질량 칼럼  ---------------\n  tab_style(\n    style = cell_text(\n      font = c(\n        google_font(name = \"Black Han Sans\"),\n        default_fonts()\n      ),\n      size = \"large\",\n      color = \"#00A08A\",\n      weight = \"bolder\"\n    ),\n    locations = cells_body(columns = body_mass_g)\n  ) %&gt;% \n  fmt_integer(body_mass_g) |&gt; \n  # 표 Header 와 첫번째 칼럼  ---------------\n  tab_style(\n    style = cell_text(\n      font = google_font(\"Do Hyeon\"), \n      size = \"large\"\n    ),\n    locations = list(\n      cells_column_labels(everything()), \n      cells_body(columns = 1)\n    )\n  ) %&gt;%   \n  # 표 제목 ---------------\n  tab_style(\n    style = cell_text(\n      font = google_font(\"Dokdo\"), \n      align = \"left\", \n      size = \"xx-large\",\n      color = \"#FF0000\"\n    ),\n    locations = cells_title(\"title\")\n  ) %&gt;%   \n  basic_theme() \n\n\n\n\n\n표 11.1:  글꼴, 색상, 서식을 반영한 표 제작 사례 \n  \n\n팔머 펭귄 표본 10 마리 측정 정보\n    \n\n펭귄종\n      섬\n      부리 길이 (mm)\n      체질량 (g)\n    \n\n\n\nGentoo\nBiscoe\n50.0\n5,550\n\n\nAdelie\nTorgersen\n39.6\n3,550\n\n\nAdelie\nTorgersen\n36.6\n3,700\n\n\nGentoo\nBiscoe\n48.5\n4,850\n\n\nChinstrap\nDream\n45.9\n3,575\n\n\nGentoo\nBiscoe\n42.9\n5,000\n\n\nAdelie\nTorgersen\n40.6\n4,000\n\n\nAdelie\nTorgersen\n34.1\n3,475\n\n\nAdelie\nBiscoe\n35.5\n3,350\n\n\nAdelie\nBiscoe\n39.6\n3,500\n\n\n\n데이터: Kristen Gorman 박사와 남국 팔머 관측소(Palmer Station, Antarctica LTER)에서 수집"
  },
  {
    "objectID": "components.html#다이어그램",
    "href": "components.html#다이어그램",
    "title": "\n11  문서 구성요소\n",
    "section": "\n11.3 다이어그램",
    "text": "11.3 다이어그램\n\n\n\n\ngraph LR\n\n    chatGPT[\"챗GPT\"] --&gt; Contents\n\n    subgraph Contents[\"디지털 글쓰기\"]\n        direction LR\n        Writing[\"글감\"] --&gt; Table[\"표\"]\n        Writing --&gt; Graph[\"그래프\"]\n        Writing --&gt; Code[\"파이썬/R/SQL&lt;br&gt;코드\"]\n        Writing --&gt; Figure[\"그림\"]\n        Writing --&gt; Diagram[\"도형\"]        \n    end\n\n    chatGPT --&gt; Format\n    Contents --&gt; Format\n\n    subgraph Format[\"구조와 외양\"]\n        direction LR\n        Theme[\"구조와 외양\"] --&gt; Title[\"문서 구조\"]\n        Theme               --&gt; Formatting[\"문서 서식\"]\n        Theme               --&gt; Layout[\"문서 레이아웃\"]\n        Theme               --&gt; reference[\"문서 참조\"]\n    end\n\n    chatGPT --&gt; Deployment\n    Format --&gt; Deployment\n\n    subgraph Deployment[\"배포와 공유\"]\n        direction LR\n        Deploy --&gt; Reader[\"독자(사람)\"]\n        Deploy --&gt; Author[\"독자(저작자)\"]\n        Deploy --&gt; Machine[\"독자(기계)\"]\n    end\n\n    style chatGPT fill:#f5f5f5,stroke:#333,stroke-width:3px\n    style Contents fill:#059fff,stroke:#333,stroke-width:1px\n    style Format fill:#fc0303,stroke:#333,stroke-width:1px\n    style Deployment fill:#03fc30,stroke:#333,stroke-width:1px"
  },
  {
    "objectID": "components.html#보고서",
    "href": "components.html#보고서",
    "title": "\n11  문서 구성요소\n",
    "section": "\n11.4 보고서",
    "text": "11.4 보고서\n데이터 사이언스 한글 출판 문서 제작을 위해서 다음 글꼴을 선택한다. 제목으로 산스 세리프 폰트로 구글 폰트에서 “노토 산스 세리프”를 선정하고, 본문은 눈누 웹사이트에서 “마루부리”를 선정하고 코딩 글꼴 폰트로 눈누에서 D2Coding 폰트를 지정한다.\n\n산스 세리프(제목): Noto Sans Serif\n세리프(본문): 마루부리\n등간격(코딩): D2Coding\n\n\nlibrary(tidyverse)\n\nmass_flipper &lt;- ggplot(data = penguins,\n                       aes(x = flipper_length_mm,\n                           y = body_mass_g)) +\n  geom_point(size = 3,\n             alpha = 0.8) +\n  theme_minimal() +\n  labs(title = \"팔머 관측소 LTER 서식 펭귄 크기\",\n       subtitle = \"Adelie, Chinstrap, Gentoo 펭귄에 대한 물갈퀴 길이와 체질량\",\n       x = \"물갈퀴 길이(Flipper length) (mm)\",\n       y = \"체질량(Body mass) (g)\") +\n  theme_minimal()\n\n\n11.4.1 css 파일\n출판문서 제작에 사용된 글꼴 관련 사항을 css/quarto-fonts.css 파일에 지정해둔다.\n\n/* 글꼴 */\n@import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR');\n\n@import url('https://fonts.googleapis.com/css2?family=Noto+Serif+KR');\n\n@import url('https://fonts.googleapis.com/css2?family=Nanum+Myeongjo&display=swap');\n\n@font-face {\n    font-family: 'MaruBuri-Regular';\n    src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_20-10-21@1.0/MaruBuri-Regular.woff') format('woff');\n    font-weight: normal;\n    font-style: normal;\n}\n\n@font-face {\n    font-family: 'D2Coding';\n    src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_three@1.0/D2Coding.woff') format('woff');\n    font-weight: normal;\n    font-style: normal;\n}\n\n/* HTML */\n\nh1, h2, h3, h4, h5, h6 {\n  font-family: \"Noto Sans KR\", sans-serif;\n}\n\nbody {\n  font-family: \"Nanum Myeongjo\", \"MaruBuri-Regular\", \"Noto Serif KR\", serif;\n  font-size: 15px;\n}\n\ntt, code, pre {\n  font-family: \"D2Coding\", Consolas, monospace;\n  font-size: 15px;\n}"
  },
  {
    "objectID": "components.html#수식",
    "href": "components.html#수식",
    "title": "\n11  문서 구성요소\n",
    "section": "\n11.5 수식",
    "text": "11.5 수식\n\n11.5.1 LaTeX를 이용한 수학적 표현\n수학은 공학, 물리학, 컴퓨터 과학, 경제학 등 다양한 분야에서 중심 역할을 하는 학문으로 정확하고 명료한 수학적 표기는 매우 중요하다. LaTeX은 수학적 표현을 깔끔하고 정확하게 표현할 수 있는 도구 중 하나로 LaTeX를 이용해 다양한 수학적 표현법을 살펴보자.\nLaTeX은 기본적인 사칙연산에서부터 지수, 삼각함수, 적분, 행렬, 그리스 문자, 무한대 등 광범위한 수학적 표현이 가능하여 전문가 느낌의 문서나 논문, 프레젠테이션에 즉시 적용할 수 있는 고급스럽고 미련한 수식표현이 가능하다.\n기본적인 덧셈과 뺄셈은 \\begin{equation} a + b = c \\end{equation}처럼 표현할 수 있고, 복잡한 적분도 \\begin{equation} \\int_{0}^{\\infty} e^{-x^2} dx = \\frac{\\sqrt{\\pi}}{2} \\end{equation}와 같이 명료하게 표현할 수 있을 뿐만 아니라, 행렬이나 그리스 문자도 \\begin{pmatrix} a & b \\\\ c & d \\end{pmatrix}와 \\alpha, \\beta, \\gamma, \\Gamma, \\pi, \\Pi, \\phi, \\Phi, \\mu 등의 명령어를 통해 표현할 수 있다.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n이 외에도 LaTeX로 더 복잡한 수식표현도 얼마든지 가능하다."
  },
  {
    "objectID": "components.html#참고문헌",
    "href": "components.html#참고문헌",
    "title": "\n11  문서 구성요소\n",
    "section": "\n11.6 참고문헌",
    "text": "11.6 참고문헌\nLaTeX 문서 컴파일 과정은 몇 단계에 걸쳐 이뤄진다. 먼저 xelatex 명령을 사용하여 원본 LaTeX 코드를 컴파일하면 .aux와 .log 파일이 생성되고, biber 또는 bibtex 명령을 실행하여 참고문헌 정보를 처리하면서 .bbl 및 .blg 파일이 생성된다. 그 다음 다시 xelatex을 두 번 실행하여 참고문헌과 인용 정보를 최종적으로 처리하고 완성된 PDF 파일이 생성된다.\n\n\n\n\ngraph LR;\n    style A fill:#f9d71c,stroke:#333,stroke-width:2px;\n    style B fill:#42f5e6,stroke:#333,stroke-width:2px;\n    style C fill:#f542e9,stroke:#333,stroke-width:2px;\n    style D fill:#42f54b,stroke:#333,stroke-width:2px;\n    style E fill:#f54242,stroke:#333,stroke-width:2px;\n\n    A[LaTeX&lt;br&gt;소스코드] --&gt;|xelatex| B{.aux,&lt;br&gt; .log}\n    B --&gt;|biber &lt;br&gt; bibtex| C{.bbl,&lt;br&gt; .blg}\n    C --&gt;|xelatex| D{.aux,&lt;br&gt; .log,&lt;br&gt;.pdf}\n    D --&gt;|xelatex| E[PDF]\n\n\n\n\n\n\n\n11.6.1 .bib 파일\n.bib 파일은 BibTeX “서지 데이터베이스”로 쿼토, R마크다운, 주피터 노트북, LaTeX 문서에서 참고문헌을 관리하는 데 사용된다. .bib 파일은 다양한 참고문헌(예: 논문, 책, 인터넷 자료 등)에 대한 메타데이터를 담고 있는데 제목, 저자, 출판일 등의 정보가 담겨있다.\nLaTeX으로 작성한 .tex 소스파일을 references.bib 서지 파일과 연결시켜 컴파일하여 .pdf 파일로 작업한다. 한가지 여기서 다루지 않는 사항으로 .csl 파일이 있다. .cls는 인용 스타일 언어(Citation Style Language) 파일로 XML 형식으로 작성되며, 참고문헌 서식규칙을 정의한다. 학술지, 출판사마다 각기 다른 참고문헌 스타일을 요구하기 때문에, .csl 파일에 다양한 스타일을 표현하다. 따라서, 참고문헌 콘텐츠가 담긴 .bib 파일과 참고문헌 스타일이 담긴 .cls 두파일이 멋진 참고문헌 출력을 위해 짝꿍처럼 함께 다닌다.\n다음 LaTeX 저작 파일은 서지 데이터가 담긴 references.bib 파일에 Kim2017과 xie2020r 두 개의 참고문헌이 들어있다.\nLaTeX 문서는 biblatex 패키지를 사용하여 이 references.bib 파일을 불러오고, \\cite 명령어로 특정된 참고문헌을 인용한다. 참고문헌 목록은 \\printbibliography[title=참고문헌] 명령어 출력되는데 title 옵션으로 참고문헌목록 제목을 “References”에서 “참고문헌”으로 변경하고 LaTeX 문서에서 인용된 참고문헌을 기본설정 .csl에 맞춰 출력한다. 만약, 특정 참고문헌 스타일을 반영하고자 한다면 LaTeX 파일에 .csl 파일을 지정하면 된다.\n\n\n\n.tex 소스파일\n\\documentclass{oblivoir}\n\n% 한글 글꼴 적용 ---------------------------\n\\usepackage{fontspec}\n\\setmainfont{NanumGothic} % NanumGothic 글꼴이 설치되어야 함\n\n% 참고문헌 설정 ----------------------------\n\\usepackage[backend=biber, style=numeric]{biblatex} % bibtex을 백엔드로 설정\n\\addbibresource{references.bib}\n\n\\begin{document}\n    \n    \\section{서론}\n    텍과 관련된 교육 현장에서의 활용에 대한 연구가 있습니다~\\cite{Kim2017}. \n    또한, R markdown에 대한 다양한 정보와 사용법이 소개된 책도 있습니다~\\cite{xie2020r}.\n    \n    \\printbibliography[title=참고문헌]\n    \n\\end{document}\n\n\n\n\n\n.bib 서지 파일\n@article{Kim2017,  \n    author = {김영록},  \n    title = {교육 현장에서의 텍의 활용},  \n    journal = {TeX: 조판, 그 이상의 가능성},  \n    year = {2017}\n}\n\n@book{xie2020r,  \n    title={R markdown cookbook},  \n    author={Xie, Yihui and Dervieux, Christophe and Riederer, Emily},  \n    year={2020},  \n    publisher={CRC Press}\n}\n\n\n\n\n\n서식파일 참고문헌\n\n\n11.6.2 영문 참고문헌\n한글이 포함된 PDF 문서를 작성할 때 디버깅은 생각보다 복잡할 수 있다. 따라서 대개는 문서 기본 구조를 영어로 먼저 정확히 작동하는지 확인한 후, 한글로 전환하여 개발을 진행한다. 아래 LaTeX 문서 예시에서 전체적인 내용을 파악하기 쉽도록 lipsum 패키지로 텍스트를 채웠으며, 2단 편집과 참고문헌 관리 기능을 구현했다. biblatex 패키지와 \\addbibresource{references.bib} 명령어를 사용하여 참고문헌파일을 지정하고, 본문에서 \\cite 명령어를 통해 참고문헌을 인용했다. 마지막으로 \\printbibliography 명령어로 참고문헌 목록을 출력했다.\n\n\n\\documentclass[twocolumn]{article}\n\\usepackage{lipsum} % lipsum 패키지 불러오기\n\n% 참고문헌\n\\usepackage[backend=biber]{biblatex}\n\\addbibresource{references.bib}\n\n% 문서 전문\n\\title{Two-Sided Lipsum Example}\n\\author{John Lee}\n\\date{\\today}\n\n\n\\begin{document}    \n    \n    \\maketitle\n    \n    \\section{Introduction}\n    \n    This is a citation~\\cite{dummy2023}.\n    \\lipsum[11] % 첫 번째 로렘 입숨 문단 생성  \n    \n    \\section{Main Body}\n    \\lipsum[2-3] % 2~3 번째 로렘 입숨 문단 생성\n    \n    \\section{Conclusion}\n    This is a book citation~\\cite{ipsum2021}.\n    \\lipsum[4] % 4번째 로렘 입숨 문단 생성\n\n\\printbibliography\n    \n\\end{document}\n\n\n\n\n\n영문 참고문헌 사례\n\n\n\n\n11.6.3 국문 참고문헌\n영문으로 작성한 작업 흐름을 그대로 이용할 수 있지만, 몇 가지 수정이 필요하다. 첫째, 영문 채우기 텍스트 패키지 ipsum을 jiwonlipsum으로 변경하여 한글 텍스트로 국문 문서임을 명확히 구성한다. 둘째, LaTeX에서 한글 글꼴을 적용하지 않으면 한글 표현이 깨지거나 전혀 출력되지 않을 수 있으므로, 한글 글꼴 적용 절차를 포함한다. 참고문헌 부제목이 영문 ’Reference’에서 ’참고문헌’으로 변경하여 기본적인 한글문서 외양을 확인한다.\n\n\n\\documentclass[twocolumn]{oblivoir}\n\n% 한글 글꼴 적용 ---------------------------\n\\usepackage{fontspec}\n\\setmainfont{NanumGothic} % NanumGothic 글꼴이 설치되어야 함\n\n% 채우기 텍스트 입숨 적용 ------------------\n\\usepackage{jiwonlipsum}\n\n% 참고문헌 설정 ----------------------------\n\\usepackage[backend=biber, style=numeric]{biblatex} % biber 백엔드로 설정\n\\addbibresource{references.bib}\n\n\n% 문서의 제목, 저자, 날짜 설정\n\\title{한글 입숨 예제}\n\\author{홍길동}\n\\date{\\today}\n\n\\begin{document}    \n    \n    \\maketitle\n    \n    \\section{서론}\n    \n    참고문헌을 연구를 했습니다.~\\cite{kim2023}\n    \\jiwon[11] % 첫 번째 로렘 입숨 문단을 생성한다.\n    \n    \\section{본문}\n    또 영문 참고문헌 보고서를 연구했습니다.~\\cite{ipsum2021}\n    \\jiwon[1] % 두 번째와 세 번째 로렘 입숨 문단을 생성한다.\n    \n    \\section{결론}\n    마지막 연구했습니다.~\\cite{lee2021}\n    \\jiwon[25] % 네 번째 로렘 입숨 문단을 생성한다.\n    \n    \\printbibliography[title=참고문헌]\n    \n\\end{document}\n\n\n\n\n\n한글 참고문헌 사례"
  },
  {
    "objectID": "fonts.html#용어-설명",
    "href": "fonts.html#용어-설명",
    "title": "\n12  글꼴\n",
    "section": "\n12.1 용어 설명",
    "text": "12.1 용어 설명\n활자와 서체, 글꼴, 타이포그래프은 비슷한 개념처럼 느껴질 수 있으나 각각 다른 의미를 가지고 있다. 활자(Type)는 글자나 기호의 물리적 형태로 본래는 글자를 만드는 데 사용된 나무 또는 금속 조각을 일컫는 말이었습니다. 서체(또는 글꼴 모음, Typeface)는 글자 및 기호가 서로 비슷한 특징을 가지도록 디자인된 문자 스타일을 의미하며, ‘나눔고딕’, ‘Times New Roman’, ‘Helvetica’ 같은 이름을 가진 것이 서체다. 글꼴(Font)은 서체의 여러 변형을 총칭하는 용어로, 특정 서체에서 굵고 진한 글꼴(Bold), 기울임(italic) 등 변형이 모두 포함된다. 타이포그래피(Typography)는 활자 서체의 배열을 의미하며, 서체의 선택, 글자 크기, 줄 간격, 단어 간격, 문장 사이 간격과 맞춤 등을 조절하여 읽기 쉽고 미적으로 효과적인 텍스트 제작을 의미한다.\n전세계적으로 글꼴의 수는 무수히 많지만, 크게과 같이 크게 분류할 수 있다. 글꼴은 기본적으로 세리프(serif)와 산세리프(sans serif)의 2가지 스타일로 구분되는데 세리프는 글자의 획 끝에 작은 삐침이 있는 글꼴이며 산스(sans)는 프랑스어로 “없다”, 또는 “없이”라는 뜻이기 때문에 삐침이 없는 글꼴을 지칭한다.\n모노스페이스(monospaced) 글꼴은 코드 작성 등에서 유용하게 사용되며, 모든 글자가 같은 폭을 차지한다. Consolas나 D2 Coding은 모노스페이스 글꼴의 대표적인 예다. 디스플레이(Display)와 스크립트(Script) 글꼴은 본문보다는 제목이나 강조할 부분에서 사용되며, 디자인적인 특성이 가미되어 있다. 디스플레이 글꼴은 대체로 크고 눈에 띄는 특성을, 스크립트 글꼴은 필기체나 서명 등을 모방한 스타일을 가진다.\n수식을 표현하는데 많이 사용되는 LaTeX에서 기본글꼴로 Computer Modern, AMS Euler, STIX 같은 수식전용 글꼴이 사용되어, 수학적 표기나 공식을 명확하고 정확하게 표현할 수 있도록 설계되었다. 데이터 과학에서 그래프 문법과 표 문법을 사용하여 그래프와 표를 제작할 경우 가독성을 높이고 이목을 끌 수 있도록 색상과 더불어 적절한 글꼴 선택이 필수적으로 자리잡아가고 있다.\n일반적으로 본문에는 세리프나 산세리프 글꼴이 사용되고, 제목에는 더 화려하거나 눈에 띄는 글꼴이 사용되고 증거기반 문서 행정문서가 늘어나고 과학기술 문서에 필수적인 수식 등에도 타이포그래피 중요성이 늘어나고 있다.\n\n\n문서에 담긴 디지털 글쓰기 글꼴\n\n\n\n\n\n\n\n서체와 글꼴\n\n\n\ntypeface는 서체로 번역되고 font는 글꼴로 번역된다. 하나의 typeface에 다수 font가 포함될 수 있고, 팬그램(Pangram)은 ’모든 글자’라는 뜻으로 주어진 모든 문자를 적어도 한 번 이상 사용하여 만든 문장을 뜻한다. 팬그램은 로렘 입숨처럼 글꼴 샘플을 보여주거나 장비를 테스트하는 데 사용된다. 영어 팬그램으로 가장 유명한 ‘The quick brown fox jumps over the lazy dog’는 19세기부터 사용되어 왔다. 유사하게 한글에서는 “다람쥐 헌 쳇바퀴에 타고파”가 사용되고 있다."
  },
  {
    "objectID": "fonts.html#두가지-형태-글꼴",
    "href": "fonts.html#두가지-형태-글꼴",
    "title": "\n12  글꼴\n",
    "section": "\n12.2 두가지 형태 글꼴",
    "text": "12.2 두가지 형태 글꼴\n글꼴(Fonts)은 문자나 기호를 디지털화하여 표현하는 데 사용되는 그래픽 디자인으로 주로 로컬 설치형 글꼴과 웹폰트 두가지 형태로 사용된다.\n로컬 설치형 글꼴은 사용자의 컴퓨터나 기기에 직접 설치되어 있는 글꼴로, 윈도우(Windows)나 맥(macOS), 리눅스(Unix/Linux)에서 기본적으로 제공되는 글꼴이나 사용자가 따로 설치하여 사용하는 글꼴을 의미한다. 인터넷 연결 없이도 사용할 수 있으며, 로컬에서 동작하므로 빠른 렌더링 속도를 제공한다는 점이 큰 장점이지만, 사용자 컴퓨터나 기기에 설치되어 있지 않은 글꼴은 보이지 않을 수 있으며, 글꼴 업데이트나 관리는 수동으로 직접해야 한다는 점은 단점이다.\n반면 웹폰트는 웹페이지를 로드할 때 서버에서 함께 다운로드되어 사용자의 브라우저에 표시된다. 구글 폰트(Google Fonts), 눈누와 같은 웹폰트 서비스를 통해 제공되며, 웹페이지를 방문하는 모든 사용자에게 동일한 글꼴를 통해 보여준다는 점은 장점이다. 다양한 스타일과 가중치(weights) 글꼴을 쉽게 사용할 수 있으며, 글꼴 업데이트나 관리가 자동화되는 장점은 있으나, 초기 페이지 로딩 시간이 길어질 수 있으며, 서버 다운 혹은 인터넷 연결 문제로 웹폰트가 정상적으로 로드되지 않을 위험도 있고, 인터넷 통신 데이터 사용량이 증가되어 속도가 늦어지고 관련 네트워크 비용이 늘어날 수 있다.\n\n\n설치형 글꼴과 웹 글꼴"
  },
  {
    "objectID": "fonts.html#글꼴-설치",
    "href": "fonts.html#글꼴-설치",
    "title": "\n12  글꼴\n",
    "section": "\n12.3 글꼴 설치",
    "text": "12.3 글꼴 설치\n구글 폰트(Google Fonts), 눈누와 같은 웹사이트에서 .ttf, .otf 형식 글꼴파일을 다운로드 한 후에 C:\\Windows\\Fonts\\ 디렉토리에 복사하거나, 다운로드 받은 글꼴파일을 더블 클릭하여 설치 버튼을 눌러 자동으로 해당 디렉토리에 설치한다. 글꼴을 시스템에 설치하면 모든 사용자가 사용할 수 있도 있지만, 프로젝트 별로 fonts 디렉토리를 생성하여 이를 프로젝트에서 불러와서 특정 글꼴을 사용하는 것도 많이 사용된다. 두가지 접근 방법 모두 장단점이 있다.\n\n\nR 폰트/글꼴 설치\n\n\n12.3.1 글꼴 패키지\n시스템에 글꼴이 설치되었다고 바로 문서 텍스트, 그래프, 표, 수식 등에 사용할 수 있는 것은 아니다. 이를 등록하는 절치가 필요하다. 언어마다 차이는 있지만 대체로 유사한 작업방식이기 때문에 R 언어를 사례로 살펴보자.\nextrafont, sysfonts, showtext, 패키지는 글꼴을 다루기 위한 다양한 기능을 제공하기 위해 개발된 글꼴 패키지로 extrafont와 sysfonts 패키지는 로컬 설치형 글꼴을 다루는데 특화되어 있는 반면에 showtext는 웹글꼴 전용 패키지다. sysfonts가 더 낮은 수준에서 더 많은 제어기능을 제공하는 반면, extrafont는 높은 수준 작업에 더 초점을 맞추고 사용자 친화적인 방법으로 글꼴을 적용하는 데 특화되어 있다.\n먼저, 로컬 컴퓨터에 설치된 R 글꼴 패키지를 확인한다.\n\nlibrary(tidyverse)\n\nfont_packages &lt;- c(\"extrafont\", \"showtext\", \"sysfonts\")\n\nfonts_list &lt;- map(font_packages, packageDescription)\n\nfonts_list |&gt; \n  enframe() |&gt; \n  mutate(패키지명 = map_chr(value, \"Package\"),\n         버전 = map_chr(value, \"Version\"),\n         날짜 = map(value, \"Date\") |&gt; as.character(),\n         URL = map(value, \"URL\") |&gt; as.character()) |&gt; \n  select(-name, -value) |&gt; \n  gt::gt()\n\n\n\n\n\n패키지명\n      버전\n      날짜\n      URL\n    \n\n\nextrafont\n0.19\nNULL\nhttps://github.com/wch/extrafont\n\n\nshowtext\n0.9-6\n2023-05-03\nhttps://github.com/yixuan/showtext\n\n\nsysfonts\n0.8.8\n2022-03-13\nhttps://github.com/yixuan/sysfonts\n\n\n\n\n\n\n\n12.3.2 네이버 글꼴 설치\n네이버 나눔스퀘어 글꼴을 로컬 컴퓨터에 다운로드 받아 설치할 수 있다. 그림 12.1 에서 “모든 사용자용으로 설치(A)”하게 되면 글꼴이 C:\\Windows\\Fonts\\ 디렉토리에 설치된다. 운영체제에 설치작업이 완료되면 R에서 사용할 수 있으나, 몇 가지 추가 작업이 필요하다. 우선, fs 패키지 file_exists() 함수를 사용하여 ‘NanumSquare.ttf’ 파일이 정상적으로 설치되었는지 확인한다. 이후 font_import() 명령어를 사용하여 R에서 해당 글꼴을 사용할 수 있도록 설정한다. 이 때, path=로 글꼴 파일의 경로를 직접 지정할 수 있으며, pattern=을 사용해서 특정 패턴에 맞는 글꼴을 일괄적으로 등록할 수도 있다. 선택한 방식에 따라 글꼴을 설치하면 이후 R 프로젝트에서 네이버 나눔스퀘어 글꼴을 자유롭게 사용할 수 있다.\n\n\n그림 12.1: 윈도우 나눔스퀘어 글꼴 설치\n\n\nlibrary(extrafont)\n\nfs::file_exists(\"C:/Windows/Fonts/NanumSquare.ttf\")\n\n# font_import(paths = \"C:/Windows/Fonts/NanumSquare.ttf\")\nfont_import(pattern = \"NanumSquare.ttf\", prompt = FALSE)\n\n동일한 방식으로 마루부리 글꼴도 설치한다.\n\nfont_import(pattern = \"MaruBuri-ExtraLight.ttf\", prompt = FALSE)\nfont_import(pattern = \"MaruBuri-Regular.ttf\", prompt = FALSE)\nfont_import(pattern = \"MaruBuri-Bold.ttf\", prompt = FALSE)\nfont_import(pattern = \"MaruBuri-Light.ttf\", prompt = FALSE)\n\n동일한 방식으로 D2 Coding 글꼴도 설치하고 RStudio IDE에서 “Tools” → “Global Options…”를 클릭하면 “Options”창이 열리고, Appearance에서 Editor font:에서 설치한 코딩전용 글꼴을 선택하고 Editor theme:도 지정한다.\n\n\nD2 코딩폰트 설치\n\n글꼴 선택은 문서나 프로젝트의 특성과 목적에 따라 크게 영향을 미친다. 제목에는 삐침이 없어 깔끔한 느낌을 주기 위해 나눔스퀘어 글꼴을 설치했고, 본문에는 삐침이 있는 마루부리 글꼴을 설치하여 가독성을 높였고, 코딩 작업에 특별히 설계된 D2코딩 글꼴을 선택하여 전체적인 글쓰기 환경을 효율적이고 편안하게 준비했다."
  },
  {
    "objectID": "document_class.html#lorem-ipsum",
    "href": "document_class.html#lorem-ipsum",
    "title": "\n14  문서 클래스\n",
    "section": "\n14.1 로렘 입숨",
    "text": "14.1 로렘 입숨\n로렘 입숨(Lorem Ipsum, 줄여서 립숨, lipsum)은 출판과 그래픽 디자인 분야에서 널리 사용되는 채우기 텍스트(dummy text)로 글꼴, 타이포그래피, 레이아웃과 같은 그래픽 요소나 시각적 연출을 검토하고 싶을 때 유용하게 쓰인다. 로렘 입숨은 최종 결과물에 들어갈 실제 텍스트가 아직 준비되지 않았을 때, 기계적으로 디자인 전반적인 느낌을 파악하기 위한 임시 채움 글로 활용된다.\n사람들은 텍스트가 보일 경우 그 내용에 집중하는 경향 때문에 로렘 입숨이 특히 진가를 발휘한다. 전형적인 로렘 입숨 텍스트는 라틴어 문장의 일부를 변형한 “Lorem ipsum dolor sit amet, consectetur adipiscing elit…”와 같은 형태로 시작된다. 디자인의 ‘보이는’ 부분을 검토할 때 방해가 되지 않는 중립적인 내용을 제공하여 디자인이나 서체 특성을 강조하고자 할 때, 로렘 입숨을 사용하면 사람들이 디자인 자체에 더 집중할 수 있게 되어, 출판사나 디자이너가 인쇄출판 시각적 요소에만 초점을 맞출 때 매우 유용하다. 1\n\n\n\n\n\n\n로렘 입숨 (영문) 사례\n\n\n\nLorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n\n\n\n14.1.1 영문 입숨\n영문 입숨 LaTeX 패키지로 lipsum, blindtext, kantlipsum, mwe 등이 있다. lipsum 패키지는 로렘 입숨(Lorem Ipsum) 텍스트를 쉽게 생성할 수 있어서 가장 널리 사용되는 텍스트 채우기 패키지 중 하나다. 특히, 문단 수를 지정할 수 있는 기능이 있어서 문서의 길이나 복잡성에 따라 유연하게 적용할 수 있다. 예를 들어, \\lipsum[1-5] 명령어를 사용하면 5개의 로렘 입숨 문단을 생성한다.\n\n\n\\documentclass[twocolumn]{article}\n\\usepackage{lipsum} % lipsum 패키지 불러오기\n\n\\begin{document}\n\n\\title{Two-Sided Lipsum Example}\n\\author{Example Author}\n\\date{\\today}\n\n\\maketitle\n\n\\section{Introduction}\n\\lipsum[1] % 첫 번째 로렘 입숨 문단 생성\n\n\\section{Main Body}\n\\lipsum[2-3] % 2~3 번째 로렘 입숨 문단 생성\n\n\\section{Conclusion}\n\\lipsum[4] % 4번째 로렘 입숨 문단 생성\n\n\\end{document}\n\n\n\n\n\n영문 입숨 2단 문서 사례\n\n\n\n\n14.1.2 한글 입숨\njiwonlipsum 패키지는 라틴 계열 문자를 위한 lipsum 패키지와 동일한 목표를 갖지만, 한글 및 한자에 특화된 글꼴, 레이아웃 등 타이포그래피의 요소를 예제로 채우기 텍스트(dummy text)를 생성하는 패키지로 김강수님이 제작했다. jiwonlipsum 팩키지는 KTUG Private Repository에 저장되어 있어 이를 설치한 후 한글 lipsum을 사용할 수 있다. jiwonlipsum 팩키지가 저장된 KTUG Private Repository 저장소를 활용하는 방식은 다음과 같다.\n\n저장소 추가: TeX Live 또는 MiKTeX의 패키지 관리자에서 KTUG Private Repository를 추가한다.\n패키지 설치: 패키지 관리자를 통해 jiwonlipsum 패키지를 검색하고 설치한다.\nLaTeX 문서에 적용: 설치가 완료되면, LaTeX 문서의 preamble(서문) 부분에 \\usepackage{jiwonlipsum}을 추가한다.\n텍스트 생성: 문서 내에서 \\jiwonlipsum 명령어를 사용하여 한글로 된 로렘 입숨 텍스트를 생성한다.\n\n$ tlmgr repository add http://ftp.ktug.org/KTUG/texlive/tlnet/ ktug\n$ tlmgr pinning add ktug \"*\"\n$ tlmgr install jiwonlipsum\ntlmgr.pl: package repositories\n        main = https://mirror.navercorp.com/CTAN/systems/texlive/tlnet (verified)\n        ktug = http://ftp.ktug.org/KTUG/texlive/tlnet/ (not verified: pubkey missing)\nFor more about verification, see https://texlive.info/verification.html.\n[1/1, ??:??/??:??] install: jiwonlipsum @ktug [245k]\nrunning mktexlsr ...\ndone running mktexlsr.\nrunning mtxrun --generate ...\ndone running mtxrun --generate.\ntlmgr.pl: package log updated: C:/texlive/2020/texmf-var/web2c/tlmgr.log\njiwonlipsum 패키지를 사용하여 한글로 된 채우기 텍스트 사례를 보여주는 예제다. 문서형식을 두 칼럼 형식 짧은 보고서(article) 형식으로 지정하고 나서, ‘NanumGothic’ 글꼴을 사용해서 한글을 표현하기 위한 준비를 한다. 제목, 저자, 수정일 정보를 포함한 제목 페이지를 만든 후, jiwonlipsum 패키지를 활용해 한 문단의 요약(abstract)과 ‘들어가며’ 섹션에 채우기 텍스트로 텍스트를 삽입한다.\n\n\n\\documentclass[twocolumn]{article}\n\n\\usepackage{fontspec}\n\\setmainfont{NanumGothic} % NanumGothic 글꼴이 설치되어야 함\n\n\\usepackage{jiwonlipsum}\n\n\\title{멋진 \\LaTeX 제목 페이지}\n\\author{홍길동}\n\\date{\\today}\n\n\\begin{document}\n\n\\maketitle\n\n\\begin{abstract}\n\n\\jiwon[1]\n\n\\end{abstract}\n\n\\section{들어가며}\n\n\\jiwon\n\n\\end{document}\n\n\n\n\n\n한글 입숨 2단 문서 사례"
  },
  {
    "objectID": "document_class.html#문서-클래스",
    "href": "document_class.html#문서-클래스",
    "title": "\n14  문서 클래스\n",
    "section": "\n14.2 문서 클래스",
    "text": "14.2 문서 클래스\nLaTeX 문서 클래스(document class)로 article, report, book 이 기본으로 제공되는 문서 클래스다. KOMA-Script는 또다른 LaTeX 패키지 모음으로 기본 LaTeX 문서 클래스(article, report, book 등) 확장 버전으로, 주로 유럽에서 널리 사용되며, 유럽의 타이포그래피와 문서 규격에 더 적합하게 설계되었다.\n\nscrartcl: article 문서 클래스 확장이며, 과학 학술지, 프리젠테이션, 짧은 보고서, 프로그램 문서, 초대장 등에 쓰이며 1~30페이지 정도 분량을 갖는 문서 작성에 좋다. 추가적인 사용자 설정 옵션과 유럽 스타일 레이아웃을 지원한다.\nscrreprt: report 문서 클래스 확장이며 중간 길이 보고서나 학위 논문 작성에 적합하고, 대략 30~200 페이지 문서 작성에 좋다. scrartcl와 마찬가지로 추가적인 사용자 설정 옵션과 유럽 스타일 레이아웃을 제공한다.\nscrbook: book 문서 클래스 확장으로, 책이나 큰 프로젝트에 적합하고, 대략 200 페이지 이상 문서 작성에 적합하다. 양쪽 페이지 레이아웃과 추가적인 사용자 설정 옵션도 지원한다.\n\n\n\n\n\n\n\n기능\n      짧은 보고서(article)\n      보고서(report)\n      책(book)\n    \n\n\n명령어와 환경\n    \n\n\n장(Chapter) 명령어\n\n\n사용 불가\n\n\n사용 가능\n\n\n사용 가능\n\n\n\n\n부록(Appendix) 스타일링\n\n\n해당 없음\n\n\n부록 X\n\n\n부록 X\n\n\n\n\n부분(Parts)에 대한 새 페이지\n\n\n새 페이지 없음\n\n\n새 페이지\n\n\n새 페이지\n\n\n\n\n전문/본문/후문(Front/Main/Back matter)\n\n\n사용 불가\n\n\n사용 불가\n\n\n사용 가능\n\n\n\n\n요약(Abstract) 환경\n\n\n사용 가능\n\n\n사용 가능\n\n\n사용 불가\n\n\n\n기본 설정\n    \n\n\n양면 옵션(Twoside vs Oneside)\n\n\n단면(Oneside)\n\n\n단면(Oneside)\n\n\n양면(Twoside)\n\n\n\n\n열기 위치(Openright vs Openany)\n\n\n해당 없음\n\n\n열기 위치: 어디든(Openany)\n\n\n열기 위치: 오른쪽(Openright)\n\n\n\n\n페이지 스타일(Pagestyle)\n\n\n일반(Plain)\n\n\n일반(Plain)\n\n\n헤딩(Headings)\n\n\n\n\n제목 페이지(Titlepage)\n\n\n제목 페이지 없음\n\n\n제목 페이지 사용\n\n\n제목 페이지 사용\n\n\n\n\n최하위 섹션(Lowest-level sectioning)\n\n\n하위-하위 섹션(Subsubsection)\n\n\n하위 섹션(Subsection)\n\n\n하위 섹션(Subsection)\n\n\n\n\n상단 제목(Running headings)\n\n\n섹션과 하위 섹션\n\n\n장과 섹션\n\n\n장과 섹션\n\n\n\n\n번호 매김(Numbering scope)\n\n\n연속적\n\n\n장 단위\n\n\n장 단위\n\n\n\n\n참고문헌 표시(Bibliography heading)\n\n\nReferences\n\n\nBibliography\n\n\nBibliography\n\n\n\n\n\n\n\n\n14.2.1 짧은 보고서\n짧은 보고서는 article 문서 클래스(documentclass)로 다음과 같은 구문을 갇고 컴파일하게 되면 짧은 보고서 문서형식을 갖는 PDF 파일을 얻게 된다.\n\n\n\n\n\n\n\n\n\n14.2.2 보고서\n보고서는 report 문서 클래스(documentclass)로 다음과 같은 구문을 갇고 컴파일하게 되면 보고서 문서형식을 갖는 PDF 파일을 얻게 된다.\n\n\n\n\n\n\n\n\n\n14.2.3 책\n책은 book 문서 클래스(documentclass)로 다음과 같은 구문을 갇고 컴파일하게 되면 보고서 문서형식을 갖는 PDF 파일을 얻게 된다.\n\n\n\n\n\n\n\n\n\n14.2.4 한글문서 클래스\noblivoir 문서 클래스(documentclass)는 한글 문서 특성을 잘 반영하여 개발되었다. 다음과 같은 구문을 갇고 컴파일하게 되면 한글 문서형식을 갖는 PDF 파일을 얻게 된다."
  },
  {
    "objectID": "themes_ggplot.html#사용자-테마",
    "href": "themes_ggplot.html#사용자-테마",
    "title": "\n15  그래프 테마\n",
    "section": "\n15.1 사용자 테마",
    "text": "15.1 사용자 테마\n설치한 한글 글꼴과 색상을 매칭하여 사용자 맞춤 테마(theme_penguin)을 생성하고 색상은 wesanderson 패키지에서 Darjeeling1 5가지 색상을 사용하여 시각화한다.\n\nextrafont::loadfonts(\"win\")\n\ntheme_penguin &lt;- function() {\n  \n  # ggthemes::theme_tufte() +\n  theme_minimal() +\n    \n  theme(\n      plot.title     = element_text(family = \"NanumSquare\", size = 18, face = \"bold\"),\n      plot.subtitle  = element_text(family = \"MaruBuri\", size = 13),\n      axis.title.x   = element_text(family = \"MaruBuri\"),\n      axis.title.y   = element_text(family = \"MaruBuri\"),\n      axis.text.x    = element_text(family = \"MaruBuri\", size = 11),\n      axis.text.y    = element_text(family = \"MaruBuri\", size = 11),\n      legend.title   = element_text(family = \"MaruBuri\", size=13),\n      plot.caption   = element_text(family = \"NanumSquare\", color = \"gray20\")\n  )\n}\n\ndarjeeling1_palette &lt;- wes_palette(\"Darjeeling1\", n = 5)\n\nggplot_penguins_gg &lt;- penguins |&gt; \n  ggplot(aes(x = flipper_length_mm, y = body_mass_g)) +\n    geom_point(aes(color = species, shape = species), size = 3) +\n    geom_smooth(method = \"lm\", se = FALSE, color = \"black\")  +\n    labs(\n      title = \"물갈퀴 길이와 체중 회귀분석\",\n      subtitle = \"남극 파머 펭귄 데이터셋\",\n      x = \"물갈퀴 길이 (mm)\",\n      y = \"체중 (g)\",\n      color = \"펭귄종\",\n      caption = \"자료출처: palmerpenguins 패키지\"\n    ) +\n  guides(shape = \"none\") +\n  scale_color_manual(values =  darjeeling1_palette) +\n  theme_penguin()\n\nggplot_penguins_gg\n\nggsave(\"images/ggplot_penguins_gg.png\")"
  },
  {
    "objectID": "themes_ggplot.html#그래프-자동-설정",
    "href": "themes_ggplot.html#그래프-자동-설정",
    "title": "\n15  그래프 테마\n",
    "section": "\n15.2 그래프 자동 설정",
    "text": "15.2 그래프 자동 설정\n작성한 테마를 매번 코드를 “복사하여 붙여넣기” 하여 사용하는 대신 .Rprofile 파일에 반영하여 매번 ggplot 시각화를 할 때 사용하는 방법을 살펴보자. usethis 패키지 edit_r_profile() 함수를 호출하여 앞서 작성한 테마를 반영한다.\n\nusethis::edit_r_profile()\n\ntheme_penguin() 테마를 ggplot2 패키지 theme_set()으로 설정하고 기본 색상을 정의하면 시각화 그래프에 반영하여 사용할 수 있다.\n\nsuppressWarnings(suppressMessages({\n\n  extrafont::loadfonts(\"win\")\n\n\n  ## 테마 (글꼴) -----------------------------\n  theme_penguin &lt;- function() {\n\n    # ggthemes::theme_tufte() +\n    ggplot2::theme_minimal() +\n\n      ggplot2::theme(\n        plot.title     = ggplot2::element_text(family = \"NanumSquare\", size = 18, face = \"bold\"),\n        plot.subtitle  = ggplot2::element_text(family = \"MaruBuri\", size = 13),\n        axis.title.x   = ggplot2::element_text(family = \"MaruBuri\"),\n        axis.title.y   = ggplot2::element_text(family = \"MaruBuri\"),\n        axis.text.x    = ggplot2::element_text(family = \"MaruBuri\", size = 11),\n        axis.text.y    = ggplot2::element_text(family = \"MaruBuri\", size = 11),\n        legend.title   = ggplot2::element_text(family = \"MaruBuri\", size=13),\n        plot.caption   = ggplot2::element_text(family = \"NanumSquare\", color = \"gray20\")\n      )\n  }\n\n  ## 색상\n  ### 웨스 앤더슨\n  color_palette &lt;- wesanderson::wes_palette(\"Darjeeling1\", n = 5)\n\n  ggplot2::theme_set(theme_penguin())\n\n}))\n\n.Rprofile 파일에 ggplot() 사용자 정의 테마가 지정되어 있기 때문에 새로 R 세션을 시작하면 theme_penguin() 테마 및 웨스 앤더스 color_palette 색상 팔레트도 사용할 수 있다.\n\nlibrary(tidyverse)\nlibrary(palmerpenguins)\n\npenguins_theme_gg &lt;- penguins |&gt; \n  ggplot(aes(x = flipper_length_mm, y = body_mass_g)) +\n    geom_point(aes(color = species, shape = species), size = 3) +\n    geom_smooth(method = \"lm\", se = FALSE, color = \"black\")  +\n    labs(\n      title = \"물갈퀴 길이와 체중 회귀분석\",\n      subtitle = \"남극 파머 펭귄 데이터셋\",\n      x = \"물갈퀴 길이 (mm)\",\n      y = \"체중 (g)\",\n      color = \"펭귄종\",\n      caption = \"자료출처: palmerpenguins 패키지\"\n    ) +\n  guides(shape = \"none\") +\n  scale_color_manual(values =  color_palette) +\n  theme_penguin()\n\nragg::agg_jpeg(\"images/penguins_theme_gg.jpg\",\n              width = 10, height = 7, units = \"in\", res = 600)\npenguins_theme_gg\ndev.off()\n\n\n\n펭귄 데이터 사용자 테마 적용 그래프"
  },
  {
    "objectID": "themes_gt.html#사용자-테마",
    "href": "themes_gt.html#사용자-테마",
    "title": "\n16  표 테마\n",
    "section": "\n16.1 사용자 테마",
    "text": "16.1 사용자 테마\n기본 표 테마에 글꼴, 텍스트 크기, 색상을 넣어 전문적으로 표를 작성한다.\n\npenguins_theme_gt &lt;- penguins_gt |&gt; \n  gt_theme_538() |&gt; \n  tab_options(\n    # column_labels.background.color = '#1E61B0', # R logo 파란색\n    table.font.names =\"NanumSquare\",    \n    heading.title.font.size = px(26),\n    heading.subtitle.font.size = px(16),    \n    heading.background.color = \"transparent\", \n    column_labels.font.weight = 'bold',\n    table_body.hlines.width = px(0),\n    data_row.padding = px(6),\n    heading.align = 'center',\n    stub.background.color = \"#ffffff\",\n    stub.font.weight = \"bold\",\n    source_notes.font.size = px(10),\n    row.striping.include_table_body = TRUE\n  ) |&gt; \n  cols_align( align = \"center\", columns = where(is.numeric)) |&gt; \n  cols_align( align = \"auto\", columns = where(is.character)) |&gt; \n  ## 글꼴 달리 적용\n  tab_style(\n    style = cell_text(\n      font = \"MaruBuri\",      \n      weight = 'bold' \n    ),\n    locations = cells_title(groups = 'subtitle')\n  ) |&gt; \n  tab_style(\n    style = cell_text(\n      font = \"MaruBuri\",      \n      weight = 'bold' \n    ),\n    locations = cells_body()\n  ) |&gt; \n  tab_style(\n    style = cell_text(\n      font = \"MaruBuri\",      \n      weight = 'bold' \n    ),\n    locations = cells_column_labels()\n  ) |&gt; \n  tab_style(\n    style = cell_text(\n      font = \"MaruBuri\",      \n    ),\n    locations = cells_source_notes()\n  )\n\npenguins_theme_gt |&gt; \n  gtsave(filename = \"images/penguins_theme_gt.png\")\n\n\n\ngt 사용자 정의 테마 적용 표\n\n\ngt_theme_hangul &lt;- function(gt_tbl) {\n  \n  # Grab number of rows of data from gt object\n  n_rows &lt;- nrow(gt_tbl$`_data`)\n  \n  gt_tbl |&gt; \n    gt_theme_538() |&gt; \n    tab_options(\n      # column_labels.background.color = '#1E61B0', # R logo 파란색\n      table.font.names =\"NanumSquare\",    \n      heading.title.font.size = px(26),\n      heading.subtitle.font.size = px(16),    \n      heading.background.color = \"transparent\", \n      column_labels.font.weight = 'bold',\n      table_body.hlines.width = px(0),\n      data_row.padding = px(6),\n      heading.align = 'center',\n      stub.background.color = \"#ffffff\",\n      stub.font.weight = \"bold\",\n      source_notes.font.size = px(10),\n      row.striping.include_table_body = FALSE\n    ) |&gt; \n    cols_align( align = \"center\", columns = where(is.numeric)) |&gt; \n    cols_align( align = \"auto\", columns = where(is.character)) |&gt; \n    ## 글꼴 달리 적용\n    tab_style(\n      style = cell_text(\n        font = \"MaruBuri\",      \n        weight = 'bold' \n      ),\n      locations = cells_title(groups = 'subtitle')\n    ) |&gt; \n    tab_style(\n      style = cell_text(\n        font = \"MaruBuri\",      \n        weight = 'bold' \n      ),\n      locations = cells_body()\n    ) |&gt; \n    tab_style(\n      style = cell_text(\n        font = \"MaruBuri\",      \n        weight = 'bold' \n      ),\n      locations = cells_column_labels()\n    ) |&gt; \n    tab_style(\n      style = cell_text(\n        font = \"MaruBuri\",      \n      ),\n      locations = cells_source_notes()\n    ) |&gt; \n    tab_style(\n      style = cell_fill(color = 'grey90'),\n      locations = cells_body(rows = seq(1, n_rows, 2))\n    )    \n}\n\npenguins_gt |&gt; \n  gt_theme_hangul()\n\n\n\n\n\n\n남극 펭귄 서식섬과 종 빈도표\n    \n\n\npalmerpenguins 데이터 패키지\n    \n\n\n      Biscoe\n      Dream\n      Torgersen\n    \n\n\n\nAdelie\n44\n56\n52\n\n\nChinstrap\n0\n68\n0\n\n\nGentoo\n124\n0\n0\n\n\n합계\n168\n124\n52\n\n\n\n자료출처: penguins 데이터셋"
  },
  {
    "objectID": "themes_gt.html#표-자동-설정",
    "href": "themes_gt.html#표-자동-설정",
    "title": "\n16  표 테마\n",
    "section": "\n16.2 표 자동 설정",
    "text": "16.2 표 자동 설정\n작성한 테마를 매번 코드를 “복사하여 붙여넣기” 하여 사용하는 대신 .Rprofile 파일에 반영하여 매번 gt 표 제작에 테마를 사용하는 방법을 살펴보자. usethis 패키지 edit_r_profile() 함수를 호출하여 앞서 작성한 테마를 반영한다.\n\nusethis::edit_r_profile()\n\ngt_theme_hangul() 테마를 gt 표 객체에 반영한다.\n\nlibrary(gt)\nlibrary(gtExtras)\n\ngt_theme_hangul &lt;- function(gt_tbl) {\n\n  # Grab number of rows of data from gt object\n  n_rows &lt;- nrow(gt_tbl$`_data`)\n\n  gt_tbl |&gt;\n    gt_theme_538() |&gt;\n    tab_options(\n      # column_labels.background.color = '#1E61B0', # R logo 파란색\n      table.font.names =\"NanumSquare\",\n      heading.title.font.size = px(26),\n      heading.subtitle.font.size = px(16),\n      heading.background.color = \"transparent\",\n      column_labels.font.weight = 'bold',\n      table_body.hlines.width = px(0),\n      data_row.padding = px(6),\n      heading.align = 'center',\n      stub.background.color = \"#ffffff\",\n      stub.font.weight = \"bold\",\n      source_notes.font.size = px(10),\n      row.striping.include_table_body = FALSE\n    ) |&gt;\n    cols_align( align = \"center\", columns = where(is.numeric)) |&gt;\n    cols_align( align = \"auto\", columns = where(is.character)) |&gt;\n    ## 글꼴 달리 적용\n    tab_style(\n      style = cell_text(\n        font = \"MaruBuri\",\n        weight = 'bold'\n      ),\n      locations = cells_title(groups = 'subtitle')\n    ) |&gt;\n    tab_style(\n      style = cell_text(\n        font = \"MaruBuri\",\n        weight = 'bold'\n      ),\n      locations = cells_body()\n    ) |&gt;\n    tab_style(\n      style = cell_text(\n        font = \"MaruBuri\",\n        weight = 'bold'\n      ),\n      locations = cells_column_labels()\n    ) |&gt;\n    tab_style(\n      style = cell_text(\n        font = \"MaruBuri\",\n      ),\n      locations = cells_source_notes()\n    ) |&gt;\n    tab_style(\n      style = cell_fill(color = 'grey90'),\n      locations = cells_body(rows = seq(1, n_rows, 2))\n    )\n}\n\n.Rprofile 파일에 gt 사용자 정의 테마가 지정되어 있기 때문에 새로 R 세션을 시작하면 gt_theme_hangul() 테마를 사용할 수 있다.\n\noriginal_penguins_gt &lt;- penguins |&gt; \n  drop_na() |&gt; \n  count(species, sex) |&gt; \n  pivot_wider(names_from = sex, values_from = n, values_fill = 0) |&gt; \n  janitor::adorn_totals(where = \"col\", name = \"합계\") |&gt; \n  rename(펭귄종 = species, 암컷 = female, 수컷 = male) |&gt; \n  as_tibble() |&gt; \n  gt(rowname_col = \"펭귄종\") |&gt; \n    tab_header(\n      title = md(\"남극 펭귄 **암수와 종** 빈도표\"),\n      subtitle = md(\"`palmerpenguins` 데이터 패키지\")\n    ) |&gt; \n    grand_summary_rows(\n      columns = c(펭귄종, 암컷, 수컷),\n      fns = list(\n        '합계' = ~sum(.) \n      ),\n      fmt = ~ fmt_number(., use_seps = FALSE, decimals = 0),\n      missing_text = '-'\n    )  |&gt; \n    cols_align(\"center\") |&gt; \n    opt_row_striping() |&gt; \n    tab_source_note(\n      source_note = md(\"자료출처: `penguins` 데이터셋\")\n  )\n\ntheme_penguins_gt &lt;- original_penguins_gt |&gt; \n  gt_theme_hangul()\n\ngt_theme_hangul_penguins &lt;- gtExtras::gt_two_column_layout(list(original_penguins_gt, theme_penguins_gt))\n\ngt_theme_hangul_penguins |&gt; \n  gtsave_extra(\"images/gt_theme_hangul_penguins.png\", expand = 1)\n\n\n\ngt_theme_hangul() 테마 적용 전후"
  },
  {
    "objectID": "templates.html",
    "href": "templates.html",
    "title": "17  템플릿",
    "section": "",
    "text": "“템플릿(template)”과 “테마(theme)”는 웹, 디자인, 문서 영역에서 주로 사용되는 용어로, 각각 다른 맥락과 목적을 갖는다. 재사용 가능한 디자인 구조를 제공하여 사용자에게 일관된 경험을 제공하여 문서저작, 디자인 및 개발 시간을 단축시킬 뿐만 아니라 디자인과 레이아웃 표준화를 지원한다.\n템플릿이 문서, 특정 페이지나 컴포넌트의 레이아웃을 위주로 정의하는 반면, 테마는 전체 문서, 웹사이트, 애플리케이션의 디자인과 스타일을 총체적으로 지칭한다는 면에서 차이가 있다."
  },
  {
    "objectID": "whole_game.html#챗gpt-글감-작성",
    "href": "whole_game.html#챗gpt-글감-작성",
    "title": "18  챗GPT 글쓰기 맛보기",
    "section": "18.1 챗GPT 글감 작성",
    "text": "18.1 챗GPT 글감 작성\n사전 자료조사를 통해서 한국영화 10선 중 국제시장과 펭귄 데이터를 통해 흥행과 현재 우리가 당면한 ESG 문제를 다룬 뭉클한 감동을 주는 영화 시놉시스 작성을 목표로 하자.\n\n\n\n\ngraph LR\n\n    chatGPT[\"챗GPT\"] --&gt; Survey\n\n    subgraph Survey[\"자료 조사\"]\n        direction LR\n        Top10[\"한국영화&lt;br&gt;10선\"] --&gt; OpenAI[\"챗GPT\"]\n        Top10                    --&gt; Bard[\"구글 바드\"]\n        Top10                    --&gt; KOBIS[\"역대&lt;br&gt;박스오피스\"]\n    end\n\n    Survey --&gt; Synopsis\n\n    subgraph Synopsis[\"시놉시스\"]\n        direction LR\n        Movie_A[\"명량\"]     -.-&gt; New_Movie[\"새로운 영화&lt;br&gt;시놉시스\"]\n        Movie_B[\"극한직업\"] --&gt; New_Movie\n        Movie_C[\"신과함께\"] -.-&gt; New_Movie\n        Market[\"국제시장\"] --&gt; New_Movie        \n        Movie_E[\"...\"] -.-&gt; New_Movie\n        Penguins[\"펭귄 데이터\"] --&gt; New_Movie\n    end\n\n    Synopsis --&gt; Synopsis_fin[\"최종&lt;br&gt;시놉시스\"]\n\n    style chatGPT fill:#f5f5f5,stroke:#333,stroke-width:3px\n\n    style Survey fill:#059fff,stroke:#333,stroke-width:1px\n    style Synopsis fill:#fc0303,stroke:#333,stroke-width:1px\n    style Synopsis_fin fill:#03fc30,stroke:#333,stroke-width:1px\n\n    style Penguins fill:#03fc30,stroke:#333,stroke-width:3px\n    style Market fill:#03fc30,stroke:#333,stroke-width:3px"
  },
  {
    "objectID": "whole_game.html#구조와-외양",
    "href": "whole_game.html#구조와-외양",
    "title": "18  챗GPT 글쓰기 맛보기",
    "section": "18.2 구조와 외양",
    "text": "18.2 구조와 외양\n글감이 준비되면 그 다음으로 가독성을 높이고 효과적인 콘텐츠 제작을 위해서 그림, 표, 그래프, 수식, 도형 등 다양한 문서 객체 뿐만 아니라 색상을 달리하여 시각적인 효과도 극대화하여 고품질 문서를 저작하게 된다.\n\n마크다운 기본 글쓰기\n\n대중소 제목\n굵은 글씨, 밑줄, ..\n단락 구분\n\n그림 (Figure)\n그래프 (Graph)\n표 (Table)\n도형 (Diagrams)\n수식 (LaTeX)\n호출 블록 (Callout Blocks)\n기사 레이아웃 (Article Layout)\n학술저작 (Scholarly Writing)\n다단편집(Side-by-Side Layout)\n…"
  },
  {
    "objectID": "whole_game.html#배포와-공유",
    "href": "whole_game.html#배포와-공유",
    "title": "18  챗GPT 글쓰기 맛보기",
    "section": "18.3 배포와 공유",
    "text": "18.3 배포와 공유\n디지털 글쓰기 저작물을 제작하게 되면 그 다음 단계로 출판을 해야하는데 다양한 문서를 모아 프로젝트로 담아 Quarto Pub에 전자출판한다. 다른 출판 플랫폼으로 netlify, GitHub Pages, RStudio Connect가 많이 사용된다."
  },
  {
    "objectID": "dw_pdf.html#환경설정",
    "href": "dw_pdf.html#환경설정",
    "title": "\n19  쿼토 PDF\n",
    "section": "\n19.1 환경설정",
    "text": "19.1 환경설정\n\n19.1.1 리눅스\nInstall Quarto 웹사이트에 쿼토 설치 방법이 잘 설명되어 있다. 먼저 쉘에서 curl로 쿼토 설치파일을 다운로드 받는다. gdebi-core를 설치하고 다운로드 받은 쿼토 파일을 gdebi 명령어로 설치하고 나서 quarto --version 명령어로 설치된 쿼토 버전을 확인한다.\n$ sudo curl -LO https://quarto.org/download/latest/quarto-linux-amd64.deb\n$ sudo apt-get install gdebi-core\n$ sudo gdebi quarto-linux-amd64.deb\n$ quarto --version\n1.3.450\n\n19.1.2 LaTeX 설치\nTinyTeX은 TeX Live를 기반으로 한 경량, 이식성 좋고, 사용하기 쉬운 LaTeX 배포판으로 LaTeX 설치와 관련된 일반적인 불편함을 해결하기 위해 만들어졌고, 특히 “이휘 쉬에(Yihui Xie)”가 개발하여 R과 R 마크다운 통합이 잘 되어 있다.\n다른 LaTeX 배포판들이 수 기가바이트(GB)의 크기를 갖지만, TinyTeX은 설치 크기가 작고 간단한 설치 과정을 제공으로 쉽지만 미려한 문서를 원하는 사용자들에게 인기가 많다. 특히, R과의 통합도 잘 이루어져 있어, LaTeX 문서를 컴파일할 때 누락된 LaTeX 패키지도 자동으로 설치해주는 기능이 많은 사랑을 받고 있다.\n보통 TexLive에 기반을 둔 tinytex 를 사용하는데 한글을 사용하는 입장에서는 kotex를 설치하는 방법도 모색이 필요하다. 유니코드 문자를 처리하기 위해서 xelatex을 쿼토 \\(LaTeX\\) 기본엔진으로 지정하면 xelatex을 통해 CJK 문자가 포함된 PDF 파일 제작이 가능하다.\n쿼토를 설치하면 quarto install tinytex 명령어로 TinyTeX을 쉽게 설치할 수 있고, 설치 정보는 quarto tools info tinytex으로 파악이 가능하다.\n$ quarto install tinytex\nInstalling tinytex\n[✓] Downloading TinyTex v2023.09\n[✓] Unzipping TinyTeX-v2023.09.tar.gz\n[✓] Moving files\n[✓] Verifying tlgpg support\n[✓] Default Repository: https://mirrors.rit.edu/CTAN/systems/texlive/tlnet/\nInstallation successful\n\n$ quarto tools info tinytex\n{\n  \"name\": \"TinyTeX\",\n  \"installed\": true,\n  \"version\": \"v2023.09\",\n  \"directory\": \"/home/statkclee/.TinyTeX\",\n  \"bin-directory\": \"/home/statkclee/.TinyTeX/bin/x86_64-linux\",\n  \"configuration\": {\n    \"status\": \"ok\"\n  }\n}\nkotex 패키지 주요 장점 중 하나는 한글 관련 문제를 해결할 수 있는 다양한 LaTeX 패키지와 기본 한글 글꼴을 내장하고 있어 한글 문서 작성이 훨씬 편리하다. 하지만, tinytex를 기본 LaTeX 엔진으로 사용할 경우, 누락된 패키지로 인해 추가 작업이 어려울 수 있다. 이러한 문제를 해결하기 위해 tinytex::parse_install() 함수를 사용하면, 오류가 발생한 텍스트를 붙여넣을 때 자동으로 필요한 패키지를 설치해 준다. 설치과정에서 오류 사항이 담긴 .log 파일을 tinytex::parse_install() 함수에 인자로 넣어주면, 자동으로 필요한 패키지를 설치해 준다.\n\n# log 파일이 hello_world.log\ntinytex::parse_install(\"hello_world.log\")\n\ntinytex::parse_install(\n  text = \"! LaTeX Error: File `titlepic.sty' not found.\"\n)"
  },
  {
    "objectID": "dw_pdf.html#헬로월드",
    "href": "dw_pdf.html#헬로월드",
    "title": "\n19  쿼토 PDF\n",
    "section": "\n19.2 헬로월드",
    "text": "19.2 헬로월드\n기본적인 LaTeX 문서 구조에 표, 수식, 다이어그램, 주석을 추가한 LaTeX 기본 문서를 작성한다.\n\\documentclass{article}  % 문서 클래스 지정. article은 학술 논문, 보고서 등에 적합하다.\n\n\\usepackage{tikz}  % tikz 패키지 추가. 그래픽을 그리기 위해 필요하다.\n\n\\title{fathers of the atomic bomb}  % 문서의 제목 설정\n\\author{Oppenheimer}  % 문서의 저자 설정\n\\date{\\today}  % 문서의 날짜 설정. \\today를 사용하여 오늘 날짜를 자동 입력한다.\n\n\\begin{document}  % 문서의 본문 시작\n\n\\maketitle  % 제목, 저자, 날짜를 출력\n\n\\section{Introduction}  % \"Introduction\"이라는 섹션 생성\n\nThe name \"Oppenheimer\"\\footnote{Oppenheimer is pronounced in English as /ˈɒpənˌhaɪmər} is a German-origin surname that is most famously associated with J. Robert Oppenheimer, the American physicist known as one of the \"fathers of the atomic bomb.\"  % 본문과 각주\n\n\\section{Table}  % \"Table\"이라는 섹션 생성\nBelow is a simple table.\n\\begin{center}\n\\begin{tabular}{|c|c|}\n\\hline\nHeader 1 & Header 2 \\\\  % 테이블의 헤더\n\\hline\nRow 1, Col 1 & Row 1, Col 2 \\\\  % 첫 번째 행\nRow 2, Col 1 & Row 2, Col 2 \\\\  % 두 번째 행\n\\hline\n\\end{tabular}\n\\end{center}  % 테이블 종료\n\n\\section{Equation}  % \"Equation\"이라는 섹션 생성\nHere is a simple equation:\n\\begin{equation}  % 수식 환경 시작\n  f(x) = x^2  % 수식\n\\end{equation}  % 수식 환경 종료\n\n\\section{Diagram}  % \"Diagram\"이라는 섹션 생성\nHere is a simple diagram:\n\\begin{center}\n\\begin{tikzpicture}  % tikz로 그림을 그리기 시작\n  \\draw[-&gt;] (0,0) -- (4,0);  % x축 그리기\n  \\draw[-&gt;] (0,0) -- (0,4);  % y축 그리기\n  \\draw (0,0) -- (3,3);  % 대각선 그리기\n\\end{tikzpicture}\n\\end{center}  % 그림 환경 종료\n\n\\end{document}  % 문서의 본문 종료\nRStudio로 LaTeX을 이용해 PDF 문서를 생성할 때, 먼저 새로운 .tex 문서를 생성하고 표, 수식, 다이어그램, 주석이 포함된 LaTeX 코드를 복사-붙여넣는다. RStudio의 Compile PDF 버튼을 클릭하여 컴파하고, 완료되면 PDF 문서가 자동으로 열린다.\n\n\n\n\nLaTeX 문서 컴파일\n\n\n\n\n\n\nLaTeX 헬로월드 기본 문서\n\n\n\n\n19.2.1 한글 PDF\n영문 PDF를 한글로 번역하여 동일한 방식으로 PDF 파일을 만들기 위해 컴파일하게 되면 한글이 깨지거나 아무것도 없는 PDF 문서가 생성된다.\n\\documentclass{article}\n\n\\usepackage{tikz}\n\n\\title{원자폭탄의 아버지들}\n\\author{오펜하이머}\n\\date{\\today}\n\n\\begin{document}\n\n\\maketitle\n\n\\section{소개}\n\n\"오펜하이머\"라는 이름\\footnote{오펜하이머는 영어로 /ˈɒpənˌhaɪmər/ 로 발음된다}은 독일 기원의 성씨로 가장 유명한 사람은 미국 물리학자 J. 로버트 오펜하이머이다. 그는 \"원자폭탄의 아버지\"로 알려져 있다.\n\n\\section{표}\n아래는 간단한 표이다.\n\\begin{center}\n\\begin{tabular}{|c|c|}\n\\hline\n헤더 1 & 헤더 2 \\\\\n\\hline\n행 1, 열 1 & 행 1, 열 2 \\\\\n행 2, 열 1 & 행 2, 열 2 \\\\\n\\hline\n\\end{tabular}\n\\end{center}\n\n\\section{수식}\n다음은 간단한 수식이다:\n\\begin{equation}\n  f(x) = x^2\n\\end{equation}\n\n\\section{다이어그램}\n아래는 간단한 다이어그램이다:\n\\begin{center}\n\\begin{tikzpicture}\n  \\draw[-&gt;] (0,0) -- (4,0);\n  \\draw[-&gt;] (0,0) -- (0,4);\n  \\draw (0,0) -- (3,3);\n\\end{tikzpicture}\n\\end{center}\n\n\\end{document}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n한글이 PDF 문서에 표현되지 않는 문제는 글꼴을 .tex 파일에 지정함으로써 해결된다. 먼저 전제조건으로 한글 글꼴(예를 들어, 나눔고딕 글꼴)이 설치되어 있고 이를 LaTeX 에서 컴파일하는 방식으로 작업한다.\n\n\\documentclass{article}\n\n\\usepackage{tikz}\n\\usepackage{fontspec}\n\\setmainfont{NanumGothic} % NanumGothic 글꼴이 설치되어야 함\n\\usepackage{tipa} % 발음기호(IPA symbols)\n\n\\title{원자폭탄의 아버지들}\n\\author{오펜하이머}\n\\date{\\today}\n\n\\begin{document}\n\n\\maketitle\n\n\\section{소개}\n\n\"오펜하이머\"라는 이름\\footnote{오펜하이머는 영어로 \\textipa{/ˈɒpənˌhaɪmər/} , \\textipa{/\\'{O}p@n\\\"{h}aIm@r/} 로 발음된다}은 독일 기원의 성씨로 가장 유명한 사람은 미국 물리학자 J. 로버트 오펜하이머이다. 그는 \"원자폭탄의 아버지\"로 알려져 있다.\n\n\\section{표}\n아래는 간단한 표이다.\n\\begin{center}\n\\begin{tabular}{|c|c|}\n\\hline\n헤더 1 & 헤더 2 \\\\\n\\hline\n행 1, 열 1 & 행 1, 열 2 \\\\\n행 2, 열 1 & 행 2, 열 2 \\\\\n\\hline\n\\end{tabular}\n\\end{center}\n\n\\section{수식}\n다음은 간단한 수식이다:\n\\begin{equation}\n  f(x) = x^2\n\\end{equation}\n\n\\section{다이어그램}\n아래는 간단한 다이어그램이다:\n\\begin{center}\n\\begin{tikzpicture}\n  \\draw[-&gt;] (0,0) -- (4,0);\n  \\draw[-&gt;] (0,0) -- (0,4);\n  \\draw (0,0) -- (3,3);\n\\end{tikzpicture}\n\\end{center}\n\n\\end{document}\n\n\n\nLaTeX에서 한글문제를 해결한 PDF 문서"
  },
  {
    "objectID": "dw_website.html#project-setup",
    "href": "dw_website.html#project-setup",
    "title": "20  웹사이트",
    "section": "20.1 프로젝트 생성",
    "text": "20.1 프로젝트 생성\n쿼토(quarto) 설치하고 정적 웹사이트 제작을 위한 프로젝트를 준비한다. 문서로 웹사이트 개발을 위한 RStudio IDE를 통합개발환경으로 선택한 경우 File → New Project ... → Project Type 에서 Quarto Website를 선택한다.\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n\n\n\n그림 20.1: (정적) 웹사이트 프로젝트 선택과정\n\n\n다음 단계로 웹사이트가 담길 디렉토리를 지정하고 웹사이트 디렉토리를 생성하고 Create Project 버튼을 를 클릭한다. 쿼토 웹사이트 프로젝트가 생성되면 웹사이트 제작을 위한 기본 골격이 제시된다. _quarto.yml 파일에 웹사이트 기본 정보가 담겨지고 각 웹페이지는 index.qmd, about.qmd 파일로 저작한다.\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n\n\n\n그림 20.2: 쿼토 웹사이트 프로젝트 생성"
  },
  {
    "objectID": "dw_website.html#project-writing",
    "href": "dw_website.html#project-writing",
    "title": "20  웹사이트",
    "section": "20.2 웹사이트 저작",
    "text": "20.2 웹사이트 저작\n문서의 구조를 정의하는 _quarto.yml 파일에 웹사이트 문법을 적용하여 웹페이지는 .qmd 파일, 외양은 .css 혹은 .scss 파일에 정리한다. 관련하여 웹사이트를 구성하는 이미지, 동영상, 소리를 비롯한 각종 자산(assets)도 웹페이지에 잘 담기도록 저작한다.\n쿼토 웹사이트 프로젝트는 웹사이트 기본골격을 다음 파일과 디렉토리를 통해 제공된다. _site/ 디렉토리는 쿼토 웹사이트를 컴파일하게 되면 자동 생성된다. _site/ 디렉토리에 index.qmd 파일을 컴파일한 index.html 파일을 비롯한 정적 웹사이트 저작을 위한 각종 파일과 디렉토리로 채워진다.\n쿼토 웹사이트를 컴파일하는 방식은 Ctrl + Shift + K 단축키를 누르거나, 상단 Render 버튼을 클릭하거나, CTRL + SHIFT + B 단축키를 누르거나, Build에 Render Website를 클릭한다.\n\n_quarto.yml\nindex.rmd\nabout.rmd\n_site/\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n\n\n\n그림 20.3: 로컬 웹사이트 컴파일\n\n\n_site/ 디렉토리는 정적 웹사이트가 배포되는 디렉토리로,\n기본적으로 http://netlify.com/를 상정한 경우 _site/를 사용하지만, docs/로 바꿔주게 되면 GitHub Pages 웹호스팅으로 사용하여 배포할 수 있게 된다. GitHub Pages 배포를 위해 _quarto.yaml 파일에 output-dir: docs을 추가하게 되면 정적 웹사이트가 _docs 폴더에 담기게 된다.\n요약하면 _quarto.yml 파일을 열어 output_dir: 설정이 없는 경우 output_dir: docs로 지정하고, 이미 존재하는 경우 output_dir: 값을 _site → docs으로 변경한다. 그리고 나서 쿼토 웹사이트를 빌드시키면 웹사이트 전체가 docs/ 디렉토리에 저장된다. 이것을 GitHub 저장소에 업로드하거나 push 해서 올리게 되면 블로그 웹사이트가 https://&lt;사용자명&gt;.github.io/&lt;저장소명&gt;/index.html을 통해 배포된다.\n\n\nproject:\n  type: website\n\n\n\nproject:\n  type: website\n  output-dir: docs"
  },
  {
    "objectID": "dw_website.html#theme-distill",
    "href": "dw_website.html#theme-distill",
    "title": "20  웹사이트",
    "section": "20.3 외양 - 폰트, 색상 등",
    "text": "20.3 외양 - 폰트, 색상 등\n지금까지 전반적인 웹사이트 생성과 웹페이지 콘텐츠 작성과 관련된 전반적인 작업흐름에 집중했다면 글꼴, 색상 등 외양을 바꾸면 근사한 웹사이트로 탈바꿈시킬 수 있다. 특히 쿼토는 부츠트랩 5(Bootstrap 5)를 지원하기 때문에 SCSS 변수 설정을 통해 멋진 웹사이트를 꾸밀 수 있다.\n글꼴만 한글로 바꿔 tidyverse.css를 저장한다. 기본 아이디어는 구글 글꼴 웹사이트 https://fonts.google.com/ 에서 한글 글꼴을 가져와서 웹사이트 제목과 텍스트에 글꼴을 저작자의 선택에 맞춰 반영한다. 수정한 tidyverse.css 파일 일부는 다음과 같다.\n@import url('https://fonts.googleapis.com/css2?family=Sunflower');\n@import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR');\n@import url('https://fonts.googleapis.com/css2?family=Gaegu');\n\nhtml {\n  /*-- Main font sizes --*/\n  --title-size:      50px;\n  --body-size:       1.06rem;\n  --code-size:       14px;\n  --aside-size:      12px;\n  --fig-cap-size:    13px;\n  /*-- Main font colors --*/\n  --title-color:     #000000;\n  --header-color:    rgba(0, 0, 0, 0.8);\n  --body-color:      rgba(0, 0, 0, 0.8);\n  --aside-color:     rgba(0, 0, 0, 0.6);\n  --fig-cap-color:   rgba(0, 0, 0, 0.6);\n  /*-- Specify custom fonts ~~~ must be imported above   --*/\n  --heading-font:    'Sunflower', sans-serif;\n  --mono-font:       \"DM Mono\", monospace;\n  --body-font:       'Noto Sans KR', sans-serif;\n  --navbar-font:     'Gaegu', cursive;\n}"
  },
  {
    "objectID": "dw_website.html#deployment-setup",
    "href": "dw_website.html#deployment-setup",
    "title": "20  웹사이트",
    "section": "20.4 웹사이트 배포",
    "text": "20.4 웹사이트 배포\n\n20.4.1 GitHub Pages 출판\nhttps://&lt;사용자명&gt;.github.io/ 저장소는 매우 특별한 GitHub 저장소다. 따라서, GitHub 저장소 명칭을 &lt;사용자명&gt;.github.io 으로 생성해야 한다. 예를 들어, statkclee.github.io 와 같이 사용자계정을 github.io와 붙여 먼저 판다. 그리고 나서, 상단 Settings로 들어간 다음 GitHub Pages 설정을 한다. 이때 GitHub 저장소의 특정 디렉토리 docs/ 디렉토리에 담긴 내용 전부가 정적 웹사이트에 게시되는 내용이 된다. 즉, docs/index.html → https://&lt;사용자명&gt;.github.io/&lt;저장소명&gt;/index.html로 바뀌어 웹사이트 생성 및 배포가 완료된다.\n\n\n\n정적 웹사이트 GitHub Pages 연결\n\n\n\n\n20.4.2 Quarto Pub 출판\nQuarto Pub 출판과정은 Quarto CLI를 통해 이뤄진다. RStudio의 내부 터미널을 사용하는 것을 권장하는데, 이유는 RStudio와 Quarto가 잘 통합되어 있어, 간편하게 출판 작업을 진행할 수 있기 때문이다. 1\n#| eval: false\n$ quarto publish quarto-pub\n? Authorize (Y/n) › \n❯ In order to publish to Quarto Pub you need to\n  authorize your account. Please be sure you are\n  logged into the correct Quarto Pub account in \n  your default web browser, then press Enter or \n  'Y' to authorize.\n첫번째 출판하게 되면 인증작업을 수행하고 나면 _publish.yml 파일이 하나 생성된다.\n#| eval: false\n- source: project\n  quarto-pub:\n    - id: 1fa3ab1f-c010-453a-aaf2-f462bd074a66\n      url: 'https://quartopub.com/sites/statkclee/quarto-ds'\n이제 모든 준비가 되었기 때문에 다음 명령어로 작성한 출판 문서를 포함한 웹사이트를 로컬에서 미리 확인 한 후에 Quarto Pub으로 전자출판한다. 윈도우에서는 RStudio 내부 Terminal CLI를 사용하는 것을 권장한다.\n#| eval: false\n$ quarto preview\n$ quarto publish quarto-pub"
  },
  {
    "objectID": "dw_slideshow.html#헬로월드",
    "href": "dw_slideshow.html#헬로월드",
    "title": "\n21  슬라이드 PPT\n",
    "section": "\n21.1 헬로월드",
    "text": "21.1 헬로월드\n쿼토는 기본적으로 프로젝트를 기반으로 시작하기 때문에 프로젝트를 하나 생성한다. RStudio를 실행하고 우측 상단 Project:(None)을 클릭하여 New Project를 새로운 디렉토리를 만들어 생성한다.\n\n\n\n\n\n\n\n\n\n\n\n그림 21.1: 슬라이드 제작을 위한 프로젝트 생성\n\n\n프로젝트가 생성되면 File → New File → Quarto Presentation...을 클릭하여 쿼토 슬라이드 .qmd 문서파일을 생성한다.\n\n\n\n\n\n\n\n\n\n\n\n그림 21.2: 쿼토 프리젠테이션 파일 생성\n\n\nCtrl + Shift + k 단축키를 눌러 .qmd 파일을 웹슬라이드로 제작할 수 있다. 웹슬라이드 파일명을 helloworld.qmd로 저장한다.\n\n\n첫번째 웹슬라이드 제작과정\n\n\n\n다운로드 예제 PPT 파일"
  },
  {
    "objectID": "publishing.html#법인-출판사-신청",
    "href": "publishing.html#법인-출판사-신청",
    "title": "24  출판",
    "section": "24.1 법인 출판사 신청",
    "text": "24.1 법인 출판사 신청\n개인이 아닌 법인으로 출판사를 설립하거나 법인 업종에 “출판업”을 추가하는 경우 목적은 출판사 신고확인증을 발급받는 것이다. 책을 출판하는 경우 먼저 관할 지자체에 신고를 준비해야 한다. 이를 위해서 “출판사(신고서, 변경신고서)”를 작성하고 다음 서류를 준비하여 관할 지자체(구시군청)를 내방하여 제출한다. 출판사 신고서는 출판문화산업 진흥법 시행규칙에 별지 서식으로 다운로드 가능하다.\n\n임대차 계약서\n법인등기부등본\n법인인감증명서\n법인인감\n법인대표 신분증\n\n출판사 등록제출서류 제출 후 3일 내 처리하는 것이 원칙이고 출판등록신고증은 등기(서류제출 시 수령주소 명시)로도 수령이 가능하다. 출판등록신고증이 완료되면 세무서를 사업자등록증에 이를 업종에 반영하여 마무리한다.\n\n\n\n\n\n\n출판사 신고확인증 예시"
  },
  {
    "objectID": "publishing.html#isbn-발급",
    "href": "publishing.html#isbn-발급",
    "title": "24  출판",
    "section": "24.2 ISBN 발급",
    "text": "24.2 ISBN 발급\n국립중앙도서관에서 책을 출판하는 경우 “ISBN” 번호를 출판사가 부여받아야 한다. 이를 위해서 국립중앙도서관 ISBN ISSN 납본시스템에 접속하여 안내에 맞춰 후속 절차를 진행한다. 먼저 국립중앙도서관 ISBN ISSN 납본시스템 상단 계정등록 작업을 수행하여 앞서 발급받은 출판사 신고확인증을 증빙으로 계정등록을 한다.\n\n24.2.1 발행자번호 신청\n발행자번호 신청을 통해 출판사 신고확인증에 기재된 출판사명과 대응되는 ISBN 발행자번호를 부여받는 작업을 수행한다. 처리기간은 업무일 기준 3일이 소요된다.\n\n\n\n\n\n\n\n24.2.2 ISBN 번호 신청\n출판사 발행자번호가 발급되면 출판할 책의 ISBN 번호를 부여할 수 있다."
  },
  {
    "objectID": "publishing.html#인쇄",
    "href": "publishing.html#인쇄",
    "title": "24  출판",
    "section": "24.3 인쇄",
    "text": "24.3 인쇄\n출판사가 출판할 책이 정해지면 다음 단계로 수익창출을 위해 인쇄소와 계약을 하여 종이형태 책을 500권, 1,000권 등 수요 구독자를 감안하여 인쇄소에서 출판한다."
  },
  {
    "objectID": "publishing.html#판매",
    "href": "publishing.html#판매",
    "title": "24  출판",
    "section": "24.4 판매",
    "text": "24.4 판매\n다양한 출판채널을 통해 독자를 만나고 책을 판매하여 수익을 출판사와 저자, 그리고 서점과 분배한다."
  },
  {
    "objectID": "publishing.html#출판-디지털-전환",
    "href": "publishing.html#출판-디지털-전환",
    "title": "24  출판",
    "section": "24.5 출판 디지털 전환",
    "text": "24.5 출판 디지털 전환\n200자 원고지 4장은 통상 A4 용지 한장에 해당한다. 만약 A4 용지 10장 보고서나 논문을 작성한다고 하면, 종이 200자 원고지 40장에 연필이나 볼펜을 가지고 작성하게 된다. 최종본을 얻기까지 빨간색으로 선생님이나 주변의 첨삭지도를 받아 최종본을 만들기까지 여러번의 반복과정을 거치게 된다.\n최종 원고가 200자 원고지 40장에 담겨 탈고를 마치게 되면, 독자에게 다가갈 준비를 한다. 그림을 넣거나 아름다운 글씨체를 적용해 보고 종이 재질을 바꿔보기도 하고 영혼이 담긴 원고를 독자가 보기 좋고, 이해하기 쉽고, 때로는 감동과 재미를 줄 수 있도록 출판 단계에서 많은 사람들의 노력이 들어간다.\n탈고를 마친 원고에 글씨체를 비롯한 디자인 작업이 완료되면 출판장비를 갖춘 출판소에서 인쇄장비를 거쳐 종이책 혹은 보고서가 완성되고, 이렇게 대량으로 출력되면 각 서점으로 배송되어 독자가 서점에서 구독을 하게 된다.\n저자의 생각을 글로 표현하면 현재도 대부분 편집 및 디자인, 출판, 배송, 서점 등 각 단계에 사람이 관여하고 필요에 따라서는 컴퓨터가 작업을 지원하는데 사용되어 최종 독자에게 전달된다.\n책과 보고서 제작하는 과정은 워드 프로세스를 기본으로 두고, 숫자 계산이 필요하면 엑셀, 이미지가 필요하면 그래픽 전문 소프트웨어, 정보 검색도 웹브라우져를 사용한다. 글자, 단어, 문장, 문단, 장/절/항으로 생각의 단위를 서문, 본문, 결어 및 참고문헌, 주석, 그림, 그래프, 도표 등도 함께 체계적으로 작성해 나간다.\n다양한 소프트웨어를 통해서 원고를 탈고하게 되면 서식, 문장 문단 모양, 색인, 참조문헌 등 보기 좋고 가독성 높은 형태로 외양을 입히는 과정을 거치게 되는데 이 과정도 소프트웨어가 핵심적인 역할을 하게 된다. 책과 보고서에 대한 디자인 작업이 완료되면 다양한 형태로 배포하기 위한 프로그래밍 과정을 거쳐 PDF, 전자책(ePUB), 웹(HTML), 출판책 형태로 독자에게 전달된다.\n글을 써서 이를 독자에게 전달되는 과정은 과거에 전문작가, 디자인 전문가, 출판전문가, 서점운영자 등 수많은 전문가가 연관되어 있고 타자기, 디자인 기계, 인쇄기 등 수많은 기계가 필요했으며 이를 사업적으로 기술적으로 연결할 수 있는 다양한 통신 방법이 필요했다. 비전문가가 밖에서 보면 복잡하고 어려워 보이지만, 컴퓨팅 사고의 시각으로 보면 단순할 수 있다.\n\n\n\n\n\n\n종이 출판\n\n\n\n\n\n\n\n디지털 출판\n\n\n\n그림 24.1: 디지털 출판 방식"
  },
  {
    "objectID": "publishing.html#판형",
    "href": "publishing.html#판형",
    "title": "24  출판",
    "section": "24.6 판형",
    "text": "24.6 판형\n종이 크기는 다양한데 우리나라는 국제 표준인 ISO A형(A4 등 A 계열)을 채택하고 있는데 제조 효율에서는 표준으로 설계된 크기인 ISO A형이 활용성과 효율이 가장 좋은 것으로 알려져 있다. A형 전지는 A0로 표기하며 이를 접어서 절단할 때마다 숫자를 늘려 표기한다. A1은 한번 접어서 자른 크기이며, 흔히 사용하는 A4는 A0를 네 번 접어서 자른 종이 크기다.\nA계열로 일명 A0판이라고 부르는 841*1189mm 종이를 가로 세로로 접어가면서 자르는 방식으로 A4는 A1을 8조각으로 자른 것이다. ’국배판’으로 불리는 A4판(210*297mm)은 학습지 등 문제풀이나 필기가 필요한 서적에 주로 사용되고, 신국판으로 불리는 A5판의 변형본은 148*210mm인 A5보다 약간 큰 152*225mm 으로 한국 출판계에서 가장 흔한 사이즈다.\nB계열은 JIS B규격으로써 4*6전지나 B0이라고 부르는 1030*1456mm 종이를 가로 세로로 접어가면서 자르는 방식으로 A4와 마찬가지로 B4는 B1을 8조각으로 자른 것이다. 소설, 자서전, 전문서적에는 신국판(152*225mm)을 많이 사용하고, 46배판은 B5(16절) 182 x 257(4x6배판)과 같은 크기로 대학 전공서적 등에 주로 사용된다.\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n\n\n\n그림 24.2: 종이크기(A0, B0)"
  },
  {
    "objectID": "about_book.html",
    "href": "about_book.html",
    "title": "\n25  책과 편집 용어\n",
    "section": "",
    "text": "26 책의 내부 순서 및 명칭\n책의 내부 순서 및 명칭을 살펴보면 다음과 같다.\ncontent_144_tbl &lt;- table_cells %&gt;% \n  filter(doc_index == 144) %&gt;% \n  select(text, row_id, cell_id) %&gt;% \n  pivot_wider(names_from = cell_id, values_from = text) %&gt;% \n  select(-row_id) \n\ncontent_147_tbl &lt;- table_cells %&gt;% \n  filter(doc_index == 147) %&gt;% \n  select(text, row_id, cell_id) %&gt;%  \n  pivot_wider(names_from = cell_id, values_from = text) %&gt;% \n  select(-row_id) \n\ncontent_tbl &lt;- bind_rows(content_144_tbl, content_147_tbl)\n\ncontent_tbl &lt;- content_tbl %&gt;% \n  set_names(cover_tbl %&gt;% slice(1)) %&gt;% \n  filter(row_number() != 1) %&gt;% \n  select(1,2,4,3) \n\ncontent_tbl |&gt; \n  gt() |&gt; \n  gt_theme_hangul()\n\n\n\n\n\n순\n      용 어\n      대응 영어\n      용어 정의\n    \n\n\n1\n반표제지\nhalf-title page\n책의제호만(편저자,출판사등넣지않음) 속표지 앞에 본문지로 인쇄하여 넣음.\n\n\n2\n머리그림\nfrontispiece\n책의 앞머리 반표제 다음에 본문과 관계된 사진이나 그림 등을 속표지와 마주 보게 인쇄하며, 뒤쪽을 백지로 비우는 것이 원칙.\n\n\n3\n속표지\nfull title page\n책의 본문 바로 앞, 면지·반표제지 다음에 넣는 표지로 앞표지와 동일하게 표제, 편저자, 출판사 등을 표시함.\n\n\n4\n판권지\nimprint page/copyright page\n표제, 편저자, 발행자, 발행사, 발행 연월일 등 출판 사항을 넣는 면. 한국이나 일본, 중국 등에서는 권말에 넣고 있으나 최근 서구의 책처럼 속표지 뒤에다 인쇄하는 경향임.\n\n\n5\n바치는 글\ndedication\n저자가 스승이나 선배, 친지에게 자신의 저서를 헌정하는 글.\n\n\n6\n고침표\nerrata/corrigenda\n인쇄가 끝난 뒤에 발견된 오자나 오식을 모은 정정 일람표로 별도로 인쇄, 제본된 책 속에 끼움.\n\n\n7\n머리말\npreface\n책의 편저자 자신이 책의 앞 부분에 스스로 써 넣은 글로 일명 ‘서문’이라고도 일컬음.\n\n\n8\n추천사\nforeword\n저자의 스승이나 선배 등이 책의 내용을 평가하며 일독을 권하는 글로 머리글 다음에 배열.\n\n\n9\n감사글\nacknowledgement\n저자가 책의 저술 중 도움을 받은 사람이나 기관 등에 감사의 마음을 표시한 글.\n\n\n10\n일러두기\nexplanatory notes\n책 내용 구성과 편집에 활용된 약호나 부호 등의 해설. 일명 ‘범례’라고도 하며, 사전이나 지도 등의 책은 필수 사항.\n\n\n11\n차례\nContents\n책이나 잡지 등에서, 내용의 대소 단원의 제목을 뽑아서 해당 페이지를 표시한 일람표로서 도서의 경우는 편, 부, 절, 항 등의 제목과 수록 페이지를 밝혀 순차적으로 편집하되, 일반 도서는 머리말 다음에, 잡지의 경우는 표지나 본문 맨 앞쪽에 배열.\n\n\n12\n그림 차례\nillustrations\n책의 본문 내용을 보충 설명하기 위해 삽입해 놓은 그림·삽화의 차례.\n\n\n13\n약어표\nabbreviations\n단어를 축약한 약어들을 가나다 순이나 알파벳 순으로 정리·요약한 표.\n\n\n14\n중간 표제지\ndivisional title page\n본문 가운데 ‘부(部)·편(篇)·장(章)의 제목’ 만의 하나의 페이지로 편집한 쪽. 통상 홀수 면으로 시작하며, 법전 등의 책에 따라 본문 인쇄 용지와 다른 색지 등을 이용하기도 함.\n\n\n15\n본문\ntext\n도서, 잡지, 신문이나 문서 가운데 주체가 되는 문장 내용의 총칭.\n\n\n16\n주\nnotes\n책의 맨 끝이나 해당 페이지 하단 또는 판면 좌우 여백에 등에 넣는 내용의 보충 설명문. 본문에 인용된 자료의 서명과 지면 등을 명확히 밝혀 순번대로 게재.\n\n\n17\n후기\nafterword/ postscript\n책의 끝 쪽에 저작자의 집필 의도나 출판 경위 등을 밝혀 쓴 글로 일명 ‘후서’,‘발문’,‘발(跋)’으로도 표현.\n\n\n18\n부록\nappendix/ supplement\n본문과 관련 있는 보충 내용을 묶어 권말에 따로 넣은 부분. 용어풀이, 참고문헌, 찾아보기 등의 후첨. 일반 잡지 등의 간행물은 별도로 인쇄하여 펴내기도 함.\n\n\n19\n용어풀이\nglossary\n책 내용과 관련된 특수 용어나 전문 용어를 따로 모아 놓은 간단한 해설. 책의 권말 부록에 넣음.\n\n\n20\n참고문헌\nbibliography\n책의 본문에 참고·인용한 책이나 논문, 잡지 등의 문헌을 각 장 끝이나 권말에 붙여 넣음.\n\n\n21\n찾아보기\nindex\n본문 내용 중에 등장하는 인명이나 지명, 용어 등을 쉽게 찾아볼 수 있도록 가나다 순, 알파벳 순으로 배열하여 해당 페이지와 함께 권말에 편집해 놓은 목록으로 일명‘색인’이라고도 함."
  },
  {
    "objectID": "about_book.html#book-outer-extract",
    "href": "about_book.html#book-outer-extract",
    "title": "\n25  책과 편집 용어\n",
    "section": "\n25.1 PDF 에서 표 추출",
    "text": "25.1 PDF 에서 표 추출\nPDF에서 바로 표를 추출할 경우 기계판독 가능한 표이기는 하지만 형태가 뭉개져서 제대로 사용할 수 없다.\n이런 문제를 PDF 파일으로 워드로 변환시킨 후에 워드에서 표를 추출하는 방식을 동원한다. 자세한 사항은 워드 파일에서 표(table) 추출 하는 방식을 참고한다.\nPDF를 워드파일로 변경한 후에 officer 팩키지의 도움으로 테이블을 추출한다. 그리고 나서, 표를 추출한다.\n\nlibrary(tidyverse)\nlibrary(officer)\nlibrary(reactable)\n\nbook_docx &lt;- officer::read_docx(\"data/KSX0003_20091228.docx\")\nbook_content &lt;- docx_summary(book_docx) %&gt;% as_tibble()\n\n# book_content\n\ntable_cells &lt;- book_content %&gt;% \n  filter(content_type %in% \"table cell\") %&gt;% \n  as_tibble()\n\ncover_tbl &lt;- table_cells %&gt;% \n  filter(doc_index == 89) %&gt;% \n  select(text, row_id, cell_id) %&gt;% \n  pivot_wider(names_from = cell_id, values_from = text) %&gt;% \n  select(-row_id) \n\ncover_first_tbl &lt;- cover_tbl %&gt;% \n  set_names(cover_tbl %&gt;% slice(1)) %&gt;% \n  filter(row_number() != 1) %&gt;% \n  select(1,2,4,3)"
  },
  {
    "objectID": "about_book.html#book-outer-I",
    "href": "about_book.html#book-outer-I",
    "title": "\n25  책과 편집 용어\n",
    "section": "\n25.2 책 외부 (I) 명칭",
    "text": "25.2 책 외부 (I) 명칭\n책 외부(I) 명칭을 살펴보면 다음과 같다.\n\nlibrary(gt)\n\ncover_first_tbl |&gt; \n  gt() |&gt; \n  gt_theme_hangul()\n\n\n\n\n\n순\n      용 어\n      대응 영어\n      용어 정의\n    \n\n\n1\n앞표지\nfront cover\n책의 맨 겉장. 속장을 보호하기 위해 책 바깥쪽 앞뒤에 붙여 놓은 것으로, 본문보다 두꺼운 용지를 쓰며, 뒤의 표지는 뒤표지.\n\n\n2\n표제\ntitle\n책의 본문 전체 내용을 압축, 상징적으로 앞표지 등에 표시한 제목.\n\n\n3\n책섶\ngusset\n책의 등쪽 제본 재료를 앞표지까지 연결하여 표지를 단단하게 받쳐주도록 한 부분.\n\n\n4\n모서리\ncorner\n앞표지의 상하 귀퉁이. 양장본에서는 천이나 가죽을 표지 양 끝 모서리에 삼각형으로 붙여 표지를 보호하는 기능을 함.\n\n\n5\n표지턱\nsquare\n책 본문 속장과 표지 앞마구리 및 위·아래쪽에 튀어나온 난간 부분으로 양장본에만 존재.\n\n\n6\n책꼬리\ntail edge\n제본된 책의 맨 아래 밑쪽의 마구리 부분.\n\n\n7\n도랑\ngroove\n양장본의 두꺼운 앞∙뒤 표지와 책등의 경계에 도랑 모양의 골을 만들어 표지를 잘 여닫도록 한 홈.\n\n\n8\n머리챙\nawning/visor\n양장본의 책등쪽 위와 아래의 튀어나온 부분. 책의 머리띠를 보호하는 챙과 같은 기능을 함.\n\n\n9\n등글자\nback title\n책등이나덧표지,케이스의등쪽에넣는문자. 표제, 저자, 출판사 등의 표시.\n\n\n10\n등턱\njoint\n양장 제본에서, 책 표지의 도랑과 책등 모서리의 튀어나온 부분으로 일명 ‘책귀’라고도 함.\n\n\n11\n책등\nspine/back\n책 앞쪽 마구리의 반대 뒤쪽 부분. 양장본에서는 둥글거나 편편하게 마름하며, 표제·저자·출판사 등을 표시함.\n\n\n12\n책목\nbook neck\n책의 본문 속장과 등쪽 위·아래 양 끝의 접속 부위.\n\n\n13\n갈피끈\nbook-mark/ tassel/ ribbon/spin\n책장 속에 끼워 넣은 가는 끈으로 읽던 곳이나 필요한 지면을 다시 찾을 때 이용됨.\n\n\n\n\n\n\n워드 파일에서 이미지를 추출하는 방식은 워드 파일 압축을 풀면된다. 그렇게 하기 위해서 KSX0003_20091228.docx 파일명을 KSX0003_20091228.zip으로 바꾼 후에 압축을 풀어준다. 그러면 word/media 디렉토리에 이미지가 저장된다."
  },
  {
    "objectID": "about_book.html#book-outer-II",
    "href": "about_book.html#book-outer-II",
    "title": "\n25  책과 편집 용어\n",
    "section": "\n25.3 책 외부 (II) 명칭",
    "text": "25.3 책 외부 (II) 명칭\n책 외부 명칭(II)을 살펴보면 다음과 같다.\n\ncover_ii_tbl &lt;- table_cells %&gt;% \n  filter(doc_index == 116) %&gt;% \n  select(text, row_id, cell_id) %&gt;% \n  pivot_wider(names_from = cell_id, values_from = text) %&gt;% \n  select(-row_id) \n\ncover_second_tbl &lt;- cover_ii_tbl %&gt;% \n  set_names(cover_tbl %&gt;% slice(1)) %&gt;% \n  filter(row_number() != 1) %&gt;% \n  select(1,2,4,3) \n\ncover_second_tbl %&gt;% \n  reactable::reactable(\n    defaultColDef = colDef(\n    header = function(value) gsub(\".\", \" \", value, fixed = TRUE),\n    cell = function(value) format(value, nsmall = 1),\n    align = \"center\",\n    minWidth = 70,\n    headerStyle = list(background = \"#f7f7f8\")\n    ),\n    columns = list(\n    순 = colDef(minWidth = 40),   # 50% width, 200px minimum\n    `용 어` = colDef(minWidth = 100),   # 25% width, 100px minimum\n    `대응 영어` = colDef(minWidth = 150),   # 25% width, 100px minimum    \n    `용어 정의` = colDef(minWidth = 500)  # 25% width, 100px minimum\n    ),\n    bordered = TRUE,\n    highlight = TRUE,\n    filterable = TRUE\n  )\n\n\n\n\n\n워드 파일에서 이미지를 추출하는 방식은 워드 파일 압축을 풀면된다. 그렇게 하기 위해서 KSX0003_20091228.docx 파일명을 KSX0003_20091228.zip으로 바꾼 후에 압축을 풀어준다. 그러면 word/media 디렉토리에 이미지가 저장된다."
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "참고문헌",
    "section": "",
    "text": "Davis, M. (2010). Unicode nearing 50% of the web. https://googleblog.blogspot.com/2010/01/unicode-nearing-50-of-web.html\n\n\nHyde, A. (2021, August 16). Single source publishing - a\ninvestigation of what single source publishing is and how this ’holy\ngrail’ can be achieved. https://coko.foundation/articles/single-source-publishing.html\n\n\nLaan, K. van der. (1994). What is TEX and metafont all about?\n\n\nOliver, C. (2017). Internationalization part i: Unicode and\ncharacter encodings. https://slideplayer.com/slide/7684069/\n\n\nSpivak, M. (1990). The joy of∖TeX\n{}, a\ngourmet guide to typesetting with the∖AmSTeX {} macro\npackage: A gourmet guide to typesetting with the AMS-TEX macro\npackage. American Mathematical Soc.\n\n\n국가기술표준원. (2009, December 28). 책의 명칭 및 편집 일반\n용어. https://www.standard.go.kr/KSCI/standardIntro/getStandardSearchView.do?menuId=919&topMenuId=502&upperMenuId=503&ksNo=KSX0003&tmprKsNo=KSX0003&reformNo=03\n\n\n김영록. (2017). 교육 현장에서의 텍의 활용. TeX: 조판, 그 이상의\n가능성."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "챗GPT 디지털 글쓰기",
    "section": "",
    "text": "1 글쓰기\n글쓰기는 언어와 문자(Writing System) 언어와 문자 체계를 활용해 생각, 지식, 감정을 표현하는 창의적 과정이다. 글쓰기는 시각적 형태로 기록되어 말하기와 달리 시간과 공간의 제약을 받지 않는다. 과거 물리적 매체에 담겨 후대에 전달됨에 따라 일부 손상과 유실을 피할 수 없었다. 하지만, 현재는 다양한 디지털 문서 형태로 손실 없이 전달할 수 있게 되었다.\n글쓰기는 단순한 문장 구성을 넘어서 사회, 문화, 과학, 기술까지 다양한 분야에서 중추적 역할을 수행한다. 법률 문서와 계약서를 작성하여 사회적 규칙과 약속을 명확히 하고, 과학기술 지식을 문서화하여 현대 문명 발전을 촉진하고, 글쓰기는 교육과 학문에서 지식과 정보의 전달 및 공유 수단으로 세대 간 지식 전승했다. 문화와 예술 분야에서는 창의적 글쓰기가 감정과 생각을 표현하는 동시에 사람들을 연결하는 다리 역할을 했고 심리와 정신 건강 분야에서는 자기 반성과 성찰을 통한 개인의 성장과 치유에도 글쓰기가 활용되고 있다.\n이러한 다양한 역할을 넘어서, 글쓰기 목적과 형태도 지속적으로 발전하고 있다. 정보 전달, 감정 표현, 이야기 전달 등 기존 목적을 넘어서, 글쓰기는 수학과 과학 저작을 위한 TeX / LaTeX 같은 수식 표현도 포함되고, 더 나아가, 최근에 기계와 의사소통을 위한 프로그래밍 언어도 글쓰기의 범주에 포함되고 있다. 교육용 파이썬이나 통계와 데이터 과학, 그리고 과학기술 저작을 위한 R 언어와 같은 프로그래밍 언어들이 글쓰기의 새로운 영역으로 빠르게 편입되고 있다.\n현대 글쓰기의 특징 중 하나로 디지털 전환과 연결성을 꼽을 수 있고 그 중심에 인터넷과 웹의 출현이 있다. 인터넷이 전 세계 컴퓨터를 거대한 하나의 네트워크로 연결시켰다면, 웹은 인터넷 위에서 작동하는 정보 공간을 열었다. 인터넷과 웹은 글쓰기를 통한 커뮤니케이션을 글로벌 수준으로 확장시킴으로써 저자와 독자 사이 시공간적 제약을 크게 줄여, 다양한 문화와 언어 뿐만 아니라 그 이전 세대에서 경험하지 못한 정보와 지식의 융합을 가져왔으며, 실시간으로 정보를 주고받을 수 있어 신속한 글쓰기 측면도 크게 부각됐다.\n과거 글쓰기 매체가 주로 종이에 기반했다면, 웹의 출현은 웹사이트, 블로그, 소셜 미디어(SNS) 등 다양한 플랫폼에서 글을 작성하고 공유할 수 있게 되면서 독자가 저자에게 직접 피드백을 줄 수 있는 인터랙티브한 환경도 제공함에 따라 글쓰기는 단방향적인 정보 전달에서 양방향적인 대화로 빠르게 진화했다. 텍스트가 종이 매체에서 주류를 형성했다면, 웹이 바꾼 글쓰기 생산과 소비환경은 이미지, 비디오, 오디오, 데이터, 그래프, 다이어그램, 표, 코드 등 다양한 요소를 통합하여 글을 작성하는 새로운 방식이 가능해졌다.\n과거 글쓰기가 주로 물리적 매체, 즉 종이와 펜으로 대표되는 인쇄기술에 크게 의존해서 시간과 공간의 제약을 받았지만, 디지털 글쓰기 등장으로 이러한 제약과 위험은 크게 줄어들었다. 디지털 글쓰기는 웹사이트, 블로그, 소셜 미디어 등 다양한 플랫폼에서 텍스트, 이미지, 비디오, 오디오, 데이터 등 다양한 형태의 정보를 통합적으로 전달할 수 있고, 인터넷을 통해 전 세계 어디서든 접근하고 수정하고 공동저작할 수 있게 되었다.\n디지털 글쓰기 발전은 인공지능 기술의 급속한 성장과도 밀접하게 연결되어 있다. 프로그래밍 언어를 통한 코딩은 이제 기계와의 상호 커뮤니케이션을 위한 새로운 형태의 글쓰기로 간주되고 있다. 글쓰기는 단순한 정보 전달이나 감정 표현을 넘어, 고도화된 현대 사회의 기술적, 사회적, 제도적 인프라를 구축하고 유지하는 데에 필수적인 역할을 하고 있기 때문에 글쓰기 없이는 현대 사회의 복잡한 시스템과 그것을 지탱하는 기술이 존재할 수 없으며, 따라서 글쓰기는 현대 사회 생존에 있어서 불가결한 요소라고 할 수 있다."
  },
  {
    "objectID": "index.html#문서로-보는-민주주의",
    "href": "index.html#문서로-보는-민주주의",
    "title": "챗GPT 디지털 글쓰기",
    "section": "\n1.1 문서로 보는 민주주의",
    "text": "1.1 문서로 보는 민주주의\n글쓰기는 권력분립와 민주주의 체계에서 중요한 역할을 하고 있으며, 인공지능의 부상이 현체계를 더욱 복잡하게 만들지만 동시에 새로운 가능성도 열고 있다. 따라서, 챗GPT로 촉발된 인공지능 사회에서 글쓰기 중요성은 더욱 강조될 수 빡에 없다.\n삼권분립 원리는 국가의 권력을 입법, 사법, 행정으로 나누어 각기 다른 역할을 수행하게 함으로써 권력의 독점과 남용을 방지한다. 이 원리는 국민의 권리와 자유를 보장하는 국가 조직의 핵심 원칙으로, 인류 사회가 발전하면서 다양한 형태로 구현되어 왔다. 삼권분립 원리에서 글쓰기는 중추적인 역할을 차지하고 있다. 입법권은 법률을 ’작성’하고, 행정권은 법률을 ’실행’하며, 사법권은 법률을 ’해석’한다. 이 모든 과정은 문서와 글쓰기에 근간을 두고 있어, 글쓰기는 삼권분립 체계를 원활하게 작동시키는 뼈대라고 할 수 있다.\n최근 인공지능(AI)의 급속한 발전은 삼권분립 체계에 깊은 영향을 미치고 있다. 입법 분야에서 인공지능이 복잡한 법률 문서의 작성과 데이터 분석을 통한 새로운 법률의 필요성을 예측하고 있으며, 사법 분야에서는 판례 분석과 법률 문서 해석에 있어 뛰어난 능력을 보여, 판사와 변호사의 의사결정 과정을 적극적으로 지원하고 있다. 행정 분야에서는 인공지능이 정책 결정에 필요한 데이터 분석을 통해 통찰력을 제공하고, 코딩은 기계와 상호 커뮤니케이션 촉진함으로써 행정 서비스 효율성을 높이고, 국민에게 더 나은 서비스를 제공하도록 기여하고 있다.\n인공지능의 부상은 삼권분립 체계에서 각 분야의 작동 방식을 혁신적으로 변화시키며, 민주주의와 국가 운영에 새로운 가능성을 제시하고 있으나 항상 기술 발전은 윤리적, 사회적 측면에서도 신중한 검토가 필요하다. 인공지능의 결정 과정이 투명하지 않거나 데이터에 편향이 있을 경우, 민주주의 원칙에 위배되는 결과를 초래할 수 있어 문제점을 신중하게 검토하고 해결책을 마련하고 도입을 추진해야 된다.\n\n\n글쓰기와 삼권분립"
  },
  {
    "objectID": "index.html#글쓰기-역사",
    "href": "index.html#글쓰기-역사",
    "title": "챗GPT 디지털 글쓰기",
    "section": "\n1.2 글쓰기 역사",
    "text": "1.2 글쓰기 역사\n점토판과 쐐기를 이용한 문자 작성에서 시작하여 중세시대에는 동양에서는 붓과 머루를, 서양에서는 잉크와 새깃털펜을 사용해 저작을 했다. 타자기의 발명은 개인 저작을 가능하게 만들었고, 전동타자기의 등장은 문서 작성의 비용을 절감하고 품질을 향상시키며 출판 과정을 신속화했다. 제2차 세계대전 이후에는 군용 애니악(ENIAC) 컴퓨터가 민간에 보급되어 IBM이 1964년에 워드 프로세서를, 1969년에 저장 장치를 시장에 출시했다. 이로써 기계식 저작 방식에서 디지털 저작 방식으로 전환의 기반이 마련되었다. 1980년대 전후로 마이크로소프트 워드 1.0, 워드 퍼펙트, 아래한글과 같은 위지윅(WYSIWYG) 방식이 일반인에게 큰 인기를 끌었다면, 문서를 구조적으로 작성하여 컴파일하는 위지윔(WYSIWYM) 방식의 TeX / LaTeX 이 비슷한 시기에 과학기술 전문가들 사이에 자리를 잡아갔다.\n\n\n글쓰기 저작도구 진화과정\n\n\n1.2.1 문서 저작 패러다임\n아래한글이나 MS 워드 같은 워드 프로세서는 위지위그(WYSIWYG: What You See Is What You Get) 방식을 기반으로 한다. 이 방식은 화면에 보이는 서식이 입혀진 텍스트가 최종 출력물과 동일하게 나오는 직관적인 특성을 가진다. 이러한 장점 덕분에 타자기나 컴파일을 필요로 하는 다른 문서 저작 방식에 비해 경쟁력을 보이며 문서 저작의 주류 소프트웨어로 자리잡았다.\n반면, 위지윔(WYSIWYM: What You See Is What You Mean) 방식의 대표적인 예는 LaTeX(레이텍)이다. 이 방식은 구조화된 형태로 문서를 작성한 후 컴파일을 통해 출판 가능한 PDF 파일을 생성한다. LaTeX의 주요 장점은 수식, 그래프, 표 등 다양한 구성요소를 미려하게 표현할 수 있다는 것이다. 또한, “문학적 프로그래밍(literate programming)” 패러다임을 통해 텍스트와 코드를 함께 담을 수 있고 위지위그 방식 워드프로세서 보다 문서가 복잡할수록 진가를 보여준다.\n\n\n문서 저작 패러다임\n\n최근 문서저작 도구의 패러다임은 눈에 띄는 변화를 겪고 있다. 과거에는 일반 사용자를 위한 위지위그(WYSIWYG)와 과학기술 전문가를 위한 위지윔(WYSIWYM)이라는 두 가지 주요 패러다임으로 문서저작 도구가 명확하게 구분되었다. 그러나 최근에는 챗GPT가 촉발한 생성형 AI 기술이 위지위그 패러다임에 본격적으로 도입되어, 워드프로세서부터 엑셀, 파워포인트, 데이터베이스, 프로그래밍, 그리고 멀티미디어 저작까지 다양한 분야에서 발전이 가속화되고 있다. 위지윔 패러다임도 마크다운, 팬독(pandoc), R/Python, LaTeX 엔진 등 단위기술 발전과 함께 생성형 AI기술이 적극 반영된 RStudio, 주피터, VS코드와 같은 통합개발환경(IDE)의 발전을 통해 두 패러다임 경계가 점차 흐릿해지고 있다.\n문서저작의 복잡성이 증가함에 따라 재현성, 추적성, 협업, 코딩, 버전 제어, 자동화, 생산성이 중요한 저작 요소로 부상하고 있다. 이러한 복잡한 문서저작 문제에 대한 해결책으로 문학적 프로그래밍 패러다임이 주목받고 있다.\n\n1.2.2 문서 도구 역사\n사람과 의사소통하는 텍스트와 기계와 의사소통하는 프로그래밍 언어를 작성하는 방식은 서로 다르다. 텍스트는 문서를 작성하고, 프로그래밍 언어는 코드를 작성한다는 점에서 차이가 있지만, 모두 문서를 작성한다는 점에서 공통점이 있다. 문서 작성과 코드 통합은 오래 전부터 컴퓨터 과학과 데이터 과학에서 중요한 주제였다. 그 결과 다양한 해법이 제시되고 도구도 개발되었다.\n도널드 크누쓰 교수가 1978년 수식이 포함된 과학문서 작성에 특화되어 TeX를 개발하였고, 1984년 문학적 프로그래밍 개념을 제안하면서 텍스트와 코드를 섞어 문서와 프로그램을 동시에 작성할 수 있다는 것을 최초로 선보였다. 1985년에 레슬리 램포트가 TeX을 기반으로 LaTeX을 개발하여 수학과 과학 분야에서 널리 사용되는 문서저작 도구로 자리잡았다. (Knuth, 1984; Spivak, 1990) \n1988년에 울프람 박사가 매쓰매티카 노트북(Mathematica Notebooks)을 개발하여 수학과 과학 연구를 위한 고급 작업 환경을 제공했지만 한동안 특별한 도구나 개념의 진전은 없었지만 2000년대 들어서면서 2001년에 페르난도 페레즈가 파이썬 대화하여 IPython을 개발했고, 2003년에 이맥스(Emacs) 텍스트 편집기에서 동작하는 작업 관리 및 문서 작성 도구인 이맥스 Org-mode를 개발했다. 2004년에 존 그루버가 웹 문서를 쉽게 작성하고 표현할 수 있는 경량 마크업 언어 마크다운(Markdown)을 공개했다. 2006년부터 본격적으로 팬독(Pandoc) 개발이 시작되면서 다양한 마크업 언어 간 자유로운 변환이 가능하게 되었다. \n페르난도 페레즈는 2011년 파이썬 기반 iPython Notebook을 개발했고, 곧 이어 2012년 R 기반 knitr 개발이 본격화되었다. 2014년에 페르난도 페레즈가 다시 한번 다양한 프로그래밍 언어를 지원하는 주피터 프로젝트(Project Jupyter)를 주도하고 있으며, 2020년 RStudio로 잘 알려진 포짓(Posit) J.J. 알레어 대표가 과학기술 문서 작성과 데이터 과학에 특화된 쿼토(Quarto)를 개발하여 지속적으로 새로운 기능을 선보이고 있다.\n\n\n\n\n\n\n\n\nKnuth, D. E. (1984). Literate Programming. Comput. J., 27(2), 97–111. https://doi.org/10.1093/comjnl/27.2.97\n\n\nSpivak, M. (1990). The Joy of\\(\\backslash\\)TeX \\(\\{\\)\\(\\}\\), a Gourmet Guide to Typesetting with the\\(\\backslash\\)AmSTeX \\(\\{\\)\\(\\}\\) Macro Package: A Gourmet Guide to Typesetting with the AMS-TEX Macro Package. American Mathematical Soc."
  }
]